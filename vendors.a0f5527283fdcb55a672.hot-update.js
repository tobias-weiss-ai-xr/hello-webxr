webpackHotUpdate("vendors",{

/***/ "./node_modules/troika-3d-text/dist/textmesh-standalone.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/troika-3d-text/dist/textmesh-standalone.esm.js ***!
  \*********************************************************************/
/*! exports provided: GlyphsGeometry, TextMesh, configureTextBuilder, fontProcessorWorkerModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GlyphsGeometry\", function() { return GlyphsGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextMesh\", function() { return TextMesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"configureTextBuilder\", function() { return configureTextBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fontProcessorWorkerModule\", function() { return fontProcessorWorkerModule; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var troika_worker_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! troika-worker-utils */ \"./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js\");\n/* harmony import */ var troika_worker_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(troika_worker_utils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var troika_three_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! troika-three-utils */ \"./node_modules/troika-three-utils/dist/troika-three-utils.umd.js\");\n/* harmony import */ var troika_three_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(troika_three_utils__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n/**\n * Initializes and returns a function to generate an SDF texture for a given glyph.\n * @param {number} config.sdfTextureSize - the length of one side of the resulting texture image.\n *                 Larger images encode more details. Should be a power of 2.\n * @param {number} config.sdfDistancePercent - see docs for SDF_DISTANCE_PERCENT in TextBuilder.js\n *\n * @return {function(Object): {renderingBounds: [minX, minY, maxX, maxY], textureData: Uint8Array}}\n */\nfunction createSDFGenerator(config) {\n  var sdfTextureSize = config.sdfTextureSize;\n  var sdfDistancePercent = config.sdfDistancePercent;\n\n  /**\n   * How many straight line segments to use when approximating a glyph's quadratic/cubic bezier curves.\n   */\n  var CURVE_POINTS = 16;\n\n  var INF = Infinity;\n\n  /**\n   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t) {\n    var t2 = 1 - t;\n    return {\n      x: t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2,\n      y: t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2\n    }\n  }\n\n  /**\n   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t) {\n    var t2 = 1 - t;\n    return {\n      x: t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3,\n      y: t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3\n    }\n  }\n\n  /**\n   * You're such a square.\n   */\n  function square(n) {\n    return n * n\n  }\n\n  /**\n   * Find the absolute distance from a point to a line segment at closest approach\n   */\n  function absDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {\n    var ldx = lineX1 - lineX0;\n    var ldy = lineY1 - lineY0;\n    var lengthSq = square(ldx) + square(ldy);\n    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n    return Math.sqrt(square(x - (lineX0 + t * ldx)) + square(y - (lineY0 + t * ldy)))\n  }\n\n\n  /**\n   * Basic quadtree impl for performing fast spatial searches of a glyph's line segments\n   */\n  var GlyphSegmentsQuadtree = function GlyphSegmentsQuadtree(glyphObj) {\n    // Pick a good initial power-of-two bounding box that will hold all possible segments\n    var xMin = glyphObj.xMin;\n    var yMin = glyphObj.yMin;\n    var xMax = glyphObj.xMax;\n    var yMax = glyphObj.yMax;\n    var dx = xMax - xMin;\n    var dy = yMax - yMin;\n    var cx = Math.round(xMin + dx / 2);\n    var cy = Math.round(yMin + dy / 2);\n    var r = Math.pow(2, Math.floor(Math.log(Math.max(dx, dy)) * Math.LOG2E));\n\n    this._root = {\n      0: null,\n      1: null,\n      2: null,\n      3: null,\n      data: null,\n      cx: cx,\n      cy: cy,\n      r: r,\n      minX: INF,\n      minY: INF,\n      maxX: -INF,\n      maxY: -INF\n    };\n  };\n\n  GlyphSegmentsQuadtree.prototype.addLineSegment = function addLineSegment (x0, y0, x1, y1) {\n    var cx = (x0 + x1) / 2;\n    var cy = (y0 + y1) / 2;\n    var segment = {\n      x0: x0, y0: y0, x1: x1, y1: y1, cx: cx, cy: cy,\n      minX: Math.min(x0, x1),\n      minY: Math.min(y0, y1),\n      maxX: Math.max(x0, x1),\n      maxY: Math.max(y0, y1),\n      next: null\n    };\n    this._insertSegment(segment, this._root);\n  };\n\n  GlyphSegmentsQuadtree.prototype._insertSegment = function _insertSegment (segment, node) {\n    // update node min/max stats\n    var minX = segment.minX;\n      var minY = segment.minY;\n      var maxX = segment.maxX;\n      var maxY = segment.maxY;\n      var cx = segment.cx;\n      var cy = segment.cy;\n    if (minX < node.minX) { node.minX = minX; }\n    if (minY < node.minY) { node.minY = minY; }\n    if (maxX > node.maxX) { node.maxX = maxX; }\n    if (maxY > node.maxY) { node.maxY = maxY; }\n\n    // leaf\n    var leafSegment = node.data;\n    if (leafSegment) {\n      // coincident; push as linked list\n      if (leafSegment.cx === cx && leafSegment.cy === cy) {\n        while (leafSegment.next) { leafSegment = leafSegment.next; }\n        leafSegment.next = segment;\n      }\n      // non-coincident; split leaf to branch\n      else {\n        node.data = null;\n        this._insertSegment(leafSegment, node);\n        this._insertSegment(segment, node);\n      }\n    }\n    // branch\n    else {\n      // find target sub-index for the segment's centerpoint\n      var subIndex = (cy < node.cy ? 0 : 2) + (cx < node.cx ? 0 : 1);\n\n      // subnode already at index: recurse\n      if (node[subIndex]) {\n        this._insertSegment(segment, node[subIndex]);\n      }\n      // create new leaf\n      else {\n        node[subIndex] = {\n          0: null,\n          1: null,\n          2: null,\n          3: null,\n          data: segment,\n          cx: node.cx + node.r / 2 * (subIndex % 2 ? 1 : -1),\n          cy: node.cy + node.r / 2 * (subIndex < 2 ? -1 : 1),\n          r: node.r / 2,\n          minX: minX,\n          minY: minY,\n          maxX: maxX,\n          maxY: maxY\n        };\n      }\n    }\n  };\n\n  GlyphSegmentsQuadtree.prototype.walkTree = function walkTree (callback) {\n    this.walkBranch(this._root, callback);\n  };\n  GlyphSegmentsQuadtree.prototype.walkBranch = function walkBranch (root, callback) {\n    if (callback(root) !== false && !root.data) {\n      for (var i = 0; i < 4; i++) {\n        if (root[i] !== null) {\n          this.walkBranch(root[i], callback);\n        }\n      }\n    }\n  };\n\n  GlyphSegmentsQuadtree.prototype.findNearestSignedDistance = function findNearestSignedDistance (x, y, maxSearchRadius) {\n    var closestDist = maxSearchRadius;\n\n    this.walkTree(function visit(node) {\n      // Ignore nodes that can't possibly have segments closer than what we've already found. We base\n      // this on a simple rect bounds check; radial would be more accurate but much slower.\n      if (\n        x - closestDist > node.maxX || x + closestDist < node.minX ||\n        y - closestDist > node.maxY || y + closestDist < node.minY\n      ) {\n        return false\n      }\n\n      // Leaf - check each segment's actual distance\n      if (node.data) {\n        for (var segment = node.data; segment; segment = segment.next) {\n          if ( //fast prefilter for segment to avoid dist calc\n            x - closestDist < segment.maxX || x + closestDist > segment.minX ||\n            y - closestDist < segment.maxY || y + closestDist > segment.minY\n          ) {\n            var dist = absDistanceToLineSegment(x, y, segment.x0, segment.y0, segment.x1, segment.y1);\n            if (dist < closestDist) {\n              closestDist = dist;\n            }\n          }\n        }\n      }\n    });\n\n    // Flip to negative distance if outside the poly\n    if (!this.isPointInPoly(x, y)) {\n      closestDist = -closestDist;\n    }\n    return closestDist\n  };\n\n  GlyphSegmentsQuadtree.prototype.isPointInPoly = function isPointInPoly (x, y) {\n    var inside = false;\n    this.walkTree(function (node) {\n      // Ignore nodes whose bounds can't possibly cross our east-pointing ray\n      if (node.maxX < x || node.minY > y || node.maxY < y) {\n        return false\n      }\n\n      // Leaf - test each segment for whether it crosses our east-pointing ray\n      if (node.data) {\n        for (var segment = node.data; segment; segment = segment.next) {\n          var x0 = segment.x0;\n            var y0 = segment.y0;\n            var x1 = segment.x1;\n            var y1 = segment.y1;\n          var intersects = ((y0 > y) !== (y1 > y)) && (x < (x1 - x0) * (y - y0) / (y1 - y0) + x0);\n          if (intersects) {\n            inside = !inside;\n          }\n        }\n      }\n    });\n    return inside\n  };\n\n  /**\n   * Generate an SDF texture segment for a single glyph.\n   * @param {object} glyphObj\n   * @return {{textureData: Uint8Array, renderingBounds: *[]}}\n   */\n  function generateSDF(glyphObj) {\n    //console.time('glyphSDF')\n\n    var textureData = new Uint8Array(square(sdfTextureSize));\n\n    // Determine mapping between glyph grid coords and sdf grid coords\n    var glyphW = glyphObj.xMax - glyphObj.xMin;\n    var glyphH = glyphObj.yMax - glyphObj.yMin;\n\n    // Choose a maximum distance radius in font units, based on the glyph's max dimensions\n    var fontUnitsMaxDist = Math.max(glyphW, glyphH) * sdfDistancePercent;\n\n    // Use that, extending to the texture edges, to find conversion ratios between texture units and font units\n    var fontUnitsPerXTexel = (glyphW + fontUnitsMaxDist * 2) / sdfTextureSize;\n    var fontUnitsPerYTexel = (glyphH + fontUnitsMaxDist * 2) / sdfTextureSize;\n\n    var textureMinFontX = glyphObj.xMin - fontUnitsMaxDist - fontUnitsPerXTexel;\n    var textureMinFontY = glyphObj.yMin - fontUnitsMaxDist - fontUnitsPerYTexel;\n    var textureMaxFontX = glyphObj.xMax + fontUnitsMaxDist + fontUnitsPerXTexel;\n    var textureMaxFontY = glyphObj.yMax + fontUnitsMaxDist + fontUnitsPerYTexel;\n\n    function textureXToFontX(x) {\n      return textureMinFontX + (textureMaxFontX - textureMinFontX) * x / sdfTextureSize\n    }\n\n    function textureYToFontY(y) {\n      return textureMinFontY + (textureMaxFontY - textureMinFontY) * y / sdfTextureSize\n    }\n\n    if (glyphObj.pathCommandCount) { //whitespace chars will have no commands, so we can skip all this\n      // Decompose all paths into straight line segments and add them to a quadtree\n      var lineSegmentsIndex = new GlyphSegmentsQuadtree(glyphObj);\n      var firstX, firstY, prevX, prevY;\n      glyphObj.forEachPathCommand(function (type, x0, y0, x1, y1, x2, y2) {\n        switch (type) {\n          case 'M':\n            prevX = firstX = x0;\n            prevY = firstY = y0;\n            break\n          case 'L':\n            if (x0 !== prevX || y0 !== prevY) { //yup, some fonts have zero-length line commands\n              lineSegmentsIndex.addLineSegment(prevX, prevY, (prevX = x0), (prevY = y0));\n            }\n            break\n          case 'Q': {\n            var prevPoint = {x: prevX, y: prevY};\n            for (var i = 1; i < CURVE_POINTS; i++) {\n              var nextPoint = pointOnQuadraticBezier(\n                prevX, prevY,\n                x0, y0,\n                x1, y1,\n                i / (CURVE_POINTS - 1)\n              );\n              lineSegmentsIndex.addLineSegment(prevPoint.x, prevPoint.y, nextPoint.x, nextPoint.y);\n              prevPoint = nextPoint;\n            }\n            prevX = x1;\n            prevY = y1;\n            break\n          }\n          case 'C': {\n            var prevPoint$1 = {x: prevX, y: prevY};\n            for (var i$1 = 1; i$1 < CURVE_POINTS; i$1++) {\n              var nextPoint$1 = pointOnCubicBezier(\n                prevX, prevY,\n                x0, y0,\n                x1, y1,\n                x2, y2,\n                i$1 / (CURVE_POINTS - 1)\n              );\n              lineSegmentsIndex.addLineSegment(prevPoint$1.x, prevPoint$1.y, nextPoint$1.x, nextPoint$1.y);\n              prevPoint$1 = nextPoint$1;\n            }\n            prevX = x2;\n            prevY = y2;\n            break\n          }\n          case 'Z':\n            if (prevX !== firstX || prevY !== firstY) {\n              lineSegmentsIndex.addLineSegment(prevX, prevY, firstX, firstY);\n            }\n            break\n        }\n      });\n\n      // For each target SDF texel, find the distance from its center to its nearest line segment,\n      // map that distance to an alpha value, and write that alpha to the texel\n      for (var sdfX = 0; sdfX < sdfTextureSize; sdfX++) {\n        for (var sdfY = 0; sdfY < sdfTextureSize; sdfY++) {\n          var signedDist = lineSegmentsIndex.findNearestSignedDistance(\n            textureXToFontX(sdfX + 0.5),\n            textureYToFontY(sdfY + 0.5),\n            fontUnitsMaxDist\n          );\n          //if (!isFinite(signedDist)) throw 'infinite distance!'\n          var alpha = isFinite(signedDist) ? Math.round(255 * (1 + signedDist / fontUnitsMaxDist) * 0.5) : signedDist;\n          alpha = Math.max(0, Math.min(255, alpha)); //clamp\n          textureData[sdfY * sdfTextureSize + sdfX] = alpha;\n        }\n      }\n    }\n\n    //console.timeEnd('glyphSDF')\n\n    return {\n      textureData: textureData,\n\n      renderingBounds: [\n        textureMinFontX,\n        textureMinFontY,\n        textureMaxFontX,\n        textureMaxFontY\n      ]\n    }\n  }\n\n\n  return generateSDF\n}\n\n/**\n * Creates a self-contained environment for processing text rendering requests.\n *\n * It is important that this function has no external dependencies, so that it can be easily injected\n * into the source for a Worker without requiring a build step or complex dependency loading. Its sole\n * dependency, a `fontParser` implementation function, must be passed in at initialization.\n *\n * @param {function} fontParser - a function that accepts an ArrayBuffer of the font data and returns\n * a standardized structure giving access to the font and its glyphs:\n *   {\n *     unitsPerEm: number,\n *     ascender: number,\n *     descender: number,\n *     forEachGlyph(string, fontSize, letterSpacing, callback) {\n *       //invokes callback for each glyph to render, passing it an object:\n *       callback({\n *         index: number,\n *         advanceWidth: number,\n *         xMin: number,\n *         yMin: number,\n *         xMax: number,\n *         yMax: number,\n *         pathCommandCount: number,\n *         forEachPathCommand(callback) {\n *           //invokes callback for each path command, with args:\n *           callback(\n *             type: 'M|L|C|Q|Z',\n *             ...args //0 to 6 args depending on the type\n *           )\n *         }\n *       })\n *     }\n *   }\n * @param {function} sdfGenerator - a function that accepts a glyph object and generates an SDF texture\n * from it.\n * @param {Object} config\n * @return {Object}\n */\nfunction createFontProcessor(fontParser, sdfGenerator, config) {\n\n  var defaultFontUrl = config.defaultFontUrl;\n\n\n  /**\n   * @private\n   * Holds the loaded data for all fonts\n   *\n   * {\n   *   fontUrl: {\n   *     fontObj: {}, //result of the fontParser\n   *     glyphs: {\n   *       [glyphIndex]: {\n   *         atlasIndex: 0,\n   *         glyphObj: {}, //glyph object from the fontParser\n   *         renderingBounds: [x0, y0, x1, y1]\n   *       },\n   *       ...\n   *     },\n   *     glyphCount: 123\n   *   }\n   * }\n   */\n  var fonts = Object.create(null);\n\n  var INF = Infinity;\n\n\n  /**\n   * Load a given font url\n   */\n  function doLoadFont(url, callback) {\n    function tryLoad() {\n      var onError = function (err) {\n        console.error((\"Failure loading font \" + url + (url === defaultFontUrl ? '' : '; trying fallback')), err);\n        if (url !== defaultFontUrl) {\n          url = defaultFontUrl;\n          tryLoad();\n        }\n      };\n      try {\n        var request = new XMLHttpRequest();\n        request.open('get', url, true);\n        request.responseType = 'arraybuffer';\n        request.onload = function () {\n          if (request.status >= 400) {\n            onError(new Error(request.statusText));\n          }\n          else if (request.status > 0) {\n            try {\n              var fontObj = fontParser(request.response);\n              callback(fontObj);\n            } catch (e) {\n              onError(e);\n            }\n          }\n        };\n        request.onerror = onError;\n        request.send();\n      } catch(err) {\n        onError(err);\n      }\n    }\n    tryLoad();\n  }\n\n\n  /**\n   * Load a given font url if needed, invoking a callback when it's loaded. If already\n   * loaded, the callback will be called synchronously.\n   */\n  function loadFont(fontUrl, callback) {\n    if (!fontUrl) { fontUrl = defaultFontUrl; }\n    var atlas = fonts[fontUrl];\n    if (atlas) {\n      // if currently loading font, add to callbacks, otherwise execute immediately\n      if (atlas.onload) {\n        atlas.onload.push(callback);\n      } else {\n        callback();\n      }\n    } else {\n      var loadingAtlas = fonts[fontUrl] = {onload: [callback]};\n      doLoadFont(fontUrl, function (fontObj) {\n        atlas = fonts[fontUrl] = {\n          fontObj: fontObj,\n          glyphs: {},\n          glyphCount: 0\n        };\n        loadingAtlas.onload.forEach(function (cb) { return cb(); });\n      });\n    }\n  }\n\n\n  /**\n   * Get the atlas data for a given font url, loading it from the network and initializing\n   * its atlas data objects if necessary.\n   */\n  function getSdfAtlas(fontUrl, callback) {\n    if (!fontUrl) { fontUrl = defaultFontUrl; }\n    loadFont(fontUrl, function () {\n      callback(fonts[fontUrl]);\n    });\n  }\n\n\n  /**\n   * Main entry point.\n   * Process a text string with given font and formatting parameters, and return all info\n   * necessary to render all its glyphs.\n   */\n  function process(\n    ref,\n    callback,\n    metricsOnly\n  ) {\n    var text = ref.text; if ( text === void 0 ) text = '';\n    var font = ref.font; if ( font === void 0 ) font = defaultFontUrl;\n    var fontSize = ref.fontSize; if ( fontSize === void 0 ) fontSize = 1;\n    var letterSpacing = ref.letterSpacing; if ( letterSpacing === void 0 ) letterSpacing = 0;\n    var lineHeight = ref.lineHeight; if ( lineHeight === void 0 ) lineHeight = 'normal';\n    var maxWidth = ref.maxWidth; if ( maxWidth === void 0 ) maxWidth = INF;\n    var textAlign = ref.textAlign; if ( textAlign === void 0 ) textAlign = 'left';\n    var whiteSpace = ref.whiteSpace; if ( whiteSpace === void 0 ) whiteSpace = 'normal';\n    var overflowWrap = ref.overflowWrap; if ( overflowWrap === void 0 ) overflowWrap = 'normal';\n    var anchor = ref.anchor;\n    var includeCaretPositions = ref.includeCaretPositions; if ( includeCaretPositions === void 0 ) includeCaretPositions = false;\n    if ( metricsOnly === void 0 ) metricsOnly=false;\n\n    // Ensure newlines are normalized\n    if (text.indexOf('\\r') > -1) {\n      console.warn('FontProcessor.process: got text with \\\\r chars; normalizing to \\\\n');\n      text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n    }\n\n    getSdfAtlas(font, function (atlas) {\n      var fontObj = atlas.fontObj;\n      var hasMaxWidth = isFinite(maxWidth);\n      var newGlyphs = null;\n      var glyphBounds = null;\n      var glyphAtlasIndices = null;\n      var caretPositions = null;\n      var totalBounds = null;\n      var maxLineWidth = 0;\n      var canWrap = whiteSpace !== 'nowrap';\n      var ascender = fontObj.ascender;\n      var descender = fontObj.descender;\n      var unitsPerEm = fontObj.unitsPerEm;\n\n      // Find conversion between native font units and fontSize units; this will already be done\n      // for the gx/gy values below but everything else we'll need to convert\n      var fontSizeMult = fontSize / unitsPerEm;\n\n      // Determine appropriate value for 'normal' line height based on the font's actual metrics\n      // TODO this does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n      if (lineHeight === 'normal') {\n        lineHeight = (ascender - descender) / unitsPerEm;\n      }\n\n      // Determine line height and leading adjustments\n      lineHeight = lineHeight * fontSize;\n      var halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;\n      var caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);\n      var caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;\n\n      // Distribute glyphs into lines based on wrapping\n      var lineXOffset = 0;\n      var currentLine = {glyphs: [], width: 0};\n      var lines = [currentLine];\n      fontObj.forEachGlyph(text, fontSize, letterSpacing, function (glyphObj, glyphX, charIndex) {\n        var char = text.charAt(charIndex);\n        var glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n        var isWhitespace = !!char && /\\s/.test(char);\n        var curLineGlyphs = currentLine.glyphs;\n        var nextLineGlyphs;\n\n        // If a non-whitespace character overflows the max width, we need to soft-wrap\n        if (canWrap && hasMaxWidth && !isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineGlyphs.length) {\n          // If it's the first char after a whitespace, start a new line\n          if (curLineGlyphs[curLineGlyphs.length - 1].isWhitespace) {\n            nextLineGlyphs = [];\n            lineXOffset = -glyphX;\n          } else {\n            // Back up looking for a whitespace character to wrap at\n            for (var i = curLineGlyphs.length; i--;) {\n              // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n              if (i === 0 && overflowWrap === 'break-word') {\n                nextLineGlyphs = [];\n                lineXOffset = -glyphX;\n                break\n              }\n              // Found a soft break point; move all chars since it to a new line\n              else if (curLineGlyphs[i].isWhitespace) {\n                nextLineGlyphs = curLineGlyphs.splice(i + 1);\n                var adjustX = nextLineGlyphs[0].x;\n                lineXOffset -= adjustX;\n                for (var j = 0; j < nextLineGlyphs.length; j++) {\n                  nextLineGlyphs[j].x -= adjustX;\n                }\n                break\n              }\n            }\n          }\n          if (nextLineGlyphs) {\n            currentLine.isSoftWrapped = true;\n            currentLine = {glyphs: nextLineGlyphs, width: 0};\n            lines.push(currentLine);\n            maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n          }\n        }\n\n        currentLine.glyphs.push({\n          glyphObj: glyphObj,\n          x: glyphX + lineXOffset,\n          y: 0, //added later\n          width: glyphWidth,\n          char: char,\n          charIndex: charIndex,\n          isWhitespace: isWhitespace,\n          isEmpty: glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax,\n          atlasInfo: null //added later\n        });\n\n        // Handle hard line breaks\n        if (char === '\\n') {\n          currentLine = {glyphs: [], width: 0};\n          lines.push(currentLine);\n          lineXOffset = -(glyphX + glyphWidth);\n        }\n      });\n\n      // Calculate width of each line (excluding trailing whitespace) and maximum block width\n      lines.forEach(function (line) {\n        var lineGlyphs = line.glyphs;\n        for (var i = lineGlyphs.length; i--;) {\n          var lastChar = lineGlyphs[i];\n          if (!lastChar.isWhitespace) {\n            line.width = lastChar.x + lastChar.width;\n            if (line.width > maxLineWidth) {\n              maxLineWidth = line.width;\n            }\n            return\n          }\n        }\n      });\n\n      if (!metricsOnly) {\n        // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n        // collecting all renderable glyphs into a single collection.\n        var renderableGlyphs = [];\n        var lineYOffset = -(fontSize + halfLeading);\n        if (includeCaretPositions) {\n          caretPositions = new Float32Array(text.length * 3);\n        }\n        var prevCharIndex = -1;\n        lines.forEach(function (line) {\n          var lineGlyphs = line.glyphs;\n          var lineWidth = line.width;\n\n          // Ignore empty lines\n          if (lineGlyphs.length) {\n            // Find x offset for horizontal alignment\n            var lineXOffset = 0;\n            var whitespaceCount = 0;\n            if (textAlign === 'center') {\n              lineXOffset = (maxLineWidth - lineWidth) / 2;\n            } else if (textAlign === 'right') {\n              lineXOffset = maxLineWidth - lineWidth;\n            } else if (textAlign === 'justify') {\n              // just count the non-trailing whitespace characters, and we'll adjust the offsets per\n              // character in the next loop\n              for (var i = lineGlyphs.length; i--;) {\n                if (!lineGlyphs[i].isWhitespace) {\n                  while (i--) {\n                    if (lineGlyphs[i].isWhitespace) {\n                      whitespaceCount++;\n                    }\n                  }\n                  break\n                }\n              }\n            }\n\n            for (var i$1 = 0, len = lineGlyphs.length; i$1 < len; i$1++) {\n              var glyphInfo = lineGlyphs[i$1];\n\n              // Apply position adjustments\n              if (lineXOffset) { glyphInfo.x += lineXOffset; }\n              glyphInfo.y = lineYOffset;\n\n              // Expand whitespaces for justify alignment\n              if (glyphInfo.isWhitespace && textAlign === 'justify' && line.isSoftWrapped) {\n                var adjust = (maxLineWidth - lineWidth) / whitespaceCount;\n                lineXOffset += adjust;\n                glyphInfo.width += adjust;\n              }\n\n              // Add initial caret positions\n              if (includeCaretPositions) {\n                var charIndex = glyphInfo.charIndex;\n                caretPositions[charIndex * 3] = glyphInfo.x; //left edge x\n                caretPositions[charIndex * 3 + 1] = glyphInfo.x + glyphInfo.width; //right edge x\n                caretPositions[charIndex * 3 + 2] = glyphInfo.y + caretBottomOffset; //common bottom y\n\n                // If we skipped any chars from the previous glyph (due to ligature subs), copy the\n                // previous glyph's info to those missing char indices. In the future we may try to\n                // use the font's LigatureCaretList table to get interior caret positions.\n                while (charIndex - prevCharIndex > 1) {\n                  caretPositions[(prevCharIndex + 1) * 3] = caretPositions[prevCharIndex * 3 + 1];\n                  caretPositions[(prevCharIndex + 1) * 3 + 1] = caretPositions[prevCharIndex * 3 + 1];\n                  caretPositions[(prevCharIndex + 1) * 3 + 2] = caretPositions[prevCharIndex * 3 + 2];\n                  prevCharIndex++;\n                }\n                prevCharIndex = charIndex;\n              }\n\n              // Get atlas data for renderable glyphs\n              if (!glyphInfo.isWhitespace && !glyphInfo.isEmpty) {\n                var glyphObj = glyphInfo.glyphObj;\n\n                // If we haven't seen this glyph yet, generate its SDF\n                var glyphAtlasInfo = atlas.glyphs[glyphObj.index];\n                if (!glyphAtlasInfo) {\n                  var glyphSDFData = sdfGenerator(glyphObj);\n\n                  // Assign this glyph the next available atlas index\n                  glyphSDFData.atlasIndex = atlas.glyphCount++;\n\n                  // Queue it up in the response's newGlyphs list\n                  if (!newGlyphs) { newGlyphs = []; }\n                  newGlyphs.push(glyphSDFData);\n\n                  // Store its metadata (not the texture) in our atlas info\n                  glyphAtlasInfo = atlas.glyphs[glyphObj.index] = {\n                    atlasIndex: glyphSDFData.atlasIndex,\n                    glyphObj: glyphObj,\n                    renderingBounds: glyphSDFData.renderingBounds\n                  };\n                }\n                glyphInfo.atlasInfo = glyphAtlasInfo;\n\n                renderableGlyphs.push(glyphInfo);\n              }\n            }\n          }\n\n          // Increment y offset for next line\n          lineYOffset -= lineHeight;\n        });\n\n        // Find overall position adjustments for anchoring\n        var anchorXOffset = 0;\n        var anchorYOffset = 0;\n        if (anchor) {\n          // TODO allow string keywords?\n          if (anchor[0]) {\n            anchorXOffset = -maxLineWidth * anchor[0];\n          }\n          if (anchor[1]) {\n            anchorYOffset = lines.length * lineHeight * anchor[1];\n          }\n        }\n\n        // Adjust caret positions by anchoring offsets\n        if (includeCaretPositions && (anchorXOffset || anchorYOffset)) {\n          for (var i = 0, len = caretPositions.length; i < len; i += 3) {\n            caretPositions[i] += anchorXOffset;\n            caretPositions[i + 1] += anchorXOffset;\n            caretPositions[i + 2] += anchorYOffset;\n          }\n        }\n\n        // Create the final output for the rendeable glyphs\n        glyphBounds = new Float32Array(renderableGlyphs.length * 4);\n        glyphAtlasIndices = new Float32Array(renderableGlyphs.length);\n        totalBounds = [INF, INF, -INF, -INF];\n        renderableGlyphs.forEach(function (glyphInfo, i) {\n          var ref = glyphInfo.atlasInfo;\n          var renderingBounds = ref.renderingBounds;\n          var atlasIndex = ref.atlasIndex;\n          var x0 = glyphBounds[i * 4] = glyphInfo.x + renderingBounds[0] * fontSizeMult + anchorXOffset;\n          var y0 = glyphBounds[i * 4 + 1] = glyphInfo.y + renderingBounds[1] * fontSizeMult + anchorYOffset;\n          var x1 = glyphBounds[i * 4 + 2] = glyphInfo.x + renderingBounds[2] * fontSizeMult + anchorXOffset;\n          var y1 = glyphBounds[i * 4 + 3] = glyphInfo.y + renderingBounds[3] * fontSizeMult + anchorYOffset;\n\n          if (x0 < totalBounds[0]) { totalBounds[0] = x0; }\n          if (y0 < totalBounds[1]) { totalBounds[1] = y0; }\n          if (x1 > totalBounds[2]) { totalBounds[2] = x1; }\n          if (y1 > totalBounds[3]) { totalBounds[3] = y1; }\n\n          glyphAtlasIndices[i] = atlasIndex;\n        });\n      }\n\n      callback({\n        glyphBounds: glyphBounds, //rendering quad bounds for each glyph [x1, y1, x2, y2]\n        glyphAtlasIndices: glyphAtlasIndices, //atlas indices for each glyph\n        caretPositions: caretPositions, //x,y of bottom of cursor position before each char, plus one after last char\n        caretHeight: caretHeight, //height of cursor from bottom to top\n        totalBounds: totalBounds, //total rect including all glyphBounds; will be slightly larger than glyph edges due to SDF padding\n        totalBlockSize: [maxLineWidth, lines.length * lineHeight], //width and height of the text block; accurate for layout measurement\n        newGlyphSDFs: newGlyphs //if this request included any new SDFs for the atlas, they'll be included here\n      });\n    });\n  }\n\n\n  /**\n   * For a given text string and font parameters, determine the resulting block dimensions\n   * after wrapping for the given maxWidth.\n   * @param args\n   * @param callback\n   */\n  function measure(args, callback) {\n    process(args, function (result) {\n      callback({\n        width: result.totalBlockSize[0],\n        height: result.totalBlockSize[1]\n      });\n    }, {metricsOnly: true});\n  }\n\n  return {\n    process: process,\n    measure: measure,\n    loadFont: loadFont\n  }\n}\n\n// Custom bundle of Typr.js (https://github.com/photopea/Typr.js) for use in troika-3d-text. \n// Original MIT license applies: https://github.com/photopea/Typr.js/blob/gh-pages/LICENSE\n\nfunction typrFactory() {\n\nvar window = self;\n\n// Begin Typr.js\n\n\nvar Typr = {};\n\nTypr.parse = function(buff)\n{\n\tvar bin = Typr._bin;\n\tvar data = new Uint8Array(buff);\n\t\n\tvar tag = bin.readASCII(data, 0, 4);  \n\tif(tag==\"ttcf\") {\n\t\tvar offset = 4;\n\t\tvar majV = bin.readUshort(data, offset);  offset+=2;\n\t\tvar minV = bin.readUshort(data, offset);  offset+=2;\n\t\tvar numF = bin.readUint  (data, offset);  offset+=4;\n\t\tvar fnts = [];\n\t\tfor(var i=0; i<numF; i++) {\n\t\t\tvar foff = bin.readUint  (data, offset);  offset+=4;\n\t\t\tfnts.push(Typr._readFont(data, foff));\n\t\t}\n\t\treturn fnts;\n\t}\n\telse { return [Typr._readFont(data, 0)]; }\n};\n\nTypr._readFont = function(data, offset) {\n\tvar bin = Typr._bin;\n\tvar ooff = offset;\n\t\n\tvar sfnt_version = bin.readFixed(data, offset);\n\toffset += 4;\n\tvar numTables = bin.readUshort(data, offset);\n\toffset += 2;\n\tvar searchRange = bin.readUshort(data, offset);\n\toffset += 2;\n\tvar entrySelector = bin.readUshort(data, offset);\n\toffset += 2;\n\tvar rangeShift = bin.readUshort(data, offset);\n\toffset += 2;\n\t\n\tvar tags = [\n\t\t\"cmap\",\n\t\t\"head\",\n\t\t\"hhea\",\n\t\t\"maxp\",\n\t\t\"hmtx\",\n\t\t\"name\",\n\t\t\"OS/2\",\n\t\t\"post\",\n\t\t\n\t\t//\"cvt\",\n\t\t//\"fpgm\",\n\t\t\"loca\",\n\t\t\"glyf\",\n\t\t\"kern\",\n\t\t\n\t\t//\"prep\"\n\t\t//\"gasp\"\n\t\t\n\t\t\"CFF \",\n\t\t\n\t\t\n\t\t\"GPOS\",\n\t\t\"GSUB\",\n\t\t\n\t\t\"SVG \" ];\n\t\n\tvar obj = {_data:data, _offset:ooff};\n\t//console.log(sfnt_version, numTables, searchRange, entrySelector, rangeShift);\n\t\n\tvar tabs = {};\n\t\n\tfor(var i=0; i<numTables; i++)\n\t{\n\t\tvar tag = bin.readASCII(data, offset, 4);   offset += 4;\n\t\tvar checkSum = bin.readUint(data, offset);  offset += 4;\n\t\tvar toffset = bin.readUint(data, offset);   offset += 4;\n\t\tvar length = bin.readUint(data, offset);    offset += 4;\n\t\ttabs[tag] = {offset:toffset, length:length};\n\t\t\n\t\t//if(tags.indexOf(tag)==-1) console.log(\"unknown tag\", tag, length);\n\t}\n\t\n\tfor(var i=0; i< tags.length; i++)\n\t{\n\t\tvar t = tags[i];\n\t\t//console.log(t);\n\t\t//if(tabs[t]) console.log(t, tabs[t].offset, tabs[t].length);\n\t\tif(tabs[t]) { obj[t.trim()] = Typr[t.trim()].parse(data, tabs[t].offset, tabs[t].length, obj); }\n\t}\n\t\n\treturn obj;\n};\n\nTypr._tabOffset = function(data, tab, foff)\n{\n\tvar bin = Typr._bin;\n\tvar numTables = bin.readUshort(data, foff+4);\n\tvar offset = foff+12;\n\tfor(var i=0; i<numTables; i++)\n\t{\n\t\tvar tag = bin.readASCII(data, offset, 4);   offset += 4;\n\t\tvar checkSum = bin.readUint(data, offset);  offset += 4;\n\t\tvar toffset = bin.readUint(data, offset);   offset += 4;\n\t\tvar length = bin.readUint(data, offset);    offset += 4;\n\t\tif(tag==tab) { return toffset; }\n\t}\n\treturn 0;\n};\n\n\n\n\n\nTypr._bin = {\n\treadFixed : function(data, o)\n\t{\n\t\treturn ((data[o]<<8) | data[o+1]) +  (((data[o+2]<<8)|data[o+3])/(256*256+4));\n\t},\n\treadF2dot14 : function(data, o)\n\t{\n\t\tvar num = Typr._bin.readShort(data, o);\n\t\treturn num / 16384;\n\t},\n\treadInt : function(buff, p)\n\t{\n\t\t//if(p>=buff.length) throw \"error\";\n\t\tvar a = Typr._bin.t.uint8;\n\t\ta[0] = buff[p+3];\n\t\ta[1] = buff[p+2];\n\t\ta[2] = buff[p+1];\n\t\ta[3] = buff[p];\n\t\treturn Typr._bin.t.int32[0];\n\t},\n\t\n\treadInt8 : function(buff, p)\n\t{\n\t\t//if(p>=buff.length) throw \"error\";\n\t\tvar a = Typr._bin.t.uint8;\n\t\ta[0] = buff[p];\n\t\treturn Typr._bin.t.int8[0];\n\t},\n\treadShort : function(buff, p)\n\t{\n\t\t//if(p>=buff.length) throw \"error\";\n\t\tvar a = Typr._bin.t.uint8;\n\t\ta[1] = buff[p]; a[0] = buff[p+1];\n\t\treturn Typr._bin.t.int16[0];\n\t},\n\treadUshort : function(buff, p)\n\t{\n\t\t//if(p>=buff.length) throw \"error\";\n\t\treturn (buff[p]<<8) | buff[p+1];\n\t},\n\treadUshorts : function(buff, p, len)\n\t{\n\t\tvar arr = [];\n\t\tfor(var i=0; i<len; i++) { arr.push(Typr._bin.readUshort(buff, p+i*2)); }\n\t\treturn arr;\n\t},\n\treadUint : function(buff, p)\n\t{\n\t\t//if(p>=buff.length) throw \"error\";\n\t\tvar a = Typr._bin.t.uint8;\n\t\ta[3] = buff[p];  a[2] = buff[p+1];  a[1] = buff[p+2];  a[0] = buff[p+3];\n\t\treturn Typr._bin.t.uint32[0];\n\t},\n\treadUint64 : function(buff, p)\n\t{\n\t\t//if(p>=buff.length) throw \"error\";\n\t\treturn (Typr._bin.readUint(buff, p)*(0xffffffff+1)) + Typr._bin.readUint(buff, p+4);\n\t},\n\treadASCII : function(buff, p, l)\t// l : length in Characters (not Bytes)\n\t{\n\t\t//if(p>=buff.length) throw \"error\";\n\t\tvar s = \"\";\n\t\tfor(var i = 0; i < l; i++) { s += String.fromCharCode(buff[p+i]); }\n\t\treturn s;\n\t},\n\treadUnicode : function(buff, p, l)\n\t{\n\t\t//if(p>=buff.length) throw \"error\";\n\t\tvar s = \"\";\n\t\tfor(var i = 0; i < l; i++)\t\n\t\t{\n\t\t\tvar c = (buff[p++]<<8) | buff[p++];\n\t\t\ts += String.fromCharCode(c);\n\t\t}\n\t\treturn s;\n\t},\n\t_tdec : window[\"TextDecoder\"] ? new window[\"TextDecoder\"]() : null,\n\treadUTF8 : function(buff, p, l) {\n\t\tvar tdec = Typr._bin._tdec;\n\t\tif(tdec && p==0 && l==buff.length) { return tdec[\"decode\"](buff); }\n\t\treturn Typr._bin.readASCII(buff,p,l);\n\t},\n\treadBytes : function(buff, p, l)\n\t{\n\t\t//if(p>=buff.length) throw \"error\";\n\t\tvar arr = [];\n\t\tfor(var i=0; i<l; i++) { arr.push(buff[p+i]); }\n\t\treturn arr;\n\t},\n\treadASCIIArray : function(buff, p, l)\t// l : length in Characters (not Bytes)\n\t{\n\t\t//if(p>=buff.length) throw \"error\";\n\t\tvar s = [];\n\t\tfor(var i = 0; i < l; i++)\t\n\t\t\t{ s.push(String.fromCharCode(buff[p+i])); }\n\t\treturn s;\n\t}\n};\n\nTypr._bin.t = {\n\tbuff: new ArrayBuffer(8),\n};\nTypr._bin.t.int8   = new Int8Array  (Typr._bin.t.buff);\nTypr._bin.t.uint8  = new Uint8Array (Typr._bin.t.buff);\nTypr._bin.t.int16  = new Int16Array (Typr._bin.t.buff);\nTypr._bin.t.uint16 = new Uint16Array(Typr._bin.t.buff);\nTypr._bin.t.int32  = new Int32Array (Typr._bin.t.buff);\nTypr._bin.t.uint32 = new Uint32Array(Typr._bin.t.buff);\n\n\n\n\n\n// OpenType Layout Common Table Formats\n\nTypr._lctf = {};\n\nTypr._lctf.parse = function(data, offset, length, font, subt)\n{\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\tvar offset0 = offset;\n\tvar tableVersion = bin.readFixed(data, offset);  offset += 4;\n\t\n\tvar offScriptList  = bin.readUshort(data, offset);  offset += 2;\n\tvar offFeatureList = bin.readUshort(data, offset);  offset += 2;\n\tvar offLookupList  = bin.readUshort(data, offset);  offset += 2;\n\t\n\t\n\tobj.scriptList  = Typr._lctf.readScriptList (data, offset0 + offScriptList);\n\tobj.featureList = Typr._lctf.readFeatureList(data, offset0 + offFeatureList);\n\tobj.lookupList  = Typr._lctf.readLookupList (data, offset0 + offLookupList, subt);\n\t\n\treturn obj;\n};\n\nTypr._lctf.readLookupList = function(data, offset, subt)\n{\n\tvar bin = Typr._bin;\n\tvar offset0 = offset;\n\tvar obj = [];\n\tvar count = bin.readUshort(data, offset);  offset+=2;\n\tfor(var i=0; i<count; i++) \n\t{\n\t\tvar noff = bin.readUshort(data, offset);  offset+=2;\n\t\tvar lut = Typr._lctf.readLookupTable(data, offset0 + noff, subt);\n\t\tobj.push(lut);\n\t}\n\treturn obj;\n};\n\nTypr._lctf.readLookupTable = function(data, offset, subt)\n{\n\t//console.log(\"Parsing lookup table\", offset);\n\tvar bin = Typr._bin;\n\tvar offset0 = offset;\n\tvar obj = {tabs:[]};\n\t\n\tobj.ltype = bin.readUshort(data, offset);  offset+=2;\n\tobj.flag  = bin.readUshort(data, offset);  offset+=2;\n\tvar cnt   = bin.readUshort(data, offset);  offset+=2;\n\t\n\tfor(var i=0; i<cnt; i++)\n\t{\n\t\tvar noff = bin.readUshort(data, offset);  offset+=2;\n\t\tvar tab = subt(data, obj.ltype, offset0 + noff);\n\t\t//console.log(obj.type, tab);\n\t\tobj.tabs.push(tab);\n\t}\n\treturn obj;\n};\n\nTypr._lctf.numOfOnes = function(n)\n{\n\tvar num = 0;\n\tfor(var i=0; i<32; i++) { if(((n>>>i)&1) != 0) { num++; } }\n\treturn num;\n};\n\nTypr._lctf.readClassDef = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\tvar obj = [];\n\tvar format = bin.readUshort(data, offset);  offset+=2;\n\tif(format==1) \n\t{\n\t\tvar startGlyph  = bin.readUshort(data, offset);  offset+=2;\n\t\tvar glyphCount  = bin.readUshort(data, offset);  offset+=2;\n\t\tfor(var i=0; i<glyphCount; i++)\n\t\t{\n\t\t\tobj.push(startGlyph+i);\n\t\t\tobj.push(startGlyph+i);\n\t\t\tobj.push(bin.readUshort(data, offset));  offset+=2;\n\t\t}\n\t}\n\tif(format==2)\n\t{\n\t\tvar count = bin.readUshort(data, offset);  offset+=2;\n\t\tfor(var i=0; i<count; i++)\n\t\t{\n\t\t\tobj.push(bin.readUshort(data, offset));  offset+=2;\n\t\t\tobj.push(bin.readUshort(data, offset));  offset+=2;\n\t\t\tobj.push(bin.readUshort(data, offset));  offset+=2;\n\t\t}\n\t}\n\treturn obj;\n};\nTypr._lctf.getInterval = function(tab, val)\n{\n\tfor(var i=0; i<tab.length; i+=3)\n\t{\n\t\tvar start = tab[i], end = tab[i+1], index = tab[i+2];\n\t\tif(start<=val && val<=end) { return i; }\n\t}\n\treturn -1;\n};\n\n\nTypr._lctf.readCoverage = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\tvar cvg = {};\n\tcvg.fmt   = bin.readUshort(data, offset);  offset+=2;\n\tvar count = bin.readUshort(data, offset);  offset+=2;\n\t//console.log(\"parsing coverage\", offset-4, format, count);\n\tif(cvg.fmt==1) { cvg.tab = bin.readUshorts(data, offset, count); } \n\tif(cvg.fmt==2) { cvg.tab = bin.readUshorts(data, offset, count*3); }\n\treturn cvg;\n};\n\nTypr._lctf.coverageIndex = function(cvg, val)\n{\n\tvar tab = cvg.tab;\n\tif(cvg.fmt==1) { return tab.indexOf(val); }\n\tif(cvg.fmt==2) {\n\t\tvar ind = Typr._lctf.getInterval(tab, val);\n\t\tif(ind!=-1) { return tab[ind+2] + (val - tab[ind]); }\n\t}\n\treturn -1;\n};\n\nTypr._lctf.readFeatureList = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\tvar offset0 = offset;\n\tvar obj = [];\n\t\n\tvar count = bin.readUshort(data, offset);  offset+=2;\n\t\n\tfor(var i=0; i<count; i++)\n\t{\n\t\tvar tag = bin.readASCII(data, offset, 4);  offset+=4;\n\t\tvar noff = bin.readUshort(data, offset);  offset+=2;\n\t\tobj.push({tag: tag.trim(), tab:Typr._lctf.readFeatureTable(data, offset0 + noff)});\n\t}\n\treturn obj;\n};\n\nTypr._lctf.readFeatureTable = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\t\n\tvar featureParams = bin.readUshort(data, offset);  offset+=2;\t// = 0\n\tvar lookupCount = bin.readUshort(data, offset);  offset+=2;\n\t\n\tvar indices = [];\n\tfor(var i=0; i<lookupCount; i++) { indices.push(bin.readUshort(data, offset+2*i)); }\n\treturn indices;\n};\n\n\nTypr._lctf.readScriptList = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\tvar offset0 = offset;\n\tvar obj = {};\n\t\n\tvar count = bin.readUshort(data, offset);  offset+=2;\n\t\n\tfor(var i=0; i<count; i++)\n\t{\n\t\tvar tag = bin.readASCII(data, offset, 4);  offset+=4;\n\t\tvar noff = bin.readUshort(data, offset);  offset+=2;\n\t\tobj[tag.trim()] = Typr._lctf.readScriptTable(data, offset0 + noff);\n\t}\n\treturn obj;\n};\n\nTypr._lctf.readScriptTable = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\tvar offset0 = offset;\n\tvar obj = {};\n\t\n\tvar defLangSysOff = bin.readUshort(data, offset);  offset+=2;\n\tobj.default = Typr._lctf.readLangSysTable(data, offset0 + defLangSysOff);\n\t\n\tvar langSysCount = bin.readUshort(data, offset);  offset+=2;\n\t\n\tfor(var i=0; i<langSysCount; i++)\n\t{\n\t\tvar tag = bin.readASCII(data, offset, 4);  offset+=4;\n\t\tvar langSysOff = bin.readUshort(data, offset);  offset+=2;\n\t\tobj[tag.trim()] = Typr._lctf.readLangSysTable(data, offset0 + langSysOff);\n\t}\n\treturn obj;\n};\n\nTypr._lctf.readLangSysTable = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\t\n\tvar lookupOrder = bin.readUshort(data, offset);  offset+=2;\n\t//if(lookupOrder!=0)  throw \"lookupOrder not 0\";\n\tobj.reqFeature = bin.readUshort(data, offset);  offset+=2;\n\t//if(obj.reqFeature != 0xffff) throw \"reqFeatureIndex != 0xffff\";\n\t\n\t//console.log(lookupOrder, obj.reqFeature);\n\t\n\tvar featureCount = bin.readUshort(data, offset);  offset+=2;\n\tobj.features = bin.readUshorts(data, offset, featureCount);\n\treturn obj;\n};\n\n\tTypr.CFF = {};\n\tTypr.CFF.parse = function(data, offset, length)\n\t{\n\t\tvar bin = Typr._bin;\n\t\t\n\t\tdata = new Uint8Array(data.buffer, offset, length);\n\t\toffset = 0;\n\t\t\n\t\t// Header\n\t\tvar major = data[offset];  offset++;\n\t\tvar minor = data[offset];  offset++;\n\t\tvar hdrSize = data[offset];  offset++;\n\t\tvar offsize = data[offset];  offset++;\n\t\t//console.log(major, minor, hdrSize, offsize);\n\t\t\n\t\t// Name INDEX\n\t\tvar ninds = [];\n\t\toffset = Typr.CFF.readIndex(data, offset, ninds);\n\t\tvar names = [];\n\t\t\n\t\tfor(var i=0; i<ninds.length-1; i++) { names.push(bin.readASCII(data, offset+ninds[i], ninds[i+1]-ninds[i])); }\n\t\toffset += ninds[ninds.length-1];\n\t\t\n\t\t\n\t\t// Top DICT INDEX\n\t\tvar tdinds = [];\n\t\toffset = Typr.CFF.readIndex(data, offset, tdinds);  //console.log(tdinds);\n\t\t// Top DICT Data\n\t\tvar topDicts = [];\n\t\tfor(var i=0; i<tdinds.length-1; i++) { topDicts.push( Typr.CFF.readDict(data, offset+tdinds[i], offset+tdinds[i+1]) ); }\n\t\toffset += tdinds[tdinds.length-1];\n\t\tvar topdict = topDicts[0];\n\t\t//console.log(topdict);\n\t\t\n\t\t// String INDEX\n\t\tvar sinds = [];\n\t\toffset = Typr.CFF.readIndex(data, offset, sinds);\n\t\t// String Data\n\t\tvar strings = [];\n\t\tfor(var i=0; i<sinds.length-1; i++) { strings.push(bin.readASCII(data, offset+sinds[i], sinds[i+1]-sinds[i])); }\n\t\toffset += sinds[sinds.length-1];\n\t\t\n\t\t// Global Subr INDEX  (subroutines)\t\t\n\t\tTypr.CFF.readSubrs(data, offset, topdict);\n\t\t\n\t\t// charstrings\n\t\tif(topdict.CharStrings)\n\t\t{\n\t\t\toffset = topdict.CharStrings;\n\t\t\tvar sinds = [];\n\t\t\toffset = Typr.CFF.readIndex(data, offset, sinds);\n\t\t\t\n\t\t\tvar cstr = [];\n\t\t\tfor(var i=0; i<sinds.length-1; i++) { cstr.push(bin.readBytes(data, offset+sinds[i], sinds[i+1]-sinds[i])); }\n\t\t\t//offset += sinds[sinds.length-1];\n\t\t\ttopdict.CharStrings = cstr;\n\t\t\t//console.log(topdict.CharStrings);\n\t\t}\n\t\t\n\t\t// CID font\n\t\tif(topdict.ROS) {\n\t\t\toffset = topdict.FDArray;\n\t\t\tvar fdind = [];\n\t\t\toffset = Typr.CFF.readIndex(data, offset, fdind);\n\t\t\t\n\t\t\ttopdict.FDArray = [];\n\t\t\tfor(var i=0; i<fdind.length-1; i++) {\n\t\t\t\tvar dict = Typr.CFF.readDict(data, offset+fdind[i], offset+fdind[i+1]);\n\t\t\t\tTypr.CFF._readFDict(data, dict, strings);\n\t\t\t\ttopdict.FDArray.push( dict );\n\t\t\t}\n\t\t\toffset += fdind[fdind.length-1];\n\t\t\t\n\t\t\toffset = topdict.FDSelect;\n\t\t\ttopdict.FDSelect = [];\n\t\t\tvar fmt = data[offset];  offset++;\n\t\t\tif(fmt==3) {\n\t\t\t\tvar rns = bin.readUshort(data, offset);  offset+=2;\n\t\t\t\tfor(var i=0; i<rns+1; i++) {\n\t\t\t\t\ttopdict.FDSelect.push(bin.readUshort(data, offset), data[offset+2]);  offset+=3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { throw fmt; }\n\t\t}\n\t\t\n\t\t// Encoding\n\t\tif(topdict.Encoding) { topdict.Encoding = Typr.CFF.readEncoding(data, topdict.Encoding, topdict.CharStrings.length); }\n\t\t\n\t\t// charset\n\t\tif(topdict.charset ) { topdict.charset  = Typr.CFF.readCharset (data, topdict.charset , topdict.CharStrings.length); }\n\t\t\n\t\tTypr.CFF._readFDict(data, topdict, strings);\n\t\treturn topdict;\n\t};\n\tTypr.CFF._readFDict = function(data, dict, ss) {\n\t\tvar offset;\n\t\tif(dict.Private) {\n\t\t\toffset = dict.Private[1];\n\t\t\tdict.Private = Typr.CFF.readDict(data, offset, offset+dict.Private[0]);\n\t\t\tif(dict.Private.Subrs)  { Typr.CFF.readSubrs(data, offset+dict.Private.Subrs, dict.Private); }\n\t\t}\n\t\tfor(var p in dict) { if([\"FamilyName\",\"FontName\",\"FullName\",\"Notice\",\"version\",\"Copyright\"].indexOf(p)!=-1)  { dict[p]=ss[dict[p] -426 + 35]; } }\n\t};\n\t\n\tTypr.CFF.readSubrs = function(data, offset, obj)\n\t{\n\t\tvar bin = Typr._bin;\n\t\tvar gsubinds = [];\n\t\toffset = Typr.CFF.readIndex(data, offset, gsubinds);\n\t\t\n\t\tvar bias, nSubrs = gsubinds.length;\n\t\tif (nSubrs <  1240) { bias = 107; }\n\t\telse if (nSubrs < 33900) { bias = 1131; }\n\t\telse { bias = 32768; }\n\t\tobj.Bias = bias;\n\t\t\n\t\tobj.Subrs = [];\n\t\tfor(var i=0; i<gsubinds.length-1; i++) { obj.Subrs.push(bin.readBytes(data, offset+gsubinds[i], gsubinds[i+1]-gsubinds[i])); }\n\t\t//offset += gsubinds[gsubinds.length-1];\n\t};\n\t\n\tTypr.CFF.tableSE = [\n      0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,\n      1,   2,   3,   4,   5,   6,   7,   8,\n      9,  10,  11,  12,  13,  14,  15,  16,\n     17,  18,  19,  20,  21,  22,  23,  24,\n     25,  26,  27,  28,  29,  30,  31,  32,\n     33,  34,  35,  36,  37,  38,  39,  40,\n     41,  42,  43,  44,  45,  46,  47,  48,\n     49,  50,  51,  52,  53,  54,  55,  56,\n     57,  58,  59,  60,  61,  62,  63,  64,\n     65,  66,  67,  68,  69,  70,  71,  72,\n     73,  74,  75,  76,  77,  78,  79,  80,\n     81,  82,  83,  84,  85,  86,  87,  88,\n     89,  90,  91,  92,  93,  94,  95,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,\n      0,  96,  97,  98,  99, 100, 101, 102,\n    103, 104, 105, 106, 107, 108, 109, 110,\n      0, 111, 112, 113, 114,   0, 115, 116,\n    117, 118, 119, 120, 121, 122,   0, 123,\n      0, 124, 125, 126, 127, 128, 129, 130,\n    131,   0, 132, 133,   0, 134, 135, 136,\n    137,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,\n      0, 138,   0, 139,   0,   0,   0,   0,\n    140, 141, 142, 143,   0,   0,   0,   0,\n      0, 144,   0,   0,   0, 145,   0,   0,\n    146, 147, 148, 149,   0,   0,   0,   0\n  ];\n  \n\tTypr.CFF.glyphByUnicode = function(cff, code)\n\t{\n\t\tfor(var i=0; i<cff.charset.length; i++) { if(cff.charset[i]==code) { return i; } }\n\t\treturn -1;\n\t};\n\t\n\tTypr.CFF.glyphBySE = function(cff, charcode)\t// glyph by standard encoding\n\t{\n\t\tif ( charcode < 0 || charcode > 255 ) { return -1; }\n\t\treturn Typr.CFF.glyphByUnicode(cff, Typr.CFF.tableSE[charcode]);\t\t\n\t};\n\t\n\tTypr.CFF.readEncoding = function(data, offset, num)\n\t{\n\t\tvar bin = Typr._bin;\n\t\t\n\t\tvar array = ['.notdef'];\n\t\tvar format = data[offset];  offset++;\n\t\t//console.log(\"Encoding\");\n\t\t//console.log(format);\n\t\t\n\t\tif(format==0)\n\t\t{\n\t\t\tvar nCodes = data[offset];  offset++;\n\t\t\tfor(var i=0; i<nCodes; i++)  { array.push(data[offset+i]); }\n\t\t}\n\t\t/*\n\t\telse if(format==1 || format==2)\n\t\t{\n\t\t\twhile(charset.length<num)\n\t\t\t{\n\t\t\t\tvar first = bin.readUshort(data, offset);  offset+=2;\n\t\t\t\tvar nLeft=0;\n\t\t\t\tif(format==1) {  nLeft = data[offset];  offset++;  }\n\t\t\t\telse          {  nLeft = bin.readUshort(data, offset);  offset+=2;  }\n\t\t\t\tfor(var i=0; i<=nLeft; i++)  {  charset.push(first);  first++;  }\n\t\t\t}\n\t\t}\n\t\t*/\n\t\telse { throw \"error: unknown encoding format: \" + format; }\n\t\t\n\t\treturn array;\n\t};\n\n\tTypr.CFF.readCharset = function(data, offset, num)\n\t{\n\t\tvar bin = Typr._bin;\n\t\t\n\t\tvar charset = ['.notdef'];\n\t\tvar format = data[offset];  offset++;\n\t\t\n\t\tif(format==0)\n\t\t{\n\t\t\tfor(var i=0; i<num; i++) \n\t\t\t{\n\t\t\t\tvar first = bin.readUshort(data, offset);  offset+=2;\n\t\t\t\tcharset.push(first);\n\t\t\t}\n\t\t}\n\t\telse if(format==1 || format==2)\n\t\t{\n\t\t\twhile(charset.length<num)\n\t\t\t{\n\t\t\t\tvar first = bin.readUshort(data, offset);  offset+=2;\n\t\t\t\tvar nLeft=0;\n\t\t\t\tif(format==1) {  nLeft = data[offset];  offset++;  }\n\t\t\t\telse          {  nLeft = bin.readUshort(data, offset);  offset+=2;  }\n\t\t\t\tfor(var i=0; i<=nLeft; i++)  {  charset.push(first);  first++;  }\n\t\t\t}\n\t\t}\n\t\telse { throw \"error: format: \" + format; }\n\t\t\n\t\treturn charset;\n\t};\n\n\tTypr.CFF.readIndex = function(data, offset, inds)\n\t{\n\t\tvar bin = Typr._bin;\n\t\t\n\t\tvar count = bin.readUshort(data, offset)+1;  offset+=2;\n\t\tvar offsize = data[offset];  offset++;\n\t\t\n\t\tif     (offsize==1) { for(var i=0; i<count; i++) { inds.push( data[offset+i] ); } }\n\t\telse if(offsize==2) { for(var i=0; i<count; i++) { inds.push( bin.readUshort(data, offset+i*2) ); } }\n\t\telse if(offsize==3) { for(var i=0; i<count; i++) { inds.push( bin.readUint  (data, offset+i*3 - 1) & 0x00ffffff ); } }\n\t\telse if(count!=1) { throw \"unsupported offset size: \" + offsize + \", count: \" + count; }\n\t\t\n\t\toffset += count*offsize;\n\t\treturn offset-1;\n\t};\n\t\n\tTypr.CFF.getCharString = function(data, offset, o)\n\t{\n\t\tvar bin = Typr._bin;\n\t\t\n\t\tvar b0 = data[offset], b1 = data[offset+1], b2 = data[offset+2], b3 = data[offset+3], b4=data[offset+4];\n\t\tvar vs = 1;\n\t\tvar op=null, val=null;\n\t\t// operand\n\t\tif(b0<=20) { op = b0;  vs=1;  }\n\t\tif(b0==12) { op = b0*100+b1;  vs=2;  }\n\t\t//if(b0==19 || b0==20) { op = b0/*+\" \"+b1*/;  vs=2; }\n\t\tif(21 <=b0 && b0<= 27) { op = b0;  vs=1; }\n\t\tif(b0==28) { val = bin.readShort(data,offset+1);  vs=3; }\n\t\tif(29 <=b0 && b0<= 31) { op = b0;  vs=1; }\n\t\tif(32 <=b0 && b0<=246) { val = b0-139;  vs=1; }\n\t\tif(247<=b0 && b0<=250) { val = (b0-247)*256+b1+108;  vs=2; }\n\t\tif(251<=b0 && b0<=254) { val =-(b0-251)*256-b1-108;  vs=2; }\n\t\tif(b0==255) {  val = bin.readInt(data, offset+1)/0xffff;  vs=5;   }\n\t\t\n\t\to.val = val!=null ? val : \"o\"+op;\n\t\to.size = vs;\n\t};\n\t\n\tTypr.CFF.readCharString = function(data, offset, length)\n\t{\n\t\tvar end = offset + length;\n\t\tvar bin = Typr._bin;\n\t\tvar arr = [];\n\t\t\n\t\twhile(offset<end)\n\t\t{\n\t\t\tvar b0 = data[offset], b1 = data[offset+1], b2 = data[offset+2], b3 = data[offset+3], b4=data[offset+4];\n\t\t\tvar vs = 1;\n\t\t\tvar op=null, val=null;\n\t\t\t// operand\n\t\t\tif(b0<=20) { op = b0;  vs=1;  }\n\t\t\tif(b0==12) { op = b0*100+b1;  vs=2;  }\n\t\t\tif(b0==19 || b0==20) { op = b0/*+\" \"+b1*/;  vs=2; }\n\t\t\tif(21 <=b0 && b0<= 27) { op = b0;  vs=1; }\n\t\t\tif(b0==28) { val = bin.readShort(data,offset+1);  vs=3; }\n\t\t\tif(29 <=b0 && b0<= 31) { op = b0;  vs=1; }\n\t\t\tif(32 <=b0 && b0<=246) { val = b0-139;  vs=1; }\n\t\t\tif(247<=b0 && b0<=250) { val = (b0-247)*256+b1+108;  vs=2; }\n\t\t\tif(251<=b0 && b0<=254) { val =-(b0-251)*256-b1-108;  vs=2; }\n\t\t\tif(b0==255) {  val = bin.readInt(data, offset+1)/0xffff;  vs=5;   }\n\t\t\t\n\t\t\tarr.push(val!=null ? val : \"o\"+op);\n\t\t\toffset += vs;\t\n\n\t\t\t//var cv = arr[arr.length-1];\n\t\t\t//if(cv==undefined) throw \"error\";\n\t\t\t//console.log()\n\t\t}\t\n\t\treturn arr;\n\t};\n\n\tTypr.CFF.readDict = function(data, offset, end)\n\t{\n\t\tvar bin = Typr._bin;\n\t\t//var dict = [];\n\t\tvar dict = {};\n\t\tvar carr = [];\n\t\t\n\t\twhile(offset<end)\n\t\t{\n\t\t\tvar b0 = data[offset], b1 = data[offset+1], b2 = data[offset+2], b3 = data[offset+3], b4=data[offset+4];\n\t\t\tvar vs = 1;\n\t\t\tvar key=null, val=null;\n\t\t\t// operand\n\t\t\tif(b0==28) { val = bin.readShort(data,offset+1);  vs=3; }\n\t\t\tif(b0==29) { val = bin.readInt  (data,offset+1);  vs=5; }\n\t\t\tif(32 <=b0 && b0<=246) { val = b0-139;  vs=1; }\n\t\t\tif(247<=b0 && b0<=250) { val = (b0-247)*256+b1+108;  vs=2; }\n\t\t\tif(251<=b0 && b0<=254) { val =-(b0-251)*256-b1-108;  vs=2; }\n\t\t\tif(b0==255) {  val = bin.readInt(data, offset+1)/0xffff;  vs=5;  throw \"unknown number\";  }\n\t\t\t\n\t\t\tif(b0==30) \n\t\t\t{  \n\t\t\t\tvar nibs = [];\n\t\t\t\tvs = 1;\n\t\t\t\twhile(true)\n\t\t\t\t{\n\t\t\t\t\tvar b = data[offset+vs];  vs++;\n\t\t\t\t\tvar nib0 = b>>4, nib1 = b&0xf;\n\t\t\t\t\tif(nib0 != 0xf) { nibs.push(nib0); }  if(nib1!=0xf) { nibs.push(nib1); }\n\t\t\t\t\tif(nib1==0xf) { break; }\n\t\t\t\t}\n\t\t\t\tvar s = \"\";\n\t\t\t\tvar chars = [0,1,2,3,4,5,6,7,8,9,\".\",\"e\",\"e-\",\"reserved\",\"-\",\"endOfNumber\"];\n\t\t\t\tfor(var i=0; i<nibs.length; i++) { s += chars[nibs[i]]; }\n\t\t\t\t//console.log(nibs);\n\t\t\t\tval = parseFloat(s);\n\t\t\t}\n\t\t\t\n\t\t\tif(b0<=21)\t// operator\n\t\t\t{\n\t\t\t\tvar keys = [\"version\", \"Notice\", \"FullName\", \"FamilyName\", \"Weight\", \"FontBBox\", \"BlueValues\", \"OtherBlues\", \"FamilyBlues\",\"FamilyOtherBlues\",\n\t\t\t\t\t\"StdHW\", \"StdVW\", \"escape\", \"UniqueID\", \"XUID\", \"charset\", \"Encoding\", \"CharStrings\", \"Private\", \"Subrs\", \n\t\t\t\t\t\"defaultWidthX\", \"nominalWidthX\"];\n\t\t\t\t\t\n\t\t\t\tkey = keys[b0];  vs=1;\n\t\t\t\tif(b0==12) { \n\t\t\t\t\tvar keys = [ \"Copyright\", \"isFixedPitch\", \"ItalicAngle\", \"UnderlinePosition\", \"UnderlineThickness\", \"PaintType\", \"CharstringType\", \"FontMatrix\", \"StrokeWidth\", \"BlueScale\",\n\t\t\t\t\t\"BlueShift\", \"BlueFuzz\", \"StemSnapH\", \"StemSnapV\", \"ForceBold\", 0,0, \"LanguageGroup\", \"ExpansionFactor\", \"initialRandomSeed\",\n\t\t\t\t\t\"SyntheticBase\", \"PostScript\", \"BaseFontName\", \"BaseFontBlend\", 0,0,0,0,0,0, \n\t\t\t\t\t\"ROS\", \"CIDFontVersion\", \"CIDFontRevision\", \"CIDFontType\", \"CIDCount\", \"UIDBase\", \"FDArray\", \"FDSelect\", \"FontName\"];\n\t\t\t\t\tkey = keys[b1];  vs=2; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(key!=null) {  dict[key] = carr.length==1 ? carr[0] : carr;  carr=[]; }\n\t\t\telse  { carr.push(val); }  \n\t\t\t\n\t\t\toffset += vs;\t\t\n\t\t}\t\n\t\treturn dict;\n\t};\n\n\nTypr.cmap = {};\nTypr.cmap.parse = function(data, offset, length)\n{\n\tdata = new Uint8Array(data.buffer, offset, length);\n\toffset = 0;\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\tvar version   = bin.readUshort(data, offset);  offset += 2;\n\tvar numTables = bin.readUshort(data, offset);  offset += 2;\n\t\n\t//console.log(version, numTables);\n\t\n\tvar offs = [];\n\tobj.tables = [];\n\t\n\t\n\tfor(var i=0; i<numTables; i++)\n\t{\n\t\tvar platformID = bin.readUshort(data, offset);  offset += 2;\n\t\tvar encodingID = bin.readUshort(data, offset);  offset += 2;\n\t\tvar noffset = bin.readUint(data, offset);       offset += 4;\n\t\t\n\t\tvar id = \"p\"+platformID+\"e\"+encodingID;\n\t\t\n\t\t//console.log(\"cmap subtable\", platformID, encodingID, noffset);\n\t\t\n\t\t\n\t\tvar tind = offs.indexOf(noffset);\n\t\t\n\t\tif(tind==-1)\n\t\t{\n\t\t\ttind = obj.tables.length;\n\t\t\tvar subt;\n\t\t\toffs.push(noffset);\n\t\t\tvar format = bin.readUshort(data, noffset);\n\t\t\tif     (format== 0) { subt = Typr.cmap.parse0(data, noffset); }\n\t\t\telse if(format== 4) { subt = Typr.cmap.parse4(data, noffset); }\n\t\t\telse if(format== 6) { subt = Typr.cmap.parse6(data, noffset); }\n\t\t\telse if(format==12) { subt = Typr.cmap.parse12(data,noffset); }\n\t\t\telse { console.log(\"unknown format: \"+format, platformID, encodingID, noffset); }\n\t\t\tobj.tables.push(subt);\n\t\t}\n\t\t\n\t\tif(obj[id]!=null) { throw \"multiple tables for one platform+encoding\"; }\n\t\tobj[id] = tind;\n\t}\n\treturn obj;\n};\n\nTypr.cmap.parse0 = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\tobj.format = bin.readUshort(data, offset);  offset += 2;\n\tvar len    = bin.readUshort(data, offset);  offset += 2;\n\tvar lang   = bin.readUshort(data, offset);  offset += 2;\n\tobj.map = [];\n\tfor(var i=0; i<len-6; i++) { obj.map.push(data[offset+i]); }\n\treturn obj;\n};\n\nTypr.cmap.parse4 = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\tvar offset0 = offset;\n\tvar obj = {};\n\t\n\tobj.format = bin.readUshort(data, offset);  offset+=2;\n\tvar length = bin.readUshort(data, offset);  offset+=2;\n\tvar language = bin.readUshort(data, offset);  offset+=2;\n\tvar segCountX2 = bin.readUshort(data, offset);  offset+=2;\n\tvar segCount = segCountX2/2;\n\tobj.searchRange = bin.readUshort(data, offset);  offset+=2;\n\tobj.entrySelector = bin.readUshort(data, offset);  offset+=2;\n\tobj.rangeShift = bin.readUshort(data, offset);  offset+=2;\n\tobj.endCount   = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n\toffset+=2;\n\tobj.startCount = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n\tobj.idDelta = [];\n\tfor(var i=0; i<segCount; i++) {obj.idDelta.push(bin.readShort(data, offset));  offset+=2;}\n\tobj.idRangeOffset = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n\tobj.glyphIdArray = [];\n\twhile(offset< offset0+length) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\n\treturn obj;\n};\n\nTypr.cmap.parse6 = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\t\n\tobj.format = bin.readUshort(data, offset);  offset+=2;\n\tvar length = bin.readUshort(data, offset);  offset+=2;\n\tvar language = bin.readUshort(data, offset);  offset+=2;\n\tobj.firstCode = bin.readUshort(data, offset);  offset+=2;\n\tvar entryCount = bin.readUshort(data, offset);  offset+=2;\n\tobj.glyphIdArray = [];\n\tfor(var i=0; i<entryCount; i++) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\n\t\n\treturn obj;\n};\n\nTypr.cmap.parse12 = function(data, offset)\n{\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\t\n\tobj.format = bin.readUshort(data, offset);  offset+=2;\n\toffset += 2;\n\tvar length = bin.readUint(data, offset);  offset+=4;\n\tvar lang   = bin.readUint(data, offset);  offset+=4;\n\tvar nGroups= bin.readUint(data, offset);  offset+=4;\n\tobj.groups = [];\n\t\n\tfor(var i=0; i<nGroups; i++)  \n\t{\n\t\tvar off = offset + i * 12;\n\t\tvar startCharCode = bin.readUint(data, off+0);\n\t\tvar endCharCode   = bin.readUint(data, off+4);\n\t\tvar startGlyphID  = bin.readUint(data, off+8);\n\t\tobj.groups.push([  startCharCode, endCharCode, startGlyphID  ]);\n\t}\n\treturn obj;\n};\n\nTypr.glyf = {};\nTypr.glyf.parse = function(data, offset, length, font)\n{\n\tvar obj = [];\n\tfor(var g=0; g<font.maxp.numGlyphs; g++) { obj.push(null); }\n\treturn obj;\n};\n\nTypr.glyf._parseGlyf = function(font, g)\n{\n\tvar bin = Typr._bin;\n\tvar data = font._data;\n\t\n\tvar offset = Typr._tabOffset(data, \"glyf\", font._offset) + font.loca[g];\n\t\t\n\tif(font.loca[g]==font.loca[g+1]) { return null; }\n\t\t\n\tvar gl = {};\n\t\t\n\tgl.noc  = bin.readShort(data, offset);  offset+=2;\t\t// number of contours\n\tgl.xMin = bin.readShort(data, offset);  offset+=2;\n\tgl.yMin = bin.readShort(data, offset);  offset+=2;\n\tgl.xMax = bin.readShort(data, offset);  offset+=2;\n\tgl.yMax = bin.readShort(data, offset);  offset+=2;\n\t\n\tif(gl.xMin>=gl.xMax || gl.yMin>=gl.yMax) { return null; }\n\t\t\n\tif(gl.noc>0)\n\t{\n\t\tgl.endPts = [];\n\t\tfor(var i=0; i<gl.noc; i++) { gl.endPts.push(bin.readUshort(data,offset)); offset+=2; }\n\t\t\n\t\tvar instructionLength = bin.readUshort(data,offset); offset+=2;\n\t\tif((data.length-offset)<instructionLength) { return null; }\n\t\tgl.instructions = bin.readBytes(data, offset, instructionLength);   offset+=instructionLength;\n\t\t\n\t\tvar crdnum = gl.endPts[gl.noc-1]+1;\n\t\tgl.flags = [];\n\t\tfor(var i=0; i<crdnum; i++ ) \n\t\t{ \n\t\t\tvar flag = data[offset];  offset++; \n\t\t\tgl.flags.push(flag); \n\t\t\tif((flag&8)!=0)\n\t\t\t{\n\t\t\t\tvar rep = data[offset];  offset++;\n\t\t\t\tfor(var j=0; j<rep; j++) { gl.flags.push(flag); i++; }\n\t\t\t}\n\t\t}\n\t\tgl.xs = [];\n\t\tfor(var i=0; i<crdnum; i++) {\n\t\t\tvar i8=((gl.flags[i]&2)!=0), same=((gl.flags[i]&16)!=0);  \n\t\t\tif(i8) { gl.xs.push(same ? data[offset] : -data[offset]);  offset++; }\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(same) { gl.xs.push(0); }\n\t\t\t\telse { gl.xs.push(bin.readShort(data, offset));  offset+=2; }\n\t\t\t}\n\t\t}\n\t\tgl.ys = [];\n\t\tfor(var i=0; i<crdnum; i++) {\n\t\t\tvar i8=((gl.flags[i]&4)!=0), same=((gl.flags[i]&32)!=0);  \n\t\t\tif(i8) { gl.ys.push(same ? data[offset] : -data[offset]);  offset++; }\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(same) { gl.ys.push(0); }\n\t\t\t\telse { gl.ys.push(bin.readShort(data, offset));  offset+=2; }\n\t\t\t}\n\t\t}\n\t\tvar x = 0, y = 0;\n\t\tfor(var i=0; i<crdnum; i++) { x += gl.xs[i]; y += gl.ys[i];  gl.xs[i]=x;  gl.ys[i]=y; }\n\t\t//console.log(endPtsOfContours, instructionLength, instructions, flags, xCoordinates, yCoordinates);\n\t}\n\telse\n\t{\n\t\tvar ARG_1_AND_2_ARE_WORDS\t= 1<<0;\n\t\tvar ARGS_ARE_XY_VALUES\t\t= 1<<1;\n\t\tvar WE_HAVE_A_SCALE\t\t\t= 1<<3;\n\t\tvar MORE_COMPONENTS\t\t\t= 1<<5;\n\t\tvar WE_HAVE_AN_X_AND_Y_SCALE= 1<<6;\n\t\tvar WE_HAVE_A_TWO_BY_TWO\t= 1<<7;\n\t\tvar WE_HAVE_INSTRUCTIONS\t= 1<<8;\n\t\t\n\t\tgl.parts = [];\n\t\tvar flags;\n\t\tdo {\n\t\t\tflags = bin.readUshort(data, offset);  offset += 2;\n\t\t\tvar part = { m:{a:1,b:0,c:0,d:1,tx:0,ty:0}, p1:-1, p2:-1 };  gl.parts.push(part);\n\t\t\tpart.glyphIndex = bin.readUshort(data, offset);  offset += 2;\n\t\t\tif ( flags & ARG_1_AND_2_ARE_WORDS) {\n\t\t\t\tvar arg1 = bin.readShort(data, offset);  offset += 2;\n\t\t\t\tvar arg2 = bin.readShort(data, offset);  offset += 2;\n\t\t\t} else {\n\t\t\t\tvar arg1 = bin.readInt8(data, offset);  offset ++;\n\t\t\t\tvar arg2 = bin.readInt8(data, offset);  offset ++;\n\t\t\t}\n\t\t\t\n\t\t\tif(flags & ARGS_ARE_XY_VALUES) { part.m.tx = arg1;  part.m.ty = arg2; }\n\t\t\telse  {  part.p1=arg1;  part.p2=arg2;  }\n\t\t\t//part.m.tx = arg1;  part.m.ty = arg2;\n\t\t\t//else { throw \"params are not XY values\"; }\n\t\t\t\n\t\t\tif ( flags & WE_HAVE_A_SCALE ) {\n\t\t\t\tpart.m.a = part.m.d = bin.readF2dot14(data, offset);  offset += 2;    \n\t\t\t} else if ( flags & WE_HAVE_AN_X_AND_Y_SCALE ) {\n\t\t\t\tpart.m.a = bin.readF2dot14(data, offset);  offset += 2; \n\t\t\t\tpart.m.d = bin.readF2dot14(data, offset);  offset += 2; \n\t\t\t} else if ( flags & WE_HAVE_A_TWO_BY_TWO ) {\n\t\t\t\tpart.m.a = bin.readF2dot14(data, offset);  offset += 2; \n\t\t\t\tpart.m.b = bin.readF2dot14(data, offset);  offset += 2; \n\t\t\t\tpart.m.c = bin.readF2dot14(data, offset);  offset += 2; \n\t\t\t\tpart.m.d = bin.readF2dot14(data, offset);  offset += 2; \n\t\t\t}\n\t\t} while ( flags & MORE_COMPONENTS ) \n\t\tif (flags & WE_HAVE_INSTRUCTIONS){\n\t\t\tvar numInstr = bin.readUshort(data, offset);  offset += 2;\n\t\t\tgl.instr = [];\n\t\t\tfor(var i=0; i<numInstr; i++) { gl.instr.push(data[offset]);  offset++; }\n\t\t}\n\t}\n\treturn gl;\n};\n\n\nTypr.GPOS = {};\nTypr.GPOS.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GPOS.subt);  };\n\n\nTypr.GPOS.subt = function(data, ltype, offset)\t// lookup type\n{\n\tvar bin = Typr._bin, offset0 = offset, tab = {};\n\t\n\ttab.fmt  = bin.readUshort(data, offset);  offset+=2;\n\t\n\t//console.log(ltype, tab.fmt);\n\t\n\tif(ltype==1 || ltype==2 || ltype==3 || ltype==7 || (ltype==8 && tab.fmt<=2)) {\n\t\tvar covOff  = bin.readUshort(data, offset);  offset+=2;\n\t\ttab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);\n\t}\n\tif(ltype==1 && tab.fmt==1) {\n\t\tvar valFmt1 = bin.readUshort(data, offset);  offset+=2;\n\t\tvar ones1 = Typr._lctf.numOfOnes(valFmt1);\n\t\tif(valFmt1!=0)  { tab.pos = Typr.GPOS.readValueRecord(data, offset, valFmt1); }\n\t}\n\telse if(ltype==2) {\n\t\tvar valFmt1 = bin.readUshort(data, offset);  offset+=2;\n\t\tvar valFmt2 = bin.readUshort(data, offset);  offset+=2;\n\t\tvar ones1 = Typr._lctf.numOfOnes(valFmt1);\n\t\tvar ones2 = Typr._lctf.numOfOnes(valFmt2);\n\t\tif(tab.fmt==1)\n\t\t{\n\t\t\ttab.pairsets = [];\n\t\t\tvar psc = bin.readUshort(data, offset);  offset+=2;  // PairSetCount\n\t\t\t\n\t\t\tfor(var i=0; i<psc; i++)\n\t\t\t{\n\t\t\t\tvar psoff = offset0 + bin.readUshort(data, offset);  offset+=2;\n\t\t\t\t\n\t\t\t\tvar pvc = bin.readUshort(data, psoff);  psoff+=2;\n\t\t\t\tvar arr = [];\n\t\t\t\tfor(var j=0; j<pvc; j++)\n\t\t\t\t{\n\t\t\t\t\tvar gid2 = bin.readUshort(data, psoff);  psoff+=2;\n\t\t\t\t\tvar value1, value2;\n\t\t\t\t\tif(valFmt1!=0) {  value1 = Typr.GPOS.readValueRecord(data, psoff, valFmt1);  psoff+=ones1*2;  }\n\t\t\t\t\tif(valFmt2!=0) {  value2 = Typr.GPOS.readValueRecord(data, psoff, valFmt2);  psoff+=ones2*2;  }\n\t\t\t\t\t//if(value1!=null) throw \"e\";\n\t\t\t\t\tarr.push({gid2:gid2, val1:value1, val2:value2});\n\t\t\t\t}\n\t\t\t\ttab.pairsets.push(arr);\n\t\t\t}\n\t\t}\n\t\tif(tab.fmt==2)\n\t\t{\n\t\t\tvar classDef1 = bin.readUshort(data, offset);  offset+=2;\n\t\t\tvar classDef2 = bin.readUshort(data, offset);  offset+=2;\n\t\t\tvar class1Count = bin.readUshort(data, offset);  offset+=2;\n\t\t\tvar class2Count = bin.readUshort(data, offset);  offset+=2;\n\t\t\t\n\t\t\ttab.classDef1 = Typr._lctf.readClassDef(data, offset0 + classDef1);\n\t\t\ttab.classDef2 = Typr._lctf.readClassDef(data, offset0 + classDef2);\n\t\t\t\n\t\t\ttab.matrix = [];\n\t\t\tfor(var i=0; i<class1Count; i++)\n\t\t\t{\n\t\t\t\tvar row = [];\n\t\t\t\tfor(var j=0; j<class2Count; j++)\n\t\t\t\t{\n\t\t\t\t\tvar value1 = null, value2 = null;\n\t\t\t\t\tif(tab.valFmt1!=0) { value1 = Typr.GPOS.readValueRecord(data, offset, tab.valFmt1);  offset+=ones1*2; }\n\t\t\t\t\tif(tab.valFmt2!=0) { value2 = Typr.GPOS.readValueRecord(data, offset, tab.valFmt2);  offset+=ones2*2; }\n\t\t\t\t\trow.push({val1:value1, val2:value2});\n\t\t\t\t}\n\t\t\t\ttab.matrix.push(row);\n\t\t\t}\n\t\t}\n\t}\n\treturn tab;\n};\n\n\nTypr.GPOS.readValueRecord = function(data, offset, valFmt)\n{\n\tvar bin = Typr._bin;\n\tvar arr = [];\n\tarr.push( (valFmt&1) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&1) ? 2 : 0;  // X_PLACEMENT\n\tarr.push( (valFmt&2) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&2) ? 2 : 0;  // Y_PLACEMENT\n\tarr.push( (valFmt&4) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&4) ? 2 : 0;  // X_ADVANCE\n\tarr.push( (valFmt&8) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&8) ? 2 : 0;  // Y_ADVANCE\n\treturn arr;\n};\n\nTypr.GSUB = {};\nTypr.GSUB.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GSUB.subt);  };\n\n\nTypr.GSUB.subt = function(data, ltype, offset)\t// lookup type\n{\n\tvar bin = Typr._bin, offset0 = offset, tab = {};\n\t\n\ttab.fmt  = bin.readUshort(data, offset);  offset+=2;\n\t\n\tif(ltype!=1 && ltype!=4 && ltype!=5 && ltype!=6) { return null; }\n\t\n\tif(ltype==1 || ltype==4 || (ltype==5 && tab.fmt<=2) || (ltype==6 && tab.fmt<=2)) {\n\t\tvar covOff  = bin.readUshort(data, offset);  offset+=2;\n\t\ttab.coverage = Typr._lctf.readCoverage(data, offset0+covOff);\t// not always is coverage here\n\t}\n\t\n\tif(ltype==1) {\t\n\t\tif(tab.fmt==1) {\n\t\t\ttab.delta = bin.readShort(data, offset);  offset+=2;\n\t\t}\n\t\telse if(tab.fmt==2) {\n\t\t\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n\t\t\ttab.newg = bin.readUshorts(data, offset, cnt);  offset+=tab.newg.length*2;\n\t\t}\n\t}\n\t//  Ligature Substitution Subtable\n\telse if(ltype==4) {\n\t\ttab.vals = [];\n\t\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n\t\tfor(var i=0; i<cnt; i++) {\n\t\t\tvar loff = bin.readUshort(data, offset);  offset+=2;\n\t\t\ttab.vals.push(Typr.GSUB.readLigatureSet(data, offset0+loff));\n\t\t}\n\t\t//console.log(tab.coverage);\n\t\t//console.log(tab.vals);\n\t} \n\t//  Contextual Substitution Subtable\n\telse if(ltype==5) {\n\t\tif(tab.fmt==2) {\n\t\t\tvar cDefOffset = bin.readUshort(data, offset);  offset+=2;\n\t\t\ttab.cDef = Typr._lctf.readClassDef(data, offset0 + cDefOffset);\n\t\t\ttab.scset = [];\n\t\t\tvar subClassSetCount = bin.readUshort(data, offset);  offset+=2;\n\t\t\tfor(var i=0; i<subClassSetCount; i++)\n\t\t\t{\n\t\t\t\tvar scsOff = bin.readUshort(data, offset);  offset+=2;\n\t\t\t\ttab.scset.push(  scsOff==0 ? null : Typr.GSUB.readSubClassSet(data, offset0 + scsOff)  );\n\t\t\t}\n\t\t}\n\t\t//else console.log(\"unknown table format\", tab.fmt);\n\t}\n\t//*\n\telse if(ltype==6) {\n\t\t/*\n\t\tif(tab.fmt==2) {\n\t\t\tvar btDef = bin.readUshort(data, offset);  offset+=2;\n\t\t\tvar inDef = bin.readUshort(data, offset);  offset+=2;\n\t\t\tvar laDef = bin.readUshort(data, offset);  offset+=2;\n\t\t\t\n\t\t\ttab.btDef = Typr._lctf.readClassDef(data, offset0 + btDef);\n\t\t\ttab.inDef = Typr._lctf.readClassDef(data, offset0 + inDef);\n\t\t\ttab.laDef = Typr._lctf.readClassDef(data, offset0 + laDef);\n\t\t\t\n\t\t\ttab.scset = [];\n\t\t\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n\t\t\tfor(var i=0; i<cnt; i++) {\n\t\t\t\tvar loff = bin.readUshort(data, offset);  offset+=2;\n\t\t\t\ttab.scset.push(Typr.GSUB.readChainSubClassSet(data, offset0+loff));\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tif(tab.fmt==3) {\n\t\t\tfor(var i=0; i<3; i++) {\n\t\t\t\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n\t\t\t\tvar cvgs = [];\n\t\t\t\tfor(var j=0; j<cnt; j++) { cvgs.push(  Typr._lctf.readCoverage(data, offset0 + bin.readUshort(data, offset+j*2))   ); }\n\t\t\t\toffset+=cnt*2;\n\t\t\t\tif(i==0) { tab.backCvg = cvgs; }\n\t\t\t\tif(i==1) { tab.inptCvg = cvgs; }\n\t\t\t\tif(i==2) { tab.ahedCvg = cvgs; }\n\t\t\t}\n\t\t\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n\t\t\ttab.lookupRec = Typr.GSUB.readSubstLookupRecords(data, offset, cnt);\n\t\t}\n\t\t//console.log(tab);\n\t} //*/\n\t//if(tab.coverage.indexOf(3)!=-1) console.log(ltype, fmt, tab);\n\t\n\treturn tab;\n};\n\nTypr.GSUB.readSubClassSet = function(data, offset)\n{\n\tvar rUs = Typr._bin.readUshort, offset0 = offset, lset = [];\n\tvar cnt = rUs(data, offset);  offset+=2;\n\tfor(var i=0; i<cnt; i++) {\n\t\tvar loff = rUs(data, offset);  offset+=2;\n\t\tlset.push(Typr.GSUB.readSubClassRule(data, offset0+loff));\n\t}\n\treturn lset;\n};\nTypr.GSUB.readSubClassRule= function(data, offset)\n{\n\tvar rUs = Typr._bin.readUshort, rule = {};\n\tvar gcount = rUs(data, offset);  offset+=2;\n\tvar scount = rUs(data, offset);  offset+=2;\n\trule.input = [];\n\tfor(var i=0; i<gcount-1; i++) {\n\t\trule.input.push(rUs(data, offset));  offset+=2;\n\t}\n\trule.substLookupRecords = Typr.GSUB.readSubstLookupRecords(data, offset, scount);\n\treturn rule;\n};\nTypr.GSUB.readSubstLookupRecords = function(data, offset, cnt)\n{\n\tvar rUs = Typr._bin.readUshort;\n\tvar out = [];\n\tfor(var i=0; i<cnt; i++) {  out.push(rUs(data, offset), rUs(data, offset+2));  offset+=4;  }\n\treturn out;\n};\n\nTypr.GSUB.readChainSubClassSet = function(data, offset)\n{\n\tvar bin = Typr._bin, offset0 = offset, lset = [];\n\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n\tfor(var i=0; i<cnt; i++) {\n\t\tvar loff = bin.readUshort(data, offset);  offset+=2;\n\t\tlset.push(Typr.GSUB.readChainSubClassRule(data, offset0+loff));\n\t}\n\treturn lset;\n};\nTypr.GSUB.readChainSubClassRule= function(data, offset)\n{\n\tvar bin = Typr._bin, rule = {};\n\tvar pps = [\"backtrack\", \"input\", \"lookahead\"];\n\tfor(var pi=0; pi<pps.length; pi++) {\n\t\tvar cnt = bin.readUshort(data, offset);  offset+=2;  if(pi==1) { cnt--; }\n\t\trule[pps[pi]]=bin.readUshorts(data, offset, cnt);  offset+= rule[pps[pi]].length*2;\n\t}\n\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n\trule.subst = bin.readUshorts(data, offset, cnt*2);  offset += rule.subst.length*2;\n\treturn rule;\n};\n\nTypr.GSUB.readLigatureSet = function(data, offset)\n{\n\tvar bin = Typr._bin, offset0 = offset, lset = [];\n\tvar lcnt = bin.readUshort(data, offset);  offset+=2;\n\tfor(var j=0; j<lcnt; j++) {\n\t\tvar loff = bin.readUshort(data, offset);  offset+=2;\n\t\tlset.push(Typr.GSUB.readLigature(data, offset0+loff));\n\t}\n\treturn lset;\n};\nTypr.GSUB.readLigature = function(data, offset)\n{\n\tvar bin = Typr._bin, lig = {chain:[]};\n\tlig.nglyph = bin.readUshort(data, offset);  offset+=2;\n\tvar ccnt = bin.readUshort(data, offset);  offset+=2;\n\tfor(var k=0; k<ccnt-1; k++) {  lig.chain.push(bin.readUshort(data, offset));  offset+=2;  }\n\treturn lig;\n};\n\n\n\nTypr.head = {};\nTypr.head.parse = function(data, offset, length)\n{\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\tvar tableVersion = bin.readFixed(data, offset);  offset += 4;\n\tobj.fontRevision = bin.readFixed(data, offset);  offset += 4;\n\tvar checkSumAdjustment = bin.readUint(data, offset);  offset += 4;\n\tvar magicNumber = bin.readUint(data, offset);  offset += 4;\n\tobj.flags = bin.readUshort(data, offset);  offset += 2;\n\tobj.unitsPerEm = bin.readUshort(data, offset);  offset += 2;\n\tobj.created  = bin.readUint64(data, offset);  offset += 8;\n\tobj.modified = bin.readUint64(data, offset);  offset += 8;\n\tobj.xMin = bin.readShort(data, offset);  offset += 2;\n\tobj.yMin = bin.readShort(data, offset);  offset += 2;\n\tobj.xMax = bin.readShort(data, offset);  offset += 2;\n\tobj.yMax = bin.readShort(data, offset);  offset += 2;\n\tobj.macStyle = bin.readUshort(data, offset);  offset += 2;\n\tobj.lowestRecPPEM = bin.readUshort(data, offset);  offset += 2;\n\tobj.fontDirectionHint = bin.readShort(data, offset);  offset += 2;\n\tobj.indexToLocFormat  = bin.readShort(data, offset);  offset += 2;\n\tobj.glyphDataFormat   = bin.readShort(data, offset);  offset += 2;\n\treturn obj;\n};\n\n\nTypr.hhea = {};\nTypr.hhea.parse = function(data, offset, length)\n{\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\tvar tableVersion = bin.readFixed(data, offset);  offset += 4;\n\tobj.ascender  = bin.readShort(data, offset);  offset += 2;\n\tobj.descender = bin.readShort(data, offset);  offset += 2;\n\tobj.lineGap = bin.readShort(data, offset);  offset += 2;\n\t\n\tobj.advanceWidthMax = bin.readUshort(data, offset);  offset += 2;\n\tobj.minLeftSideBearing  = bin.readShort(data, offset);  offset += 2;\n\tobj.minRightSideBearing = bin.readShort(data, offset);  offset += 2;\n\tobj.xMaxExtent = bin.readShort(data, offset);  offset += 2;\n\t\n\tobj.caretSlopeRise = bin.readShort(data, offset);  offset += 2;\n\tobj.caretSlopeRun  = bin.readShort(data, offset);  offset += 2;\n\tobj.caretOffset    = bin.readShort(data, offset);  offset += 2;\n\t\n\toffset += 4*2;\n\t\n\tobj.metricDataFormat = bin.readShort (data, offset);  offset += 2;\n\tobj.numberOfHMetrics = bin.readUshort(data, offset);  offset += 2;\n\treturn obj;\n};\n\n\nTypr.hmtx = {};\nTypr.hmtx.parse = function(data, offset, length, font)\n{\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\t\n\tobj.aWidth = [];\n\tobj.lsBearing = [];\n\t\n\t\n\tvar aw = 0, lsb = 0;\n\t\n\tfor(var i=0; i<font.maxp.numGlyphs; i++)\n\t{\n\t\tif(i<font.hhea.numberOfHMetrics) {  aw=bin.readUshort(data, offset);  offset += 2;  lsb=bin.readShort(data, offset);  offset+=2;  }\n\t\tobj.aWidth.push(aw);\n\t\tobj.lsBearing.push(lsb);\n\t}\n\t\n\treturn obj;\n};\n\n\nTypr.kern = {};\nTypr.kern.parse = function(data, offset, length, font)\n{\n\tvar bin = Typr._bin;\n\t\n\tvar version = bin.readUshort(data, offset);  offset+=2;\n\tif(version==1) { return Typr.kern.parseV1(data, offset-2, length, font); }\n\tvar nTables = bin.readUshort(data, offset);  offset+=2;\n\t\n\tvar map = {glyph1: [], rval:[]};\n\tfor(var i=0; i<nTables; i++)\n\t{\n\t\toffset+=2;\t// skip version\n\t\tvar length  = bin.readUshort(data, offset);  offset+=2;\n\t\tvar coverage = bin.readUshort(data, offset);  offset+=2;\n\t\tvar format = coverage>>>8;\n\t\t/* I have seen format 128 once, that's why I do */ format &= 0xf;\n\t\tif(format==0) { offset = Typr.kern.readFormat0(data, offset, map); }\n\t\telse { throw \"unknown kern table format: \"+format; }\n\t}\n\treturn map;\n};\n\nTypr.kern.parseV1 = function(data, offset, length, font)\n{\n\tvar bin = Typr._bin;\n\t\n\tvar version = bin.readFixed(data, offset);  offset+=4;\n\tvar nTables = bin.readUint(data, offset);  offset+=4;\n\t\n\tvar map = {glyph1: [], rval:[]};\n\tfor(var i=0; i<nTables; i++)\n\t{\n\t\tvar length = bin.readUint(data, offset);   offset+=4;\n\t\tvar coverage = bin.readUshort(data, offset);  offset+=2;\n\t\tvar tupleIndex = bin.readUshort(data, offset);  offset+=2;\n\t\tvar format = coverage>>>8;\n\t\t/* I have seen format 128 once, that's why I do */ format &= 0xf;\n\t\tif(format==0) { offset = Typr.kern.readFormat0(data, offset, map); }\n\t\telse { throw \"unknown kern table format: \"+format; }\n\t}\n\treturn map;\n};\n\nTypr.kern.readFormat0 = function(data, offset, map)\n{\n\tvar bin = Typr._bin;\n\tvar pleft = -1;\n\tvar nPairs        = bin.readUshort(data, offset);  offset+=2;\n\tvar searchRange   = bin.readUshort(data, offset);  offset+=2;\n\tvar entrySelector = bin.readUshort(data, offset);  offset+=2;\n\tvar rangeShift    = bin.readUshort(data, offset);  offset+=2;\n\tfor(var j=0; j<nPairs; j++)\n\t{\n\t\tvar left  = bin.readUshort(data, offset);  offset+=2;\n\t\tvar right = bin.readUshort(data, offset);  offset+=2;\n\t\tvar value = bin.readShort (data, offset);  offset+=2;\n\t\tif(left!=pleft) { map.glyph1.push(left);  map.rval.push({ glyph2:[], vals:[] }); }\n\t\tvar rval = map.rval[map.rval.length-1];\n\t\trval.glyph2.push(right);   rval.vals.push(value);\n\t\tpleft = left;\n\t}\n\treturn offset;\n};\n\n\n\nTypr.loca = {};\nTypr.loca.parse = function(data, offset, length, font)\n{\n\tvar bin = Typr._bin;\n\tvar obj = [];\n\t\n\tvar ver = font.head.indexToLocFormat;\n\t//console.log(\"loca\", ver, length, 4*font.maxp.numGlyphs);\n\tvar len = font.maxp.numGlyphs+1;\n\t\n\tif(ver==0) { for(var i=0; i<len; i++) { obj.push(bin.readUshort(data, offset+(i<<1))<<1); } }\n\tif(ver==1) { for(var i=0; i<len; i++) { obj.push(bin.readUint  (data, offset+(i<<2))   ); } }\n\t\n\treturn obj;\n};\n\n\nTypr.maxp = {};\nTypr.maxp.parse = function(data, offset, length)\n{\n\t//console.log(data.length, offset, length);\n\t\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\t\n\t// both versions 0.5 and 1.0\n\tvar ver = bin.readUint(data, offset); offset += 4;\n\tobj.numGlyphs = bin.readUshort(data, offset);  offset += 2;\n\t\n\t// only 1.0\n\tif(ver == 0x00010000)\n\t{\n\t\tobj.maxPoints             = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxContours           = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxCompositePoints    = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxCompositeContours  = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxZones              = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxTwilightPoints     = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxStorage            = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxFunctionDefs       = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxInstructionDefs    = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxStackElements      = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxSizeOfInstructions = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxComponentElements  = bin.readUshort(data, offset);  offset += 2;\n\t\tobj.maxComponentDepth     = bin.readUshort(data, offset);  offset += 2;\n\t}\n\t\n\treturn obj;\n};\n\n\nTypr.name = {};\nTypr.name.parse = function(data, offset, length)\n{\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\tvar format = bin.readUshort(data, offset);  offset += 2;\n\tvar count  = bin.readUshort(data, offset);  offset += 2;\n\tvar stringOffset = bin.readUshort(data, offset);  offset += 2;\n\t\n\t//console.log(format,count);\n\t\n\tvar names = [\n\t\t\"copyright\",\n\t\t\"fontFamily\",\n\t\t\"fontSubfamily\",\n\t\t\"ID\",\n\t\t\"fullName\",\n\t\t\"version\",\n\t\t\"postScriptName\",\n\t\t\"trademark\",\n\t\t\"manufacturer\",\n\t\t\"designer\",\n\t\t\"description\",\n\t\t\"urlVendor\",\n\t\t\"urlDesigner\",\n\t\t\"licence\",\n\t\t\"licenceURL\",\n\t\t\"---\",\n\t\t\"typoFamilyName\",\n\t\t\"typoSubfamilyName\",\n\t\t\"compatibleFull\",\n\t\t\"sampleText\",\n\t\t\"postScriptCID\",\n\t\t\"wwsFamilyName\",\n\t\t\"wwsSubfamilyName\",\n\t\t\"lightPalette\",\n\t\t\"darkPalette\"\n\t];\n\t\n\tvar offset0 = offset;\n\t\n\tfor(var i=0; i<count; i++)\n\t{\n\t\tvar platformID = bin.readUshort(data, offset);  offset += 2;\n\t\tvar encodingID = bin.readUshort(data, offset);  offset += 2;\n\t\tvar languageID = bin.readUshort(data, offset);  offset += 2;\n\t\tvar nameID     = bin.readUshort(data, offset);  offset += 2;\n\t\tvar slen       = bin.readUshort(data, offset);  offset += 2;\n\t\tvar noffset    = bin.readUshort(data, offset);  offset += 2;\n\t\t//console.log(platformID, encodingID, languageID.toString(16), nameID, length, noffset);\n\t\t\n\t\tvar cname = names[nameID];\n\t\tvar soff = offset0 + count*12 + noffset;\n\t\tvar str;\n\t\tif(platformID == 0) { str = bin.readUnicode(data, soff, slen/2); }\n\t\telse if(platformID == 3 && encodingID == 0) { str = bin.readUnicode(data, soff, slen/2); }\n\t\telse if(encodingID == 0) { str = bin.readASCII  (data, soff, slen); }\n\t\telse if(encodingID == 1) { str = bin.readUnicode(data, soff, slen/2); }\n\t\telse if(encodingID == 3) { str = bin.readUnicode(data, soff, slen/2); }\n\t\t\n\t\telse if(platformID == 1) { str = bin.readASCII(data, soff, slen);  console.log(\"reading unknown MAC encoding \"+encodingID+\" as ASCII\"); }\n\t\telse { throw \"unknown encoding \"+encodingID + \", platformID: \"+platformID; }\n\t\t\n\t\tvar tid = \"p\"+platformID+\",\"+(languageID).toString(16);//Typr._platforms[platformID];\n\t\tif(obj[tid]==null) { obj[tid] = {}; }\n\t\tobj[tid][cname] = str;\n\t\tobj[tid]._lang = languageID;\n\t\t//console.log(tid, obj[tid]);\n\t}\n\t/*\n\tif(format == 1)\n\t{\n\t\tvar langTagCount = bin.readUshort(data, offset);  offset += 2;\n\t\tfor(var i=0; i<langTagCount; i++)\n\t\t{\n\t\t\tvar length  = bin.readUshort(data, offset);  offset += 2;\n\t\t\tvar noffset = bin.readUshort(data, offset);  offset += 2;\n\t\t}\n\t}\n\t*/\n\t\n\t//console.log(obj);\n\t\n\tfor(var p in obj) { if(obj[p].postScriptName!=null && obj[p]._lang==0x0409) { return obj[p]; } }\t\t// United States\n\tfor(var p in obj) { if(obj[p].postScriptName!=null && obj[p]._lang==0x0000) { return obj[p]; } }\t\t// Universal\n\tfor(var p in obj) { if(obj[p].postScriptName!=null && obj[p]._lang==0x0c0c) { return obj[p]; } }\t\t// Canada\n\tfor(var p in obj) { if(obj[p].postScriptName!=null) { return obj[p]; } }\n\t\n\tvar tname;\n\tfor(var p in obj) { tname=p; break; }\n\tconsole.log(\"returning name table with languageID \"+ obj[tname]._lang);\n\treturn obj[tname];\n};\n\n\nTypr[\"OS/2\"] = {};\nTypr[\"OS/2\"].parse = function(data, offset, length)\n{\n\tvar bin = Typr._bin;\n\tvar ver = bin.readUshort(data, offset); offset += 2;\n\t\n\tvar obj = {};\n\tif     (ver==0) { Typr[\"OS/2\"].version0(data, offset, obj); }\n\telse if(ver==1) { Typr[\"OS/2\"].version1(data, offset, obj); }\n\telse if(ver==2 || ver==3 || ver==4) { Typr[\"OS/2\"].version2(data, offset, obj); }\n\telse if(ver==5) { Typr[\"OS/2\"].version5(data, offset, obj); }\n\telse { throw \"unknown OS/2 table version: \"+ver; }\n\t\n\treturn obj;\n};\n\nTypr[\"OS/2\"].version0 = function(data, offset, obj)\n{\n\tvar bin = Typr._bin;\n\tobj.xAvgCharWidth = bin.readShort(data, offset); offset += 2;\n\tobj.usWeightClass = bin.readUshort(data, offset); offset += 2;\n\tobj.usWidthClass  = bin.readUshort(data, offset); offset += 2;\n\tobj.fsType = bin.readUshort(data, offset); offset += 2;\n\tobj.ySubscriptXSize = bin.readShort(data, offset); offset += 2;\n\tobj.ySubscriptYSize = bin.readShort(data, offset); offset += 2;\n\tobj.ySubscriptXOffset = bin.readShort(data, offset); offset += 2;\n\tobj.ySubscriptYOffset = bin.readShort(data, offset); offset += 2; \n\tobj.ySuperscriptXSize = bin.readShort(data, offset); offset += 2; \n\tobj.ySuperscriptYSize = bin.readShort(data, offset); offset += 2; \n\tobj.ySuperscriptXOffset = bin.readShort(data, offset); offset += 2;\n\tobj.ySuperscriptYOffset = bin.readShort(data, offset); offset += 2;\n\tobj.yStrikeoutSize = bin.readShort(data, offset); offset += 2;\n\tobj.yStrikeoutPosition = bin.readShort(data, offset); offset += 2;\n\tobj.sFamilyClass = bin.readShort(data, offset); offset += 2;\n\tobj.panose = bin.readBytes(data, offset, 10);  offset += 10;\n\tobj.ulUnicodeRange1\t= bin.readUint(data, offset);  offset += 4;\n\tobj.ulUnicodeRange2\t= bin.readUint(data, offset);  offset += 4;\n\tobj.ulUnicodeRange3\t= bin.readUint(data, offset);  offset += 4;\n\tobj.ulUnicodeRange4\t= bin.readUint(data, offset);  offset += 4;\n\tobj.achVendID = [bin.readInt8(data, offset), bin.readInt8(data, offset+1),bin.readInt8(data, offset+2),bin.readInt8(data, offset+3)];  offset += 4;\n\tobj.fsSelection\t = bin.readUshort(data, offset); offset += 2;\n\tobj.usFirstCharIndex = bin.readUshort(data, offset); offset += 2;\n\tobj.usLastCharIndex = bin.readUshort(data, offset); offset += 2;\n\tobj.sTypoAscender = bin.readShort(data, offset); offset += 2;\n\tobj.sTypoDescender = bin.readShort(data, offset); offset += 2;\n\tobj.sTypoLineGap = bin.readShort(data, offset); offset += 2;\n\tobj.usWinAscent = bin.readUshort(data, offset); offset += 2;\n\tobj.usWinDescent = bin.readUshort(data, offset); offset += 2;\n\treturn offset;\n};\n\nTypr[\"OS/2\"].version1 = function(data, offset, obj)\n{\n\tvar bin = Typr._bin;\n\toffset = Typr[\"OS/2\"].version0(data, offset, obj);\n\t\n\tobj.ulCodePageRange1 = bin.readUint(data, offset); offset += 4;\n\tobj.ulCodePageRange2 = bin.readUint(data, offset); offset += 4;\n\treturn offset;\n};\n\nTypr[\"OS/2\"].version2 = function(data, offset, obj)\n{\n\tvar bin = Typr._bin;\n\toffset = Typr[\"OS/2\"].version1(data, offset, obj);\n\t\n\tobj.sxHeight = bin.readShort(data, offset); offset += 2;\n\tobj.sCapHeight = bin.readShort(data, offset); offset += 2;\n\tobj.usDefault = bin.readUshort(data, offset); offset += 2;\n\tobj.usBreak = bin.readUshort(data, offset); offset += 2;\n\tobj.usMaxContext = bin.readUshort(data, offset); offset += 2;\n\treturn offset;\n};\n\nTypr[\"OS/2\"].version5 = function(data, offset, obj)\n{\n\tvar bin = Typr._bin;\n\toffset = Typr[\"OS/2\"].version2(data, offset, obj);\n\n\tobj.usLowerOpticalPointSize = bin.readUshort(data, offset); offset += 2;\n\tobj.usUpperOpticalPointSize = bin.readUshort(data, offset); offset += 2;\n\treturn offset;\n};\n\nTypr.post = {};\nTypr.post.parse = function(data, offset, length)\n{\n\tvar bin = Typr._bin;\n\tvar obj = {};\n\t\n\tobj.version           = bin.readFixed(data, offset);  offset+=4;\n\tobj.italicAngle       = bin.readFixed(data, offset);  offset+=4;\n\tobj.underlinePosition = bin.readShort(data, offset);  offset+=2;\n\tobj.underlineThickness = bin.readShort(data, offset);  offset+=2;\n\n\treturn obj;\n};\nTypr.SVG = {};\nTypr.SVG.parse = function(data, offset, length)\n{\n\tvar bin = Typr._bin;\n\tvar obj = { entries: []};\n\n\tvar offset0 = offset;\n\n\tvar tableVersion = bin.readUshort(data, offset);\toffset += 2;\n\tvar svgDocIndexOffset = bin.readUint(data, offset);\toffset += 4;\n\tvar reserved = bin.readUint(data, offset); offset += 4;\n\n\toffset = svgDocIndexOffset + offset0;\n\n\tvar numEntries = bin.readUshort(data, offset);\toffset += 2;\n\n\tfor(var i=0; i<numEntries; i++)\n\t{\n\t\tvar startGlyphID = bin.readUshort(data, offset);  offset += 2;\n\t\tvar endGlyphID   = bin.readUshort(data, offset);  offset += 2;\n\t\tvar svgDocOffset = bin.readUint  (data, offset);  offset += 4;\n\t\tvar svgDocLength = bin.readUint  (data, offset);  offset += 4;\n\n\t\tvar sbuf = new Uint8Array(data.buffer, offset0 + svgDocOffset + svgDocIndexOffset, svgDocLength);\n\t\tvar svg = bin.readUTF8(sbuf, 0, sbuf.length);\n\t\t\n\t\tfor(var f=startGlyphID; f<=endGlyphID; f++) {\n\t\t\tobj.entries[f] = svg;\n\t\t}\n\t}\n\treturn obj;\n};\n\nTypr.SVG.toPath = function(str)\n{\n\tvar pth = {cmds:[], crds:[]};\n\tif(str==null) { return pth; }\n\t\n\tvar prsr = new DOMParser();\n\tvar doc = prsr[\"parseFromString\"](str,\"image/svg+xml\");\n\t\n\tvar svg = doc.firstChild;  while(svg.tagName!=\"svg\") { svg = svg.nextSibling; }\n\tvar vb = svg.getAttribute(\"viewBox\");\n\tif(vb) { vb = vb.trim().split(\" \").map(parseFloat); }  else   { vb = [0,0,1000,1000]; }\n\tTypr.SVG._toPath(svg.children, pth);\n\tfor(var i=0; i<pth.crds.length; i+=2) {\n\t\tvar x = pth.crds[i], y = pth.crds[i+1];\n\t\tx -= vb[0];\n\t\ty -= vb[1];\n\t\ty = -y;\n\t\tpth.crds[i] = x;\n\t\tpth.crds[i+1] = y;\n\t}\n\treturn pth;\n};\n\nTypr.SVG._toPath = function(nds, pth, fill) {\n\tfor(var ni=0; ni<nds.length; ni++) {\n\t\tvar nd = nds[ni], tn = nd.tagName;\n\t\tvar cfl = nd.getAttribute(\"fill\");  if(cfl==null) { cfl = fill; }\n\t\tif(tn==\"g\") { Typr.SVG._toPath(nd.children, pth, cfl); }\n\t\telse if(tn==\"path\") {\n\t\t\tpth.cmds.push(cfl?cfl:\"#000000\");\n\t\t\tvar d = nd.getAttribute(\"d\");  //console.log(d);\n\t\t\tvar toks = Typr.SVG._tokens(d);  //console.log(toks);\n\t\t\tTypr.SVG._toksToPath(toks, pth);  pth.cmds.push(\"X\");\n\t\t}\n\t\telse if(tn==\"defs\") ;\n\t\telse { console.log(tn, nd); }\n\t}\n};\n\nTypr.SVG._tokens = function(d) {\n\tvar ts = [], off = 0, rn=false, cn=\"\";  // reading number, current number\n\twhile(off<d.length){\n\t\tvar cc=d.charCodeAt(off), ch = d.charAt(off);  off++;\n\t\tvar isNum = (48<=cc && cc<=57) || ch==\".\" || ch==\"-\";\n\t\t\n\t\tif(rn) {\n\t\t\tif(ch==\"-\") {  ts.push(parseFloat(cn));  cn=ch;  }\n\t\t\telse if(isNum) { cn+=ch; }\n\t\t\telse {  ts.push(parseFloat(cn));  if(ch!=\",\" && ch!=\" \") { ts.push(ch); }  rn=false;  }\n\t\t}\n\t\telse {\n\t\t\tif(isNum) {  cn=ch;  rn=true;  }\n\t\t\telse if(ch!=\",\" && ch!=\" \") { ts.push(ch); }\n\t\t}\n\t}\n\tif(rn) { ts.push(parseFloat(cn)); }\n\treturn ts;\n};\n\nTypr.SVG._toksToPath = function(ts, pth) {\t\n\tvar i = 0, x = 0, y = 0, ox = 0, oy = 0;\n\tvar pc = {\"M\":2,\"L\":2,\"H\":1,\"V\":1,   \"S\":4,   \"C\":6};\n\tvar cmds = pth.cmds, crds = pth.crds;\n\t\n\twhile(i<ts.length) {\n\t\tvar cmd = ts[i];  i++;\n\t\t\n\t\tif(cmd==\"z\") {  cmds.push(\"Z\");  x=ox;  y=oy;  }\n\t\telse {\n\t\t\tvar cmu = cmd.toUpperCase();\n\t\t\tvar ps = pc[cmu], reps = Typr.SVG._reps(ts, i, ps);\n\t\t\n\t\t\tfor(var j=0; j<reps; j++) {\n\t\t\t\tvar xi = 0, yi = 0;   if(cmd!=cmu) {  xi=x;  yi=y;  }\n\t\t\t\t\n\t\t\t\tif(cmu==\"M\") {  x = xi+ts[i++];  y = yi+ts[i++];  cmds.push(\"M\");  crds.push(x,y);  ox=x;  oy=y; }\n\t\t\t\telse if(cmu==\"L\") {  x = xi+ts[i++];  y = yi+ts[i++];  cmds.push(\"L\");  crds.push(x,y);  }\n\t\t\t\telse if(cmu==\"H\") {  x = xi+ts[i++];                   cmds.push(\"L\");  crds.push(x,y);  }\n\t\t\t\telse if(cmu==\"V\") {  y = yi+ts[i++];                   cmds.push(\"L\");  crds.push(x,y);  }\n\t\t\t\telse if(cmu==\"C\") {\n\t\t\t\t\tvar x1=xi+ts[i++], y1=yi+ts[i++], x2=xi+ts[i++], y2=yi+ts[i++], x3=xi+ts[i++], y3=yi+ts[i++];\n\t\t\t\t\tcmds.push(\"C\");  crds.push(x1,y1,x2,y2,x3,y3);  x=x3;  y=y3;\n\t\t\t\t}\n\t\t\t\telse if(cmu==\"S\") {\n\t\t\t\t\tvar co = Math.max(crds.length-4, 0);\n\t\t\t\t\tvar x1 = x+x-crds[co], y1 = y+y-crds[co+1];\n\t\t\t\t\tvar x2=xi+ts[i++], y2=yi+ts[i++], x3=xi+ts[i++], y3=yi+ts[i++];  \n\t\t\t\t\tcmds.push(\"C\");  crds.push(x1,y1,x2,y2,x3,y3);  x=x3;  y=y3;\n\t\t\t\t}\n\t\t\t\telse { console.log(\"Unknown SVG command \"+cmd); }\n\t\t\t}\n\t\t}\n\t}\n};\nTypr.SVG._reps = function(ts, off, ps) {\n\tvar i = off;\n\twhile(i<ts.length) {  if((typeof ts[i]) == \"string\") { break; }  i+=ps;  }\n\treturn (i-off)/ps;\n};\n// End Typr.js\n\n// Begin Typr.U.js\n\nif(Typr  ==null) { Typr   = {}; }\nif(Typr.U==null) { Typr.U = {}; }\n\n\nTypr.U.codeToGlyph = function(font, code)\n{\n\tvar cmap = font.cmap;\n\t\n\tvar tind = -1;\n\tif(cmap.p0e4!=null) { tind = cmap.p0e4; }\n\telse if(cmap.p3e1!=null) { tind = cmap.p3e1; }\n\telse if(cmap.p1e0!=null) { tind = cmap.p1e0; }\n\telse if(cmap.p0e3!=null) { tind = cmap.p0e3; }\n\t\n\tif(tind==-1) { throw \"no familiar platform and encoding!\"; }\n\t\n\tvar tab = cmap.tables[tind];\n\t\n\tif(tab.format==0)\n\t{\n\t\tif(code>=tab.map.length) { return 0; }\n\t\treturn tab.map[code];\n\t}\n\telse if(tab.format==4)\n\t{\n\t\tvar sind = -1;\n\t\tfor(var i=0; i<tab.endCount.length; i++)   { if(code<=tab.endCount[i]){  sind=i;  break;  } } \n\t\tif(sind==-1) { return 0; }\n\t\tif(tab.startCount[sind]>code) { return 0; }\n\t\t\n\t\tvar gli = 0;\n\t\tif(tab.idRangeOffset[sind]!=0) { gli = tab.glyphIdArray[(code-tab.startCount[sind]) + (tab.idRangeOffset[sind]>>1) - (tab.idRangeOffset.length-sind)]; }\n\t\telse                           { gli = code + tab.idDelta[sind]; }\n\t\treturn gli & 0xFFFF;\n\t}\n\telse if(tab.format==12)\n\t{\n\t\tif(code>tab.groups[tab.groups.length-1][1]) { return 0; }\n\t\tfor(var i=0; i<tab.groups.length; i++)\n\t\t{\n\t\t\tvar grp = tab.groups[i];\n\t\t\tif(grp[0]<=code && code<=grp[1]) { return grp[2] + (code-grp[0]); }\n\t\t}\n\t\treturn 0;\n\t}\n\telse { throw \"unknown cmap table format \"+tab.format; }\n};\n\n\nTypr.U.glyphToPath = function(font, gid)\n{\n\tvar path = { cmds:[], crds:[] };\n\tif(font.SVG && font.SVG.entries[gid]) {\n\t\tvar p = font.SVG.entries[gid];  if(p==null) { return path; }\n\t\tif(typeof p == \"string\") {  p = Typr.SVG.toPath(p);  font.SVG.entries[gid]=p;  }\n\t\treturn p;\n\t}\n\telse if(font.CFF) {\n\t\tvar state = {x:0,y:0,stack:[],nStems:0,haveWidth:false,width: font.CFF.Private ? font.CFF.Private.defaultWidthX : 0,open:false};\n\t\tvar cff=font.CFF, pdct = font.CFF.Private;\n\t\tif(cff.ROS) {\n\t\t\tvar gi = 0;\n\t\t\twhile(cff.FDSelect[gi+2]<=gid) { gi+=2; }\n\t\t\tpdct = cff.FDArray[cff.FDSelect[gi+1]].Private;\n\t\t}\n\t\tTypr.U._drawCFF(font.CFF.CharStrings[gid], state, cff, pdct, path);\n\t}\n\telse if(font.glyf) {  Typr.U._drawGlyf(gid, font, path);  }\n\treturn path;\n};\n\nTypr.U._drawGlyf = function(gid, font, path)\n{\n\tvar gl = font.glyf[gid];\n\tif(gl==null) { gl = font.glyf[gid] = Typr.glyf._parseGlyf(font, gid); }\n\tif(gl!=null){\n\t\tif(gl.noc>-1) { Typr.U._simpleGlyph(gl, path); }\n\t\telse          { Typr.U._compoGlyph (gl, font, path); }\n\t}\n};\nTypr.U._simpleGlyph = function(gl, p)\n{\n\tfor(var c=0; c<gl.noc; c++)\n\t{\n\t\tvar i0 = (c==0) ? 0 : (gl.endPts[c-1] + 1);\n\t\tvar il = gl.endPts[c];\n\t\t\n\t\tfor(var i=i0; i<=il; i++)\n\t\t{\n\t\t\tvar pr = (i==i0)?il:(i-1);\n\t\t\tvar nx = (i==il)?i0:(i+1);\n\t\t\tvar onCurve = gl.flags[i]&1;\n\t\t\tvar prOnCurve = gl.flags[pr]&1;\n\t\t\tvar nxOnCurve = gl.flags[nx]&1;\n\t\t\t\n\t\t\tvar x = gl.xs[i], y = gl.ys[i];\n\t\t\t\n\t\t\tif(i==i0) { \n\t\t\t\tif(onCurve)  \n\t\t\t\t{\n\t\t\t\t\tif(prOnCurve) { Typr.U.P.moveTo(p, gl.xs[pr], gl.ys[pr]); } \n\t\t\t\t\telse          {  Typr.U.P.moveTo(p,x,y);  continue;  /*  will do curveTo at il  */  }\n\t\t\t\t}\n\t\t\t\telse        \n\t\t\t\t{\n\t\t\t\t\tif(prOnCurve) { Typr.U.P.moveTo(p,  gl.xs[pr],       gl.ys[pr]        ); }\n\t\t\t\t\telse          { Typr.U.P.moveTo(p, (gl.xs[pr]+x)/2, (gl.ys[pr]+y)/2   ); } \n\t\t\t\t}\n\t\t\t}\n\t\t\tif(onCurve)\n\t\t\t{\n\t\t\t\tif(prOnCurve) { Typr.U.P.lineTo(p,x,y); }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nxOnCurve) { Typr.U.P.qcurveTo(p, x, y, gl.xs[nx], gl.ys[nx]); } \n\t\t\t\telse          { Typr.U.P.qcurveTo(p, x, y, (x+gl.xs[nx])/2, (y+gl.ys[nx])/2); } \n\t\t\t}\n\t\t}\n\t\tTypr.U.P.closePath(p);\n\t}\n};\nTypr.U._compoGlyph = function(gl, font, p)\n{\n\tfor(var j=0; j<gl.parts.length; j++)\n\t{\n\t\tvar path = { cmds:[], crds:[] };\n\t\tvar prt = gl.parts[j];\n\t\tTypr.U._drawGlyf(prt.glyphIndex, font, path);\n\t\t\n\t\tvar m = prt.m;\n\t\tfor(var i=0; i<path.crds.length; i+=2)\n\t\t{\n\t\t\tvar x = path.crds[i  ], y = path.crds[i+1];\n\t\t\tp.crds.push(x*m.a + y*m.b + m.tx);\n\t\t\tp.crds.push(x*m.c + y*m.d + m.ty);\n\t\t}\n\t\tfor(var i=0; i<path.cmds.length; i++) { p.cmds.push(path.cmds[i]); }\n\t}\n};\n\n\nTypr.U._getGlyphClass = function(g, cd)\n{\n\tvar intr = Typr._lctf.getInterval(cd, g);\n\treturn intr==-1 ? 0 : cd[intr+2];\n\t//for(var i=0; i<cd.start.length; i++) \n\t//\tif(cd.start[i]<=g && cd.end[i]>=g) return cd.class[i];\n\t//return 0;\n};\n\nTypr.U.getPairAdjustment = function(font, g1, g2)\n{\n\t//return 0;\n\tif(font.GPOS) {\n\t\tvar gpos = font[\"GPOS\"];\n\t\tvar llist = gpos.lookupList, flist = gpos.featureList;\n\t\tvar tused = [];\n\t\tfor(var i=0; i<flist.length; i++) \n\t\t{\n\t\t\tvar fl = flist[i];  //console.log(fl);\n\t\t\tif(fl.tag!=\"kern\") { continue; }\n\t\t\tfor(var ti=0; ti<fl.tab.length; ti++) {\n\t\t\t\tif(tused[fl.tab[ti]]) { continue; }  tused[fl.tab[ti]] = true;\n\t\t\t\tvar tab = llist[fl.tab[ti]];\n\t\t\t\t//console.log(tab);\n\t\t\t\t\n\t\t\t\tfor(var j=0; j<tab.tabs.length; j++)\n\t\t\t\t{\n\t\t\t\t\tif(tab.tabs[i]==null) { continue; }\n\t\t\t\t\tvar ltab = tab.tabs[j], ind;\n\t\t\t\t\tif(ltab.coverage) {  ind = Typr._lctf.coverageIndex(ltab.coverage, g1);  if(ind==-1) { continue; }  }\n\t\t\t\t\t\n\t\t\t\t\tif(tab.ltype==1) ;\n\t\t\t\t\telse if(tab.ltype==2)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar adj;\n\t\t\t\t\t\tif(ltab.fmt==1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar right = ltab.pairsets[ind];\n\t\t\t\t\t\t\tfor(var i=0; i<right.length; i++) { if(right[i].gid2==g2) { adj = right[i]; } }\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ltab.fmt==2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar c1 = Typr.U._getGlyphClass(g1, ltab.classDef1);\n\t\t\t\t\t\t\tvar c2 = Typr.U._getGlyphClass(g2, ltab.classDef2);\n\t\t\t\t\t\t\tadj = ltab.matrix[c1][c2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//if(adj) console.log(ltab, adj);\n\t\t\t\t\t\tif(adj && adj.val2) { return adj.val2[2]; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(font.kern)\n\t{\n\t\tvar ind1 = font.kern.glyph1.indexOf(g1);\n\t\tif(ind1!=-1)\n\t\t{\n\t\t\tvar ind2 = font.kern.rval[ind1].glyph2.indexOf(g2);\n\t\t\tif(ind2!=-1) { return font.kern.rval[ind1].vals[ind2]; }\n\t\t}\n\t}\n\t\n\treturn 0;\n};\n\nTypr.U.stringToGlyphs = function(font, str)\n{\n\tvar gls = [];\n\tfor(var i=0; i<str.length; i++) {\n\t\tvar cc = str.codePointAt(i);  if(cc>0xffff) { i++; }\n\t\tgls.push(Typr.U.codeToGlyph(font, cc));\n\t}\n\tfor(var i=0; i<str.length; i++) {\n\t\tvar cc = str.codePointAt(i);  //\n\t\tif(cc==2367) {  var t=gls[i-1];  gls[i-1]=gls[i];  gls[i]=t;  }\n\t\t//if(cc==2381) {  var t=gls[i+1];  gls[i+1]=gls[i];  gls[i]=t;  }\n\t\tif(cc>0xffff) { i++; }\n\t}\n\t//console.log(gls.slice(0));\n\t\n\t//console.log(gls);  return gls;\n\t\n\tvar gsub = font[\"GSUB\"];  if(gsub==null) { return gls; }\n\tvar llist = gsub.lookupList, flist = gsub.featureList;\n\t\n\tvar cligs = [\"rlig\", \"liga\", \"mset\",  \"isol\",\"init\",\"fina\",\"medi\",   \"half\", \"pres\", \n\t\t\t\t\"blws\" /* Tibetan fonts like Himalaya.ttf */ ];\n\t\n\t//console.log(gls.slice(0));\n\tvar tused = [];\n\tfor(var fi=0; fi<flist.length; fi++)\n\t{\n\t\tvar fl = flist[fi];  if(cligs.indexOf(fl.tag)==-1) { continue; }\n\t\t//if(fl.tag==\"blwf\") continue;\n\t\t//console.log(fl);\n\t\t//console.log(fl.tag);\n\t\tfor(var ti=0; ti<fl.tab.length; ti++) {\n\t\t\tif(tused[fl.tab[ti]]) { continue; }  tused[fl.tab[ti]] = true;\n\t\t\tvar tab = llist[fl.tab[ti]];\n\t\t\t//console.log(fl.tab[ti], tab.ltype);\n\t\t\t//console.log(fl.tag, tab);\n\t\t\tfor(var ci=0; ci<gls.length; ci++) {\n\t\t\t\tvar feat = Typr.U._getWPfeature(str, ci);\n\t\t\t\tif(\"isol,init,fina,medi\".indexOf(fl.tag)!=-1 && fl.tag!=feat) { continue; }\n\t\t\t\t\n\t\t\t\tTypr.U._applySubs(gls, ci, tab, llist);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn gls;\n};\nTypr.U._getWPfeature = function(str, ci) {  // get Word Position feature\n\tvar wsep = \"\\n\\t\\\" ,.:;!?()  \";\n\tvar R = \"\";\n\tvar L = \"\";\n\t\n\tvar slft = ci==0            || wsep.indexOf(str[ci-1])!=-1;\n\tvar srgt = ci==str.length-1 || wsep.indexOf(str[ci+1])!=-1;\n\t\t\n\tif(!slft && R.indexOf(str[ci-1])!=-1) { slft=true; }\n\tif(!srgt && R.indexOf(str[ci  ])!=-1) { srgt=true; }\n\t\t\n\tif(!srgt && L.indexOf(str[ci+1])!=-1) { srgt=true; }\n\tif(!slft && L.indexOf(str[ci  ])!=-1) { slft=true; }\n\t\t\n\tvar feat = null;\n\tif(slft) { feat = srgt ? \"isol\" : \"init\"; }\n\telse     { feat = srgt ? \"fina\" : \"medi\"; }\n\t\n\treturn feat;\n};\nTypr.U._applySubs = function(gls, ci, tab, llist) {\n\tvar rlim = gls.length-ci-1;\n\t//if(ci==0) console.log(\"++++ \", tab.ltype);\n\tfor(var j=0; j<tab.tabs.length; j++)\n\t{\n\t\tif(tab.tabs[j]==null) { continue; }\n\t\tvar ltab = tab.tabs[j], ind;\n\t\tif(ltab.coverage) {  ind = Typr._lctf.coverageIndex(ltab.coverage, gls[ci]);  if(ind==-1) { continue; }  }\n\t\t//if(ci==0) console.log(ind, ltab);\n\t\t//*\n\t\tif(tab.ltype==1) {\n\t\t\tvar gl = gls[ci];\n\t\t\tif(ltab.fmt==1) { gls[ci] = gls[ci]+ltab.delta; }\n\t\t\telse            { gls[ci] = ltab.newg[ind]; }\n\t\t\t//console.log(\"applying ... 1\", ci, gl, gls[ci]);\n\t\t}//*\n\t\telse if(tab.ltype==4) {\n\t\t\tvar vals = ltab.vals[ind];\n\t\t\t\n\t\t\tfor(var k=0; k<vals.length; k++) {\n\t\t\t\tvar lig = vals[k], rl = lig.chain.length;  if(rl>rlim) { continue; }\n\t\t\t\tvar good = true, em1 = 0;\n\t\t\t\tfor(var l=0; l<rl; l++) {  while(gls[ci+em1+(1+l)]==-1){ em1++; }  if(lig.chain[l]!=gls[ci+em1+(1+l)]) { good=false; }  }\n\t\t\t\tif(!good) { continue; }\n\t\t\t\tgls[ci]=lig.nglyph;\n\t\t\t\tfor(var l=0; l<rl+em1; l++) { gls[ci+l+1]=-1; }   break;  // first character changed, other ligatures do not apply anymore\n\t\t\t\t//console.log(\"lig\", ci, lig.chain, lig.nglyph);\n\t\t\t\t//console.log(\"applying ...\");\n\t\t\t}\n\t\t}\n\t\telse  if(tab.ltype==5 && ltab.fmt==2) {\n\t\t\tvar cind = Typr._lctf.getInterval(ltab.cDef, gls[ci]);\n\t\t\tvar cls = ltab.cDef[cind+2], scs = ltab.scset[cls]; \n\t\t\tfor(var i=0; i<scs.length; i++) {\n\t\t\t\tvar sc = scs[i], inp = sc.input;\n\t\t\t\tif(inp.length>rlim) { continue; }\n\t\t\t\tvar good = true;\n\t\t\t\tfor(var l=0; l<inp.length; l++) {\n\t\t\t\t\tvar cind2 = Typr._lctf.getInterval(ltab.cDef, gls[ci+1+l]);\n\t\t\t\t\tif(cind==-1 && ltab.cDef[cind2+2]!=inp[l]) {  good=false;  break;  }\n\t\t\t\t}\n\t\t\t\tif(!good) { continue; }\n\t\t\t\t//console.log(ci, gl);\n\t\t\t\tvar lrs = sc.substLookupRecords;\n\t\t\t\tfor(var k=0; k<lrs.length; k+=2)\n\t\t\t\t{\n\t\t\t\t\tvar gi = lrs[k], tabi = lrs[k+1];\n\t\t\t\t\t//Typr.U._applyType1(gls, ci+gi, llist[tabi]);\n\t\t\t\t\t//console.log(tabi, gls[ci+gi], llist[tabi]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(tab.ltype==6 && ltab.fmt==3) {\n\t\t\t//if(ltab.backCvg.length==0) return;\n\t\t\tif(!Typr.U._glsCovered(gls, ltab.backCvg, ci-ltab.backCvg.length)) { continue; }\n\t\t\tif(!Typr.U._glsCovered(gls, ltab.inptCvg, ci)) { continue; }\n\t\t\tif(!Typr.U._glsCovered(gls, ltab.ahedCvg, ci+ltab.inptCvg.length)) { continue; }\n\t\t\t//console.log(ci, ltab);\n\t\t\tvar lr = ltab.lookupRec;  //console.log(ci, gl, lr);\n\t\t\tfor(var i=0; i<lr.length; i+=2) {\n\t\t\t\tvar cind = lr[i], tab2 = llist[lr[i+1]];\n\t\t\t\t//console.log(\"-\", lr[i+1], tab2);\n\t\t\t\tTypr.U._applySubs(gls, ci+cind, tab2, llist);\n\t\t\t}\n\t\t}\n\t\t//else console.log(\"Unknown table\", tab.ltype, ltab.fmt);\n\t\t//*/\n\t}\n};\n\nTypr.U._glsCovered = function(gls, cvgs, ci) {\n\tfor(var i=0; i<cvgs.length; i++) {\n\t\tvar ind = Typr._lctf.coverageIndex(cvgs[i], gls[ci+i]);  if(ind==-1) { return false; }\n\t}\n\treturn true;\n};\n\nTypr.U.glyphsToPath = function(font, gls, clr)\n{\t\n\t//gls = gls.reverse();//gls.slice(0,12).concat(gls.slice(12).reverse());\n\t\n\tvar tpath = {cmds:[], crds:[]};\n\tvar x = 0;\n\t\n\tfor(var i=0; i<gls.length; i++)\n\t{\n\t\tvar gid = gls[i];  if(gid==-1) { continue; }\n\t\tvar gid2 = (i<gls.length-1 && gls[i+1]!=-1)  ? gls[i+1] : 0;\n\t\tvar path = Typr.U.glyphToPath(font, gid);\n\t\tfor(var j=0; j<path.crds.length; j+=2)\n\t\t{\n\t\t\ttpath.crds.push(path.crds[j] + x);\n\t\t\ttpath.crds.push(path.crds[j+1]);\n\t\t}\n\t\tif(clr) { tpath.cmds.push(clr); }\n\t\tfor(var j=0; j<path.cmds.length; j++) { tpath.cmds.push(path.cmds[j]); }\n\t\tif(clr) { tpath.cmds.push(\"X\"); }\n\t\tx += font.hmtx.aWidth[gid];// - font.hmtx.lsBearing[gid];\n\t\tif(i<gls.length-1) { x += Typr.U.getPairAdjustment(font, gid, gid2); }\n\t}\n\treturn tpath;\n};\n\nTypr.U.pathToSVG = function(path, prec)\n{\n\tif(prec==null) { prec = 5; }\n\tvar out = [], co = 0, lmap = {\"M\":2,\"L\":2,\"Q\":4,\"C\":6};\n\tfor(var i=0; i<path.cmds.length; i++)\n\t{\n\t\tvar cmd = path.cmds[i], cn = co+(lmap[cmd]?lmap[cmd]:0);  \n\t\tout.push(cmd);\n\t\twhile(co<cn) {  var c = path.crds[co++];  out.push(parseFloat(c.toFixed(prec))+(co==cn?\"\":\" \"));  }\n\t}\n\treturn out.join(\"\");\n};\n\nTypr.U.pathToContext = function(path, ctx)\n{\n\tvar c = 0, crds = path.crds;\n\t\n\tfor(var j=0; j<path.cmds.length; j++)\n\t{\n\t\tvar cmd = path.cmds[j];\n\t\tif     (cmd==\"M\") {\n\t\t\tctx.moveTo(crds[c], crds[c+1]);\n\t\t\tc+=2;\n\t\t}\n\t\telse if(cmd==\"L\") {\n\t\t\tctx.lineTo(crds[c], crds[c+1]);\n\t\t\tc+=2;\n\t\t}\n\t\telse if(cmd==\"C\") {\n\t\t\tctx.bezierCurveTo(crds[c], crds[c+1], crds[c+2], crds[c+3], crds[c+4], crds[c+5]);\n\t\t\tc+=6;\n\t\t}\n\t\telse if(cmd==\"Q\") {\n\t\t\tctx.quadraticCurveTo(crds[c], crds[c+1], crds[c+2], crds[c+3]);\n\t\t\tc+=4;\n\t\t}\n\t\telse if(cmd.charAt(0)==\"#\") {\n\t\t\tctx.beginPath();\n\t\t\tctx.fillStyle = cmd;\n\t\t}\n\t\telse if(cmd==\"Z\") {\n\t\t\tctx.closePath();\n\t\t}\n\t\telse if(cmd==\"X\") {\n\t\t\tctx.fill();\n\t\t}\n\t}\n};\n\n\nTypr.U.P = {};\nTypr.U.P.moveTo = function(p, x, y)\n{\n\tp.cmds.push(\"M\");  p.crds.push(x,y);\n};\nTypr.U.P.lineTo = function(p, x, y)\n{\n\tp.cmds.push(\"L\");  p.crds.push(x,y);\n};\nTypr.U.P.curveTo = function(p, a,b,c,d,e,f)\n{\n\tp.cmds.push(\"C\");  p.crds.push(a,b,c,d,e,f);\n};\nTypr.U.P.qcurveTo = function(p, a,b,c,d)\n{\n\tp.cmds.push(\"Q\");  p.crds.push(a,b,c,d);\n};\nTypr.U.P.closePath = function(p) {  p.cmds.push(\"Z\");  };\n\n\n\n\nTypr.U._drawCFF = function(cmds, state, font, pdct, p)\n{\n\tvar stack = state.stack;\n\tvar nStems = state.nStems, haveWidth=state.haveWidth, width=state.width, open=state.open;\n\tvar i=0;\n\tvar x=state.x, y=state.y, c1x=0, c1y=0, c2x=0, c2y=0, c3x=0, c3y=0, c4x=0, c4y=0, jpx=0, jpy=0;\n\t\n\tvar o = {val:0,size:0};\n\t//console.log(cmds);\n\twhile(i<cmds.length)\n\t{\n\t\tTypr.CFF.getCharString(cmds, i, o);\n\t\tvar v = o.val;\n\t\ti += o.size;\n\t\t\t\n\t\tif(v==\"o1\" || v==\"o18\")  //  hstem || hstemhm\n\t\t{\n\t\t\tvar hasWidthArg;\n\n\t\t\t// The number of stem operators on the stack is always even.\n\t\t\t// If the value is uneven, that means a width is specified.\n\t\t\thasWidthArg = stack.length % 2 !== 0;\n\t\t\tif (hasWidthArg && !haveWidth) {\n\t\t\t\twidth = stack.shift() + pdct.nominalWidthX;\n\t\t\t}\n\n\t\t\tnStems += stack.length >> 1;\n\t\t\tstack.length = 0;\n\t\t\thaveWidth = true;\n\t\t}\n\t\telse if(v==\"o3\" || v==\"o23\")  // vstem || vstemhm\n\t\t{\n\t\t\tvar hasWidthArg;\n\n\t\t\t// The number of stem operators on the stack is always even.\n\t\t\t// If the value is uneven, that means a width is specified.\n\t\t\thasWidthArg = stack.length % 2 !== 0;\n\t\t\tif (hasWidthArg && !haveWidth) {\n\t\t\t\twidth = stack.shift() + pdct.nominalWidthX;\n\t\t\t}\n\n\t\t\tnStems += stack.length >> 1;\n\t\t\tstack.length = 0;\n\t\t\thaveWidth = true;\n\t\t}\n\t\telse if(v==\"o4\")\n\t\t{\n\t\t\tif (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + pdct.nominalWidthX;\n                        haveWidth = true;\n                    }\n\t\t\tif(open) { Typr.U.P.closePath(p); }\n\n                    y += stack.pop();\n\t\t\t\t\tTypr.U.P.moveTo(p,x,y);   open=true;\n\t\t}\n\t\telse if(v==\"o5\")\n\t\t{\n\t\t\twhile (stack.length > 0) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        Typr.U.P.lineTo(p, x, y);\n                    }\n\t\t}\n\t\telse if(v==\"o6\" || v==\"o7\")  // hlineto || vlineto\n\t\t{\n\t\t\tvar count = stack.length;\n\t\t\tvar isX = (v == \"o6\");\n\t\t\t\n\t\t\tfor(var j=0; j<count; j++) {\n\t\t\t\tvar sval = stack.shift();\n\t\t\t\t\n\t\t\t\tif(isX) { x += sval; }  else  { y += sval; }\n\t\t\t\tisX = !isX;\n\t\t\t\tTypr.U.P.lineTo(p, x, y);\n\t\t\t}\n\t\t}\n\t\telse if(v==\"o8\" || v==\"o24\")\t// rrcurveto || rcurveline\n\t\t{\n\t\t\tvar count = stack.length;\n\t\t\tvar index = 0;\n\t\t\twhile(index+6 <= count) {\n\t\t\t\tc1x = x + stack.shift();\n\t\t\t\tc1y = y + stack.shift();\n\t\t\t\tc2x = c1x + stack.shift();\n\t\t\t\tc2y = c1y + stack.shift();\n\t\t\t\tx = c2x + stack.shift();\n\t\t\t\ty = c2y + stack.shift();\n\t\t\t\tTypr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n\t\t\t\tindex+=6;\n\t\t\t}\n\t\t\tif(v==\"o24\")\n\t\t\t{\n\t\t\t\tx += stack.shift();\n\t\t\t\ty += stack.shift();\n\t\t\t\tTypr.U.P.lineTo(p, x, y);\n\t\t\t}\n\t\t}\n\t\telse if(v==\"o11\")  { break; }\n\t\telse if(v==\"o1234\" || v==\"o1235\" || v==\"o1236\" || v==\"o1237\")//if((v+\"\").slice(0,3)==\"o12\")\n\t\t{\n\t\t\tif(v==\"o1234\")\n\t\t\t{\n\t\t\t\tc1x = x   + stack.shift();    // dx1\n                c1y = y;                      // dy1\n\t\t\t\tc2x = c1x + stack.shift();    // dx2\n\t\t\t\tc2y = c1y + stack.shift();    // dy2\n\t\t\t\tjpx = c2x + stack.shift();    // dx3\n\t\t\t\tjpy = c2y;                    // dy3\n\t\t\t\tc3x = jpx + stack.shift();    // dx4\n\t\t\t\tc3y = c2y;                    // dy4\n\t\t\t\tc4x = c3x + stack.shift();    // dx5\n\t\t\t\tc4y = y;                      // dy5\n\t\t\t\tx = c4x + stack.shift();      // dx6\n\t\t\t\tTypr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n\t\t\t\tTypr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n\t\t\t\t\n\t\t\t}\n\t\t\tif(v==\"o1235\")\n\t\t\t{\n\t\t\t\tc1x = x   + stack.shift();    // dx1\n\t\t\t\tc1y = y   + stack.shift();    // dy1\n\t\t\t\tc2x = c1x + stack.shift();    // dx2\n\t\t\t\tc2y = c1y + stack.shift();    // dy2\n\t\t\t\tjpx = c2x + stack.shift();    // dx3\n\t\t\t\tjpy = c2y + stack.shift();    // dy3\n\t\t\t\tc3x = jpx + stack.shift();    // dx4\n\t\t\t\tc3y = jpy + stack.shift();    // dy4\n\t\t\t\tc4x = c3x + stack.shift();    // dx5\n\t\t\t\tc4y = c3y + stack.shift();    // dy5\n\t\t\t\tx = c4x + stack.shift();      // dx6\n\t\t\t\ty = c4y + stack.shift();      // dy6\n\t\t\t\tstack.shift();                // flex depth\n\t\t\t\tTypr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n\t\t\t\tTypr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n\t\t\t}\n\t\t\tif(v==\"o1236\")\n\t\t\t{\n\t\t\t\tc1x = x   + stack.shift();    // dx1\n\t\t\t\tc1y = y   + stack.shift();    // dy1\n\t\t\t\tc2x = c1x + stack.shift();    // dx2\n\t\t\t\tc2y = c1y + stack.shift();    // dy2\n\t\t\t\tjpx = c2x + stack.shift();    // dx3\n\t\t\t\tjpy = c2y;                    // dy3\n\t\t\t\tc3x = jpx + stack.shift();    // dx4\n\t\t\t\tc3y = c2y;                    // dy4\n\t\t\t\tc4x = c3x + stack.shift();    // dx5\n\t\t\t\tc4y = c3y + stack.shift();    // dy5\n\t\t\t\tx = c4x + stack.shift();      // dx6\n\t\t\t\tTypr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n\t\t\t\tTypr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n\t\t\t}\n\t\t\tif(v==\"o1237\")\n\t\t\t{\n\t\t\t\tc1x = x   + stack.shift();    // dx1\n\t\t\t\tc1y = y   + stack.shift();    // dy1\n\t\t\t\tc2x = c1x + stack.shift();    // dx2\n\t\t\t\tc2y = c1y + stack.shift();    // dy2\n\t\t\t\tjpx = c2x + stack.shift();    // dx3\n\t\t\t\tjpy = c2y + stack.shift();    // dy3\n\t\t\t\tc3x = jpx + stack.shift();    // dx4\n\t\t\t\tc3y = jpy + stack.shift();    // dy4\n\t\t\t\tc4x = c3x + stack.shift();    // dx5\n\t\t\t\tc4y = c3y + stack.shift();    // dy5\n\t\t\t\tif (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n\t\t\t\t    x = c4x + stack.shift();\n\t\t\t\t} else {\n\t\t\t\t    y = c4y + stack.shift();\n\t\t\t\t}\n\t\t\t\tTypr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n\t\t\t\tTypr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n\t\t\t}\n\t\t}\n\t\telse if(v==\"o14\")\n\t\t{\n\t\t\tif (stack.length > 0 && !haveWidth) {\n                        width = stack.shift() + font.nominalWidthX;\n                        haveWidth = true;\n                    }\n\t\t\tif(stack.length==4) // seac = standard encoding accented character\n\t\t\t{\n\t\t\t\tvar adx = stack.shift();\n\t\t\t\tvar ady = stack.shift();\n\t\t\t\tvar bchar = stack.shift();\n\t\t\t\tvar achar = stack.shift();\n\t\t\t\n\t\t\t\t\n\t\t\t\tvar bind = Typr.CFF.glyphBySE(font, bchar);\n\t\t\t\tvar aind = Typr.CFF.glyphBySE(font, achar);\n\t\t\t\t\n\t\t\t\t//console.log(bchar, bind);\n\t\t\t\t//console.log(achar, aind);\n\t\t\t\t//state.x=x; state.y=y; state.nStems=nStems; state.haveWidth=haveWidth; state.width=width;  state.open=open;\n\t\t\t\t\n\t\t\t\tTypr.U._drawCFF(font.CharStrings[bind], state,font,pdct,p);\n\t\t\t\tstate.x = adx; state.y = ady;\n\t\t\t\tTypr.U._drawCFF(font.CharStrings[aind], state,font,pdct,p);\n\t\t\t\t\n\t\t\t\t//x=state.x; y=state.y; nStems=state.nStems; haveWidth=state.haveWidth; width=state.width;  open=state.open;\n\t\t\t}\n\t\t\tif(open) {  Typr.U.P.closePath(p);  open=false;  }\n\t\t}\t\t\n\t\telse if(v==\"o19\" || v==\"o20\") \n\t\t{ \n\t\t\tvar hasWidthArg;\n\n\t\t\t// The number of stem operators on the stack is always even.\n\t\t\t// If the value is uneven, that means a width is specified.\n\t\t\thasWidthArg = stack.length % 2 !== 0;\n\t\t\tif (hasWidthArg && !haveWidth) {\n\t\t\t\twidth = stack.shift() + pdct.nominalWidthX;\n\t\t\t}\n\n\t\t\tnStems += stack.length >> 1;\n\t\t\tstack.length = 0;\n\t\t\thaveWidth = true;\n\t\t\t\n\t\t\ti += (nStems + 7) >> 3;\n\t\t}\n\t\t\n\t\telse if(v==\"o21\") {\n\t\t\tif (stack.length > 2 && !haveWidth) {\n                        width = stack.shift() + pdct.nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    x += stack.pop();\n\t\t\t\t\t\n\t\t\t\t\tif(open) { Typr.U.P.closePath(p); }\n                    Typr.U.P.moveTo(p,x,y);   open=true;\n\t\t}\n\t\telse if(v==\"o22\")\n\t\t{\n\t\t\t if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + pdct.nominalWidthX;\n                        haveWidth = true;\n                    }\n\t\t\t\t\t\n                    x += stack.pop();\n\t\t\t\t\t\n\t\t\t\t\tif(open) { Typr.U.P.closePath(p); }\n\t\t\t\t\tTypr.U.P.moveTo(p,x,y);   open=true;                    \n\t\t}\n\t\telse if(v==\"o25\")\n\t\t{\n\t\t\twhile (stack.length > 6) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        Typr.U.P.lineTo(p, x, y);\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n\t\t}\n\t\telse if(v==\"o26\") \n\t\t{\n\t\t\tif (stack.length % 2) {\n                        x += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x;\n                        y = c2y + stack.shift();\n                        Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n                    }\n\n\t\t}\n\t\telse if(v==\"o27\")\n\t\t{\n\t\t\tif (stack.length % 2) {\n                        y += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y;\n                        Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n                    }\n\t\t}\n\t\telse if(v==\"o10\" || v==\"o29\")\t// callsubr || callgsubr\n\t\t{\n\t\t\tvar obj = (v==\"o10\" ? pdct : font);\n\t\t\tif(stack.length==0) { console.log(\"error: empty stack\");  }\n\t\t\telse {\n\t\t\t\tvar ind = stack.pop();\n\t\t\t\tvar subr = obj.Subrs[ ind + obj.Bias ];\n\t\t\t\tstate.x=x; state.y=y; state.nStems=nStems; state.haveWidth=haveWidth; state.width=width;  state.open=open;\n\t\t\t\tTypr.U._drawCFF(subr, state,font,pdct,p);\n\t\t\t\tx=state.x; y=state.y; nStems=state.nStems; haveWidth=state.haveWidth; width=state.width;  open=state.open;\n\t\t\t}\n\t\t}\n\t\telse if(v==\"o30\" || v==\"o31\")   // vhcurveto || hvcurveto\n\t\t{\n\t\t\tvar count, count1 = stack.length;\n\t\t\tvar index = 0;\n\t\t\tvar alternate = v == \"o31\";\n\t\t\t\n\t\t\tcount  = count1 & ~2;\n\t\t\tindex += count1 - count;\n\t\t\t\n\t\t\twhile ( index < count ) \n\t\t\t{\n\t\t\t\tif(alternate)\n\t\t\t\t{\n\t\t\t\t\tc1x = x + stack.shift();\n\t\t\t\t\tc1y = y;\n\t\t\t\t\tc2x = c1x + stack.shift();\n\t\t\t\t\tc2y = c1y + stack.shift();\n\t\t\t\t\ty = c2y + stack.shift();\n\t\t\t\t\tif(count-index == 5) {  x = c2x + stack.shift();  index++;  }\n\t\t\t\t\telse { x = c2x; }\n\t\t\t\t\talternate = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tc1x = x;\n\t\t\t\t\tc1y = y + stack.shift();\n\t\t\t\t\tc2x = c1x + stack.shift();\n\t\t\t\t\tc2y = c1y + stack.shift();\n\t\t\t\t\tx = c2x + stack.shift();\n\t\t\t\t\tif(count-index == 5) {  y = c2y + stack.shift();  index++;  }\n\t\t\t\t\telse { y = c2y; }\n\t\t\t\t\talternate = true;\n\t\t\t\t}\n                Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n\t\t\t\tindex += 4;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse if((v+\"\").charAt(0)==\"o\") {   console.log(\"Unknown operation: \"+v, cmds); throw v;  }\n\t\telse { stack.push(v); }\n\t}\n\t//console.log(cmds);\n\tstate.x=x; state.y=y; state.nStems=nStems; state.haveWidth=haveWidth; state.width=width; state.open=open;\n};\n\n// End Typr.U.js\n\nreturn Typr\n\n}\n\n// Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with tiny-inflate \n// (https://github.com/foliojs/tiny-inflate) for use in troika-3d-text. \n// Original licenses apply: \n// - tiny-inflate: https://github.com/foliojs/tiny-inflate/blob/master/LICENSE (MIT)\n// - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n\nfunction woff2otfFactory() {\n\n// Begin tinyInflate\nvar tinyInflate = (function() {\n  var module = {};\n  var TINF_OK = 0;\nvar TINF_DATA_ERROR = -3;\n\nfunction Tree() {\n  this.table = new Uint16Array(16);   /* table of code length counts */\n  this.trans = new Uint16Array(288);  /* code -> symbol translation table */\n}\n\nfunction Data(source, dest) {\n  this.source = source;\n  this.sourceIndex = 0;\n  this.tag = 0;\n  this.bitcount = 0;\n  \n  this.dest = dest;\n  this.destLen = 0;\n  \n  this.ltree = new Tree();  /* dynamic length/symbol tree */\n  this.dtree = new Tree();  /* dynamic distance tree */\n}\n\n/* --------------------------------------------------- *\n * -- uninitialized global data (static structures) -- *\n * --------------------------------------------------- */\n\nvar sltree = new Tree();\nvar sdtree = new Tree();\n\n/* extra bits and base tables for length codes */\nvar length_bits = new Uint8Array(30);\nvar length_base = new Uint16Array(30);\n\n/* extra bits and base tables for distance codes */\nvar dist_bits = new Uint8Array(30);\nvar dist_base = new Uint16Array(30);\n\n/* special ordering of code length codes */\nvar clcidx = new Uint8Array([\n  16, 17, 18, 0, 8, 7, 9, 6,\n  10, 5, 11, 4, 12, 3, 13, 2,\n  14, 1, 15\n]);\n\n/* used by tinf_decode_trees, avoids allocations every call */\nvar code_tree = new Tree();\nvar lengths = new Uint8Array(288 + 32);\n\n/* ----------------------- *\n * -- utility functions -- *\n * ----------------------- */\n\n/* build extra bits and base tables */\nfunction tinf_build_bits_base(bits, base, delta, first) {\n  var i, sum;\n\n  /* build bits table */\n  for (i = 0; i < delta; ++i) { bits[i] = 0; }\n  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }\n\n  /* build base table */\n  for (sum = first, i = 0; i < 30; ++i) {\n    base[i] = sum;\n    sum += 1 << bits[i];\n  }\n}\n\n/* build the fixed huffman trees */\nfunction tinf_build_fixed_trees(lt, dt) {\n  var i;\n\n  /* build fixed length tree */\n  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }\n\n  lt.table[7] = 24;\n  lt.table[8] = 152;\n  lt.table[9] = 112;\n\n  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }\n  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }\n  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }\n  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }\n\n  /* build fixed distance tree */\n  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }\n\n  dt.table[5] = 32;\n\n  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }\n}\n\n/* given an array of code lengths, build a tree */\nvar offs = new Uint16Array(16);\n\nfunction tinf_build_tree(t, lengths, off, num) {\n  var i, sum;\n\n  /* clear code length count table */\n  for (i = 0; i < 16; ++i) { t.table[i] = 0; }\n\n  /* scan symbol lengths, and sum code length counts */\n  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }\n\n  t.table[0] = 0;\n\n  /* compute offset table for distribution sort */\n  for (sum = 0, i = 0; i < 16; ++i) {\n    offs[i] = sum;\n    sum += t.table[i];\n  }\n\n  /* create code->symbol translation table (symbols sorted by code) */\n  for (i = 0; i < num; ++i) {\n    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }\n  }\n}\n\n/* ---------------------- *\n * -- decode functions -- *\n * ---------------------- */\n\n/* get one bit from source stream */\nfunction tinf_getbit(d) {\n  /* check if tag is empty */\n  if (!d.bitcount--) {\n    /* load next tag */\n    d.tag = d.source[d.sourceIndex++];\n    d.bitcount = 7;\n  }\n\n  /* shift bit out of tag */\n  var bit = d.tag & 1;\n  d.tag >>>= 1;\n\n  return bit;\n}\n\n/* read a num bit value from a stream and add base */\nfunction tinf_read_bits(d, num, base) {\n  if (!num)\n    { return base; }\n\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n\n  var val = d.tag & (0xffff >>> (16 - num));\n  d.tag >>>= num;\n  d.bitcount -= num;\n  return val + base;\n}\n\n/* given a data stream and a tree, decode a symbol */\nfunction tinf_decode_symbol(d, t) {\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n  \n  var sum = 0, cur = 0, len = 0;\n  var tag = d.tag;\n\n  /* get more bits while code value is above sum */\n  do {\n    cur = 2 * cur + (tag & 1);\n    tag >>>= 1;\n    ++len;\n\n    sum += t.table[len];\n    cur -= t.table[len];\n  } while (cur >= 0);\n  \n  d.tag = tag;\n  d.bitcount -= len;\n\n  return t.trans[sum + cur];\n}\n\n/* given a data stream, decode dynamic trees from it */\nfunction tinf_decode_trees(d, lt, dt) {\n  var hlit, hdist, hclen;\n  var i, num, length;\n\n  /* get 5 bits HLIT (257-286) */\n  hlit = tinf_read_bits(d, 5, 257);\n\n  /* get 5 bits HDIST (1-32) */\n  hdist = tinf_read_bits(d, 5, 1);\n\n  /* get 4 bits HCLEN (4-19) */\n  hclen = tinf_read_bits(d, 4, 4);\n\n  for (i = 0; i < 19; ++i) { lengths[i] = 0; }\n\n  /* read code lengths for code length alphabet */\n  for (i = 0; i < hclen; ++i) {\n    /* get 3 bits code length (0-7) */\n    var clen = tinf_read_bits(d, 3, 0);\n    lengths[clcidx[i]] = clen;\n  }\n\n  /* build code length tree */\n  tinf_build_tree(code_tree, lengths, 0, 19);\n\n  /* decode code lengths for the dynamic trees */\n  for (num = 0; num < hlit + hdist;) {\n    var sym = tinf_decode_symbol(d, code_tree);\n\n    switch (sym) {\n      case 16:\n        /* copy previous code length 3-6 times (read 2 bits) */\n        var prev = lengths[num - 1];\n        for (length = tinf_read_bits(d, 2, 3); length; --length) {\n          lengths[num++] = prev;\n        }\n        break;\n      case 17:\n        /* repeat code length 0 for 3-10 times (read 3 bits) */\n        for (length = tinf_read_bits(d, 3, 3); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      case 18:\n        /* repeat code length 0 for 11-138 times (read 7 bits) */\n        for (length = tinf_read_bits(d, 7, 11); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      default:\n        /* values 0-15 represent the actual code lengths */\n        lengths[num++] = sym;\n        break;\n    }\n  }\n\n  /* build dynamic trees */\n  tinf_build_tree(lt, lengths, 0, hlit);\n  tinf_build_tree(dt, lengths, hlit, hdist);\n}\n\n/* ----------------------------- *\n * -- block inflate functions -- *\n * ----------------------------- */\n\n/* given a stream and two trees, inflate a block of data */\nfunction tinf_inflate_block_data(d, lt, dt) {\n  while (1) {\n    var sym = tinf_decode_symbol(d, lt);\n\n    /* check for end of block */\n    if (sym === 256) {\n      return TINF_OK;\n    }\n\n    if (sym < 256) {\n      d.dest[d.destLen++] = sym;\n    } else {\n      var length, dist, offs;\n      var i;\n\n      sym -= 257;\n\n      /* possibly get more bits from length code */\n      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n\n      dist = tinf_decode_symbol(d, dt);\n\n      /* possibly get more bits from distance code */\n      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n\n      /* copy match */\n      for (i = offs; i < offs + length; ++i) {\n        d.dest[d.destLen++] = d.dest[i];\n      }\n    }\n  }\n}\n\n/* inflate an uncompressed block of data */\nfunction tinf_inflate_uncompressed_block(d) {\n  var length, invlength;\n  var i;\n  \n  /* unread from bitbuffer */\n  while (d.bitcount > 8) {\n    d.sourceIndex--;\n    d.bitcount -= 8;\n  }\n\n  /* get length */\n  length = d.source[d.sourceIndex + 1];\n  length = 256 * length + d.source[d.sourceIndex];\n\n  /* get one's complement of length */\n  invlength = d.source[d.sourceIndex + 3];\n  invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n\n  /* check length */\n  if (length !== (~invlength & 0x0000ffff))\n    { return TINF_DATA_ERROR; }\n\n  d.sourceIndex += 4;\n\n  /* copy block */\n  for (i = length; i; --i)\n    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }\n\n  /* make sure we start next block on a byte boundary */\n  d.bitcount = 0;\n\n  return TINF_OK;\n}\n\n/* inflate stream from source to dest */\nfunction tinf_uncompress(source, dest) {\n  var d = new Data(source, dest);\n  var bfinal, btype, res;\n\n  do {\n    /* read final block flag */\n    bfinal = tinf_getbit(d);\n\n    /* read block type (2 bits) */\n    btype = tinf_read_bits(d, 2, 0);\n\n    /* decompress block */\n    switch (btype) {\n      case 0:\n        /* decompress uncompressed block */\n        res = tinf_inflate_uncompressed_block(d);\n        break;\n      case 1:\n        /* decompress block with fixed huffman trees */\n        res = tinf_inflate_block_data(d, sltree, sdtree);\n        break;\n      case 2:\n        /* decompress block with dynamic huffman trees */\n        tinf_decode_trees(d, d.ltree, d.dtree);\n        res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n        break;\n      default:\n        res = TINF_DATA_ERROR;\n    }\n\n    if (res !== TINF_OK)\n      { throw new Error('Data error'); }\n\n  } while (!bfinal);\n\n  if (d.destLen < d.dest.length) {\n    if (typeof d.dest.slice === 'function')\n      { return d.dest.slice(0, d.destLen); }\n    else\n      { return d.dest.subarray(0, d.destLen); }\n  }\n  \n  return d.dest;\n}\n\n/* -------------------- *\n * -- initialization -- *\n * -------------------- */\n\n/* build fixed huffman trees */\ntinf_build_fixed_trees(sltree, sdtree);\n\n/* build extra bits and base tables */\ntinf_build_bits_base(length_bits, length_base, 4, 3);\ntinf_build_bits_base(dist_bits, dist_base, 2, 1);\n\n/* fix a special case */\nlength_bits[28] = 0;\nlength_base[28] = 258;\n\nmodule.exports = tinf_uncompress;\n\n  return module.exports\n})();\n// End tinyInflate\n\n// Begin woff2otf.js\n/*\n Copyright 2012, Steffen Hanikel (https://github.com/hanikesn)\n Modified by Artemy Tregubenko, 2014 (https://github.com/arty-name/woff2otf)\n Modified by Jason Johnston, 2019 (pako --> tiny-inflate)\n \n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n A tool to convert a WOFF back to a TTF/OTF font file, in pure Javascript\n*/\n\nfunction convert_streams(bufferIn, tinyInflate) {\n    var dataViewIn = new DataView(bufferIn);\n    var offsetIn = 0;\n\n    function read2() {\n        var uint16 = dataViewIn.getUint16(offsetIn);\n        offsetIn += 2;\n        return uint16;\n    }\n\n    function read4() {\n        var uint32 = dataViewIn.getUint32(offsetIn);\n        offsetIn += 4;\n        return uint32;\n    }\n\n    function write2(uint16) {\n        dataViewOut.setUint16(offsetOut, uint16);\n        offsetOut += 2;\n    }\n\n    function write4(uint32) {\n        dataViewOut.setUint32(offsetOut, uint32);\n        offsetOut += 4;\n    }\n\n    var WOFFHeader = {\n        signature: read4(),\n        flavor: read4(),\n        length: read4(),\n        numTables: read2(),\n        reserved: read2(),\n        totalSfntSize: read4(),\n        majorVersion: read2(),\n        minorVersion: read2(),\n        metaOffset: read4(),\n        metaLength: read4(),\n        metaOrigLength: read4(),\n        privOffset: read4(),\n        privLength: read4()\n    };\n\n    var entrySelector = 0;\n    while (Math.pow(2, entrySelector) <= WOFFHeader.numTables) {\n        entrySelector++;\n    }\n    entrySelector--;\n\n    var searchRange = Math.pow(2, entrySelector) * 16;\n    var rangeShift = WOFFHeader.numTables * 16 - searchRange;\n\n    var offset = 4 + 2 + 2 + 2 + 2;\n    var TableDirectoryEntries = [];\n    for (var i = 0; i < WOFFHeader.numTables; i++) {\n        TableDirectoryEntries.push({\n            tag: read4(),\n            offset: read4(),\n            compLength: read4(),\n            origLength: read4(),\n            origChecksum: read4()\n        });\n        offset += 4 * 4;\n    }\n\n    var arrayOut = new Uint8Array(\n        4 + 2 + 2 + 2 + 2 +\n        TableDirectoryEntries.length * (4 + 4 + 4 + 4) +\n        TableDirectoryEntries.reduce(function(acc, entry) { return acc + entry.origLength + 4; }, 0)\n    );\n    var bufferOut = arrayOut.buffer;\n    var dataViewOut = new DataView(bufferOut);\n    var offsetOut = 0;\n\n    write4(WOFFHeader.flavor);\n    write2(WOFFHeader.numTables);\n    write2(searchRange);\n    write2(entrySelector);\n    write2(rangeShift);\n\n    TableDirectoryEntries.forEach(function(TableDirectoryEntry) {\n        write4(TableDirectoryEntry.tag);\n        write4(TableDirectoryEntry.origChecksum);\n        write4(offset);\n        write4(TableDirectoryEntry.origLength);\n\n        TableDirectoryEntry.outOffset = offset;\n        offset += TableDirectoryEntry.origLength;\n        if ((offset % 4) != 0) {\n            offset += 4 - (offset % 4);\n        }\n    });\n\n    var size;\n\n    TableDirectoryEntries.forEach(function(TableDirectoryEntry) {\n        var compressedData = bufferIn.slice(\n            TableDirectoryEntry.offset,\n            TableDirectoryEntry.offset + TableDirectoryEntry.compLength\n        );\n\n        if (TableDirectoryEntry.compLength != TableDirectoryEntry.origLength) {\n            var uncompressedData = new Uint8Array(TableDirectoryEntry.origLength);\n            tinyInflate(\n              new Uint8Array(compressedData, 2), //skip deflate header\n              uncompressedData\n            );\n        } else {\n            uncompressedData = new Uint8Array(compressedData);\n        }\n\n        arrayOut.set(uncompressedData, TableDirectoryEntry.outOffset);\n        offset = TableDirectoryEntry.outOffset + TableDirectoryEntry.origLength;\n\n        var padding = 0;\n        if ((offset % 4) != 0) {\n            padding = 4 - (offset % 4);\n        }\n        arrayOut.set(\n            new Uint8Array(padding).buffer,\n            TableDirectoryEntry.outOffset + TableDirectoryEntry.origLength\n        );\n\n        size = offset + padding;\n    });\n\n    return bufferOut.slice(0, size);\n}\n\n// End woff2otf.js\n\nreturn function(buffer) {\n  return convert_streams(buffer, tinyInflate)\n}\n\n}\n\n/**\n * An adapter that allows Typr.js to be used as if it were (a subset of) the OpenType.js API.\n * Also adds support for WOFF files (not WOFF2).\n */\n\nfunction parserFactory(Typr, woff2otf) {\n  var cmdArgLengths = {\n    M: 2,\n    L: 2,\n    Q: 4,\n    C: 6,\n    Z: 0\n  };\n\n  function wrapFontObj(ref) {\n    var typrFont = ref[0];\n\n    var glyphMap = Object.create(null);\n\n    var fontObj = {\n      unitsPerEm: typrFont.head.unitsPerEm,\n      ascender: typrFont.hhea.ascender,\n      descender: typrFont.hhea.descender,\n      forEachGlyph: function forEachGlyph(text, fontSize, letterSpacing, callback) {\n        var glyphX = 0;\n        var fontScale = 1 / fontObj.unitsPerEm * fontSize;\n\n        var glyphIndices = Typr.U.stringToGlyphs(typrFont, text);\n        var charIndex = 0;\n        glyphIndices.forEach(function (glyphIndex) {\n          // Typr returns a glyph index per string codepoint, with -1s in place of those that\n          // were omitted due to ligature substitution. So we can track original index in the\n          // string via simple increment, and skip everything else when seeing a -1.\n          if (glyphIndex !== -1) {\n            var glyphObj = glyphMap[glyphIndex];\n            if (!glyphObj) {\n              // !!! NOTE: Typr doesn't expose a public accessor for the glyph data, so this just\n              // copies how it parses that data in Typr.U._drawGlyf -- this may be fragile.\n              var typrGlyph = Typr.glyf._parseGlyf(typrFont, glyphIndex) || {xMin: 0, xMax: 0, yMin: 0, yMax: 0};\n              var ref = Typr.U.glyphToPath(typrFont, glyphIndex);\n              var cmds = ref.cmds;\n              var crds = ref.crds;\n\n              glyphObj = glyphMap[glyphIndex] = {\n                index: glyphIndex,\n                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],\n                xMin: typrGlyph.xMin,\n                yMin: typrGlyph.yMin,\n                xMax: typrGlyph.xMax,\n                yMax: typrGlyph.yMax,\n                pathCommandCount: cmds.length,\n                forEachPathCommand: function forEachPathCommand(callback) {\n                  var argsIndex = 0;\n                  var argsArray = [];\n                  for (var i = 0, len = cmds.length; i < len; i++) {\n                    var numArgs = cmdArgLengths[cmds[i]];\n                    argsArray.length = 1 + numArgs;\n                    argsArray[0] = cmds[i];\n                    for (var j = 1; j <= numArgs; j++) {\n                      argsArray[j] = crds[argsIndex++];\n                    }\n                    callback.apply(null, argsArray);\n                  }\n                }\n              };\n            }\n\n            callback.call(null, glyphObj, glyphX, charIndex);\n\n            if (glyphObj.advanceWidth) {\n              glyphX += glyphObj.advanceWidth * fontScale;\n            }\n            if (letterSpacing) {\n              glyphX += letterSpacing * fontSize;\n            }\n          }\n          charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);\n        });\n        return glyphX\n      }\n    };\n\n    return fontObj\n  }\n\n  return function parse(buffer) {\n    // Look to see if we have a WOFF file and convert it if so:\n    var peek = new Uint8Array(buffer, 0, 4);\n    var tag = Typr._bin.readASCII(peek, 0, 4);\n    if (tag === 'wOFF') {\n      buffer = woff2otf(buffer);\n    } else if (tag === 'wOF2') {\n      throw new Error('woff2 fonts not supported')\n    }\n    return wrapFontObj(Typr.parse(buffer))\n  }\n}\n\n\nvar workerModule = Object(troika_worker_utils__WEBPACK_IMPORTED_MODULE_1__[\"defineWorkerModule\"])({\n  dependencies: [typrFactory, woff2otfFactory, parserFactory],\n  init: function init(typrFactory, woff2otfFactory, parserFactory) {\n    var Typr = typrFactory();\n    var woff2otf = woff2otfFactory();\n    return parserFactory(Typr, woff2otf)\n  }\n});\n\n//import fontParser from './FontParser_OpenType.js'\n\n\nvar CONFIG = {\n  defaultFontURL: 'https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff', //Roboto Regular\n  sdfGlyphSize: 64,\n  textureWidth: 2048\n};\nvar linkEl = document.createElement('a'); //for resolving relative URLs to absolute\n\n/**\n * Customizes the text builder configuration. This must be called prior to the first font processing\n * request, and applies to all fonts.\n *\n * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n *                 requests, in case none is specified or the specifiede font fails to load or parse.\n *                 Defaults to \"Roboto Regular\" from Google Fonts.\n * @param {Number} config.sdfGlyphSize - The size of each glyph's SDF (signed distance field) texture\n *                 that is used for rendering. Must be a power-of-two number, and applies to all fonts.\n *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n *                 to 64 which is generally a good balance of size and quality.\n * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n *                 2048 which is a safe maximum texture dimension according to the stats at\n *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n *                 reasonably large number of glyphs (default glyph size of 64 and safe texture size of\n *                 2048^2 allows for 1024 glyphs.) This can be increased if you need to increase the\n *                 glyph size and/or have an extraordinary number of glyphs.\n */\nfunction configureTextBuilder(config) {\n  {\n    assign(CONFIG, config);\n  }\n}\n\n\n/**\n * The radial distance from glyph edges over which the SDF alpha will be calculated; if the alpha\n * at distance:0 is 0.5, then the alpha at this distance will be zero. This is defined as a percentage\n * of each glyph's maximum dimension in font space units so that it maps to the same minimum number of\n * SDF texels regardless of the glyph's size. A larger value provides greater alpha gradient resolution\n * and improves readability/antialiasing quality at small display sizes, but also decreases the number\n * of texels available for encoding path details.\n */\nvar SDF_DISTANCE_PERCENT = 1 / 8;\n\n\n/**\n * Repository for all font SDF atlas textures\n *\n *   {\n *     [font]: {\n *       sdfTexture: DataTexture\n *     }\n *   }\n */\nvar atlases = Object.create(null);\n\n/**\n * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n * @property {DataTexture} sdfTexture\n * @property {number} sdfGlyphSize\n * @property {number} sdfMinDistancePercent\n * @property {Float32Array} glyphBounds\n * @property {Float32Array} glyphAtlasIndices\n * @property {Float32Array} [caretPositions]\n * @property {number} [caretHeight]\n * @property {Array<number>} totalBounds\n * @property {Array<number>} totalBlockSize\n * @frozen\n */\n\n/**\n * @callback getTextRenderInfo~callback\n * @param {TroikaTextRenderInfo} textRenderInfo\n */\n\n/**\n * Main entry point for requesting the data needed to render a text string with given font parameters.\n * This is an asynchronous call, performing most of the logic in a web worker thread.\n * @param {object} args\n * @param {getTextRenderInfo~callback} callback\n */\nfunction getTextRenderInfo(args, callback) {\n  args = assign({}, args);\n\n  // Apply default font here to avoid a 'null' atlas, and convert relative\n  // URLs to absolute so they can be resolved in the worker\n  linkEl.href = args.font || CONFIG.defaultFontURL;\n  args.font = linkEl.href;\n\n  // Normalize text to a string\n  args.text = '' + args.text;\n\n  // Init the atlas for this font if needed\n  var sdfGlyphSize = CONFIG.sdfGlyphSize;\n  var textureWidth = CONFIG.textureWidth;\n  var atlas = atlases[args.font];\n  if (!atlas) {\n    atlas = atlases[args.font] = {\n      sdfTexture: new three__WEBPACK_IMPORTED_MODULE_0__[\"DataTexture\"](\n        new Uint8Array(sdfGlyphSize * textureWidth),\n        textureWidth,\n        sdfGlyphSize,\n        three__WEBPACK_IMPORTED_MODULE_0__[\"LuminanceFormat\"],\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        three__WEBPACK_IMPORTED_MODULE_0__[\"LinearFilter\"],\n        three__WEBPACK_IMPORTED_MODULE_0__[\"LinearFilter\"]\n      )\n    };\n    atlas.sdfTexture.font = args.font;\n  }\n\n  // Issue request to the FontProcessor in the worker\n  processInWorker(args).then(function (result) {\n    // If the response has newGlyphs, copy them into the atlas texture at the specified indices\n    if (result.newGlyphSDFs) {\n      result.newGlyphSDFs.forEach(function (ref) {\n        var textureData = ref.textureData;\n        var atlasIndex = ref.atlasIndex;\n\n        var texImg = atlas.sdfTexture.image;\n\n        // Grow the texture by power of 2 if needed\n        while (texImg.data.length < (atlasIndex + 1) * sdfGlyphSize * sdfGlyphSize) {\n          var biggerArray = new Uint8Array(texImg.data.length * 2);\n          biggerArray.set(texImg.data);\n          texImg.data = biggerArray;\n          texImg.height *= 2;\n        }\n\n        // Insert the new glyph's data into the full texture image at the correct offsets\n        var cols = texImg.width / sdfGlyphSize;\n        for (var y = 0; y < sdfGlyphSize; y++) {\n          var srcStartIndex = y * sdfGlyphSize;\n          var tgtStartIndex = texImg.width * sdfGlyphSize * Math.floor(atlasIndex / cols) //full rows\n            + (atlasIndex % cols) * sdfGlyphSize //partial row\n            + (y * texImg.width); //row within glyph\n          for (var x = 0; x < sdfGlyphSize; x++) {\n            texImg.data[tgtStartIndex + x] = textureData[srcStartIndex + x];\n          }\n        }\n      });\n      atlas.sdfTexture.needsUpdate = true;\n    }\n\n    // Invoke callback with the text layout arrays and updated texture\n    callback(Object.freeze({\n      sdfTexture: atlas.sdfTexture,\n      sdfGlyphSize: sdfGlyphSize,\n      sdfMinDistancePercent: SDF_DISTANCE_PERCENT,\n      glyphBounds: result.glyphBounds,\n      glyphAtlasIndices: result.glyphAtlasIndices,\n      caretPositions: result.caretPositions,\n      caretHeight: result.caretHeight,\n      totalBounds: result.totalBounds,\n      totalBlockSize: result.totalBlockSize\n    }));\n  });\n}\n\n// Local assign impl so we don't have to import troika-core\nfunction assign(toObj, fromObj) {\n  for (var key in fromObj) {\n    if (fromObj.hasOwnProperty(key)) {\n      toObj[key] = fromObj[key];\n    }\n  }\n  return toObj\n}\n\n\nvar fontProcessorWorkerModule = Object(troika_worker_utils__WEBPACK_IMPORTED_MODULE_1__[\"defineWorkerModule\"])({\n  dependencies: [\n    CONFIG,\n    SDF_DISTANCE_PERCENT,\n    workerModule,\n    createSDFGenerator,\n    createFontProcessor\n  ],\n  init: function init(config, sdfDistancePercent, fontParser, createSDFGenerator, createFontProcessor) {\n    var sdfGenerator = createSDFGenerator({\n      sdfTextureSize: config.sdfGlyphSize,\n      sdfDistancePercent: sdfDistancePercent\n    });\n    return createFontProcessor(fontParser, sdfGenerator, {\n      defaultFontUrl: config.defaultFontURL\n    })\n  }\n});\n\nvar processInWorker = Object(troika_worker_utils__WEBPACK_IMPORTED_MODULE_1__[\"defineWorkerModule\"])({\n  dependencies: [fontProcessorWorkerModule, troika_worker_utils__WEBPACK_IMPORTED_MODULE_1__[\"ThenableWorkerModule\"]],\n  init: function init(fontProcessor, Thenable) {\n    return function(args) {\n      var thenable = new Thenable();\n      fontProcessor.process(args, thenable.resolve);\n      return thenable\n    }\n  },\n  getTransferables: function getTransferables(result) {\n    // Mark array buffers as transferable to avoid cloning during postMessage\n    var transferables = [\n      result.glyphBounds.buffer,\n      result.glyphAtlasIndices.buffer\n    ];\n    if (result.caretPositions) {\n      transferables.push(result.caretPositions.buffer);\n    }\n    if (result.newGlyphSDFs) {\n      result.newGlyphSDFs.forEach(function (d) {\n        transferables.push(d.textureData.buffer);\n      });\n    }\n    return transferables\n  }\n});\n\n/*\nwindow._dumpSDFs = function() {\n  Object.values(atlases).forEach(atlas => {\n    const imgData = atlas.sdfTexture.image.data\n    const canvas = document.createElement('canvas')\n    const {width, height} = atlas.sdfTexture.image\n    canvas.width = width\n    canvas.height = height\n    const ctx = canvas.getContext('2d')\n    ctx.fillStyle = '#fff'\n    ctx.fillRect(0, 0, width, height)\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        ctx.fillStyle = `rgba(0,0,0,${imgData[y * width + x]/255})`\n        ctx.fillRect(x, y, 1, 1)\n      }\n    }\n    const img = new Image()\n    img.src = canvas.toDataURL()\n    document.body.appendChild(img)\n    console.log(img)\n  })\n}\n*/\n\nvar templateGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"PlaneBufferGeometry\"](1, 1).translate(0.5, 0.5, 0);\nvar tempVec3 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n\nvar glyphBoundsAttrName = 'aTroikaGlyphBounds';\nvar glyphIndexAttrName = 'aTroikaGlyphIndex';\n\n\n\n/**\n@class GlyphsGeometry\n\nA specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\nrender the glyphs using GPU instancing of a single quad, rather than constructing a whole\ngeometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n  Where N = number of glyphs...\n\n  Instanced:\n  - position: 4 * 3\n  - index: 2 * 3\n  - normal: 4 * 3\n  - uv: 4 * 2\n  - glyph x/y bounds: N * 4\n  - glyph indices: N * 1\n  = 5N + 38\n\n  Non-instanced:\n  - position: N * 4 * 3\n  - index: N * 2 * 3\n  - normal: N * 4 * 3\n  - uv: N * 4 * 2\n  - glyph indices: N * 1\n  = 39N\n\nA downside of this is the rare-but-possible lack of the instanced arrays extension,\nwhich we could potentially work around with a fallback non-instanced implementation.\n\n*/\nvar GlyphsGeometry = /*@__PURE__*/(function (InstancedBufferGeometry) {\n  function GlyphsGeometry() {\n    InstancedBufferGeometry.call(this);\n\n    // Base per-instance attributes\n    this.copy(templateGeometry);\n\n    // Preallocate zero-radius bounding sphere\n    this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_0__[\"Sphere\"]();\n  }\n\n  if ( InstancedBufferGeometry ) GlyphsGeometry.__proto__ = InstancedBufferGeometry;\n  GlyphsGeometry.prototype = Object.create( InstancedBufferGeometry && InstancedBufferGeometry.prototype );\n  GlyphsGeometry.prototype.constructor = GlyphsGeometry;\n\n  GlyphsGeometry.prototype.computeBoundingSphere = function computeBoundingSphere () {\n    // No-op; we'll sync the boundingSphere proactively in `updateGlyphs`.\n  };\n\n  /**\n   * Update the geometry for a new set of glyphs.\n   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n   *        the SDF atlas texture.\n   * @param {Array} totalBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n   */\n  GlyphsGeometry.prototype.updateGlyphs = function updateGlyphs (glyphBounds, glyphAtlasIndices, totalBounds) {\n    // Update the instance attributes\n    updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);\n    updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);\n    this.maxInstancedCount = glyphAtlasIndices.length;\n\n    // Update the boundingSphere based on the total bounds\n    var sphere = this.boundingSphere;\n    sphere.center.set(\n      (totalBounds[0] + totalBounds[2]) / 2,\n      (totalBounds[1] + totalBounds[3]) / 2,\n      0\n    );\n    sphere.radius = sphere.center.distanceTo(tempVec3.set(totalBounds[0], totalBounds[1], 0));\n  };\n\n  return GlyphsGeometry;\n}(three__WEBPACK_IMPORTED_MODULE_0__[\"InstancedBufferGeometry\"]));\n\n// Compat for pre r109:\nif (!GlyphsGeometry.prototype.setAttribute) {\n  GlyphsGeometry.prototype.setAttribute = function(name, attribute) {\n    this.attributes[ name ] = attribute;\n    return this\n  };\n}\n\n\nfunction updateBufferAttr(geom, attrName, newArray, itemSize) {\n  var attr = geom.getAttribute(attrName);\n  // If length isn't changing, just update the attribute's array data\n  if (attr && attr.array.length === newArray.length) {\n    attr.array.set(newArray);\n    attr.needsUpdate = true;\n  } else {\n    geom.setAttribute(attrName, new three__WEBPACK_IMPORTED_MODULE_0__[\"InstancedBufferAttribute\"](newArray, itemSize));\n  }\n}\n\n// language=GLSL\nvar VERTEX_DEFS = \"\\nuniform vec2 uTroikaSDFTextureSize;\\nuniform float uTroikaSDFGlyphSize;\\nuniform vec4 uTroikaTotalBounds;\\nattribute vec4 aTroikaGlyphBounds;\\nattribute float aTroikaGlyphIndex;\\nvarying vec2 vTroikaSDFTextureUV;\\nvarying vec2 vTroikaGlyphUV;\\nvarying vec3 vTroikaLocalPos;\\n\";\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nvar VERTEX_TRANSFORM = \"\\nvTroikaGlyphUV = vec2(position);\\n\\nvec2 colsAndRows = uTroikaSDFTextureSize / uTroikaSDFGlyphSize;\\nvTroikaSDFTextureUV = vec2(\\n  mod(aTroikaGlyphIndex, colsAndRows.x) + position.x,\\n  floor(aTroikaGlyphIndex / colsAndRows.x) + position.y\\n) * uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\\n\\nposition = vec3(\\n  mix(aTroikaGlyphBounds.x, aTroikaGlyphBounds.z, position.x),\\n  mix(aTroikaGlyphBounds.y, aTroikaGlyphBounds.w, position.y),\\n  position.z\\n);\\nvTroikaLocalPos = vec3(position);\\n\\nuv = vec2(\\n  (position.x - uTroikaTotalBounds.x) / (uTroikaTotalBounds.z - uTroikaTotalBounds.x),\\n  (position.y - uTroikaTotalBounds.y) / (uTroikaTotalBounds.w - uTroikaTotalBounds.y)\\n);\\n\";\n\n// language=GLSL\nvar FRAGMENT_DEFS = \"\\nuniform sampler2D uTroikaSDFTexture;\\nuniform float uTroikaSDFMinDistancePct;\\nuniform bool uTroikaSDFDebug;\\nuniform vec4 uTroikaClipRect;\\nvarying vec2 vTroikaSDFTextureUV;\\nvarying vec2 vTroikaGlyphUV;\\nvarying vec3 vTroikaLocalPos;\\n\\nfloat troikaGetClipAlpha() {\\n  vec4 clip = uTroikaClipRect;\\n  vec3 pos = vTroikaLocalPos;\\n  float dClip = min(\\n    min(pos.x - min(clip.x, clip.z), max(clip.x, clip.z) - pos.x),\\n    min(pos.y - min(clip.y, clip.w), max(clip.y, clip.w) - pos.y)\\n  );\\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\\n  float aa = length(fwidth(pos)) * 0.5;\\n  return smoothstep(-aa, aa, dClip);\\n  #else\\n  return step(0.0, dClip);\\n  #endif\\n}\\n\\nfloat troikaGetTextAlpha() {\\n  float troikaSDFValue = texture2D(uTroikaSDFTexture, vTroikaSDFTextureUV).r;\\n  \\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\\n  float alpha = step(0.5, troikaSDFValue);\\n  #else\\n  \" + ('') + \"\\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\\n  float aaDist = min(\\n    0.5,\\n    0.5 * min(\\n      fwidth(vTroikaGlyphUV.x),\\n      fwidth(vTroikaGlyphUV.y)\\n    )\\n  ) / uTroikaSDFMinDistancePct;\\n  #else\\n  float aaDist = 0.01;\\n  #endif\\n  \\n  float alpha = uTroikaSDFDebug ? troikaSDFValue : smoothstep(\\n    0.5 - aaDist,\\n    0.5 + aaDist,\\n    troikaSDFValue\\n  );\\n  #endif\\n  \\n  return min(alpha, troikaGetClipAlpha());\\n}\\n\";\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nvar FRAGMENT_TRANSFORM = \"\\nfloat troikaAlphaMult = troikaGetTextAlpha();\\nif (troikaAlphaMult == 0.0) {\\n  discard;\\n} else {\\n  gl_FragColor.a *= troikaAlphaMult;\\n}\\n\";\n\n\n/**\n * Create a material for rendering text, derived from a baseMaterial\n */\nfunction createTextDerivedMaterial(baseMaterial) {\n  var textMaterial = Object(troika_three_utils__WEBPACK_IMPORTED_MODULE_2__[\"createDerivedMaterial\"])(baseMaterial, {\n    extensions: {derivatives: true},\n    uniforms: {\n      uTroikaSDFTexture: {value: null},\n      uTroikaSDFTextureSize: {value: new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]()},\n      uTroikaSDFGlyphSize: {value: 0},\n      uTroikaSDFMinDistancePct: {value: 0},\n      uTroikaTotalBounds: {value: new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector4\"]()},\n      uTroikaClipRect: {value: new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector4\"]()},\n      uTroikaSDFDebug: {value: false}\n    },\n    vertexDefs: VERTEX_DEFS,\n    vertexTransform: VERTEX_TRANSFORM,\n    fragmentDefs: FRAGMENT_DEFS,\n    fragmentColorTransform: FRAGMENT_TRANSFORM\n  });\n\n  // Force transparency - TODO is this reasonable?\n  textMaterial.transparent = true;\n\n  // WebGLShadowMap reverses the side of the shadow material by default, which fails\n  // for planes, so here we force the `shadowSide` to always match the main side.\n  Object.defineProperty(textMaterial, 'shadowSide', {\n    get: function get() {\n      return this.side\n    }\n  });\n\n  return textMaterial\n}\n\nvar defaultMaterial = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\n  color: 0xffffff,\n  side: three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"],\n  transparent: true\n});\n\nvar tempMat4 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]();\n\nvar raycastMesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](\n  new three__WEBPACK_IMPORTED_MODULE_0__[\"PlaneBufferGeometry\"](1, 1).translate(0.5, 0.5, 0),\n  defaultMaterial\n);\n\n\n\n/**\n * @class TextMesh\n *\n * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n * fields (SDF).\n */\nvar TextMesh = /*@__PURE__*/(function (Mesh) {\n  function TextMesh(material) {\n    var geometry = new GlyphsGeometry();\n    Mesh.call(this, geometry, null);\n\n    // === Text layout properties: === //\n\n    /**\n     * @member {string} text\n     * The string of text to be rendered.\n     */\n    this.text = '';\n\n    /**\n     * @member {Array<number>} anchor\n     * Defines where in the text block should correspond to the mesh's local position, as a set\n     * of horizontal and vertical percentages from 0 to 1. A value of `[0, 0]` (the default)\n     * anchors at the top-left, `[1, 1]` at the bottom-right, and `[0.5, 0.5]` centers the\n     * block at the mesh's position.\n     */\n    this.anchor = null;\n\n    /**\n     * @member {string} font\n     * URL of a custom font to be used. Font files can be any of the formats supported by\n     * OpenType (see https://github.com/opentypejs/opentype.js).\n     * Defaults to the Roboto font loaded from Google Fonts.\n     */\n    this.font = null; //will use default from TextBuilder\n\n    /**\n     * @member {number} fontSize\n     * The size at which to render the font in local units; corresponds to the em-box height\n     * of the chosen `font`.\n     */\n    this.fontSize = 0.1;\n\n    /**\n     * @member {number} letterSpacing\n     * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n     * numbers increase spacing and negative numbers decrease it.\n     */\n    this.letterSpacing = 0;\n\n    /**\n     * @member {number|string} lineHeight\n     * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n     * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n     */\n    this.lineHeight = 'normal';\n\n    /**\n     * @member {number} maxWidth\n     * The maximum width of the text block, above which text may start wrapping according to the\n     * `whiteSpace` and `overflowWrap` properties.\n     */\n    this.maxWidth = Infinity;\n\n    /**\n     * @member {string} overflowWrap\n     * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n     * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n     * Defaults to `'normal'`.\n     */\n    this.overflowWrap = 'normal';\n\n    /**\n     * @member {string} textAlign\n     * The horizontal alignment of each line of text within the overall text bounding box.\n     */\n    this.textAlign = 'left';\n\n    /**\n     * @member {string} whiteSpace\n     * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n     * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n     * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n     * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n     */\n    this.whiteSpace = 'normal';\n\n\n    // === Presentation properties: === //\n\n    /**\n     * @member {THREE.Material} material\n     * Defines a _base_ material to be used when rendering the text. This material will be\n     * automatically replaced with a material derived from it, that adds shader code to\n     * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n     * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n     * of the other mesh materials to gain other features like lighting, texture maps, etc.\n     *\n     * Also see the `color` shortcut property.\n     */\n    this.material = null;\n\n    /**\n     * @member {string|number|THREE.Color} color\n     * This is a shortcut for setting the `color` of the text's material. You can use this\n     * if you don't want to specify a whole custom `material`.\n     */\n    this.color = null;\n\n    /**\n     * @member {number} depthOffset\n     * This is a shortcut for setting the material's `polygonOffset` and related properties,\n     * which can be useful in preventing z-fighting when this text is laid on top of another\n     * plane in the scene. Positive numbers are further from the camera, negatives closer.\n     */\n    this.depthOffset = 0;\n\n    /**\n     * @member {Array<number>} clipRect\n     * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n     * pixels will be discarded. This can be used for example to clip overflowing text when\n     * `whiteSpace='nowrap'`.\n     */\n    this.clipRect = null;\n\n    this.debugSDF = false;\n  }\n\n  if ( Mesh ) TextMesh.__proto__ = Mesh;\n  TextMesh.prototype = Object.create( Mesh && Mesh.prototype );\n  TextMesh.prototype.constructor = TextMesh;\n\n  var prototypeAccessors = { textRenderInfo: { configurable: true },material: { configurable: true },customDepthMaterial: { configurable: true },customDistanceMaterial: { configurable: true } };\n\n  /**\n   * Updates the text rendering according to the current text-related configuration properties.\n   * This is an async process, so you can pass in a callback function to be executed when it\n   * finishes.\n   * @param {function} [callback]\n   */\n  TextMesh.prototype.sync = function sync (callback) {\n    var this$1 = this;\n\n    if (this._needsSync) {\n      this._needsSync = false;\n\n      // If there's another sync still in progress, queue\n      if (this._isSyncing) {\n        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n      } else {\n        this._isSyncing = true;\n\n        getTextRenderInfo({\n          text: this.text,\n          font: this.font,\n          fontSize: this.fontSize,\n          letterSpacing: this.letterSpacing,\n          lineHeight: this.lineHeight,\n          maxWidth: this.maxWidth,\n          textAlign: this.textAlign,\n          whiteSpace: this.whiteSpace,\n          overflowWrap: this.overflowWrap,\n          anchor: this.anchor,\n          includeCaretPositions: true //TODO parameterize\n        }, function (textRenderInfo) {\n          this$1._isSyncing = false;\n\n          // Save result for later use in onBeforeRender\n          this$1._textRenderInfo = textRenderInfo;\n\n          // Update the geometry attributes\n          this$1.geometry.updateGlyphs(textRenderInfo.glyphBounds, textRenderInfo.glyphAtlasIndices, textRenderInfo.totalBounds);\n\n          // If we had extra sync requests queued up, kick it off\n          var queued = this$1._queuedSyncs;\n          if (queued) {\n            this$1._queuedSyncs = null;\n            this$1._needsSync = true;\n            this$1.sync(function () {\n              queued.forEach(function (fn) { return fn && fn(); });\n            });\n          }\n\n          if (callback) {\n            callback();\n          }\n        });\n      }\n    }\n  };\n\n  /**\n   * Initiate a sync if needed - note it won't complete until next frame at the\n   * earliest so if possible it's a good idea to call sync() manually as soon as\n   * all the properties have been set.\n   * @override\n   */\n  TextMesh.prototype.onBeforeRender = function onBeforeRender () {\n    this.sync();\n    this._prepareMaterial();\n  };\n\n  /**\n   * Shortcut to dispose the geometry specific to this instance.\n   * Note: we don't also dispose the derived material here because if anything else is\n   * sharing the same base material it will result in a pause next frame as the program\n   * is recompiled. Instead users can dispose the base material manually, like normal,\n   * and we'll also dispose the derived material at that time.\n   */\n  TextMesh.prototype.dispose = function dispose () {\n    this.geometry.dispose();\n  };\n\n  /**\n   * @property {TroikaTextRenderInfo|null} textRenderInfo\n   * @readonly\n   * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n   * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n   * the asynchrous `sync()` process completes.\n   */\n  prototypeAccessors.textRenderInfo.get = function () {\n    return this._textRenderInfo || null\n  };\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  prototypeAccessors.material.get = function () {\n    var derivedMaterial = this._derivedMaterial;\n    var baseMaterial = this._baseMaterial || defaultMaterial;\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      if (derivedMaterial) {\n        derivedMaterial.dispose();\n      }\n      derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    return derivedMaterial\n  };\n  prototypeAccessors.material.set = function (baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  };\n\n  // Create and update material for shadows upon request:\n  prototypeAccessors.customDepthMaterial.get = function () {\n    return this._updateLayoutUniforms(this.material.getDepthMaterial())\n  };\n  prototypeAccessors.customDistanceMaterial.get = function () {\n    return this._updateLayoutUniforms(this.material.getDistanceMaterial())\n  };\n\n  TextMesh.prototype._prepareMaterial = function _prepareMaterial () {\n    var material = this._derivedMaterial;\n    this._updateLayoutUniforms(material);\n\n    // presentation uniforms:\n    var uniforms = material.uniforms;\n    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n    material.polygonOffset = !!this.depthOffset;\n    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n\n    // shortcut for setting material color via facade prop:\n    var color = this.color;\n    if (color != null && material.color && material.color.isColor && color !== material._troikaColor) {\n      material.color.set(material._troikaColor = color);\n    }\n  };\n\n  TextMesh.prototype._updateLayoutUniforms = function _updateLayoutUniforms (material) {\n    var textInfo = this.textRenderInfo;\n    var uniforms = material.uniforms;\n    if (textInfo) {\n      var sdfTexture = textInfo.sdfTexture;\n      var totalBounds = textInfo.totalBounds;\n      uniforms.uTroikaSDFTexture.value = sdfTexture;\n      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n      uniforms.uTroikaSDFMinDistancePct.value = textInfo.sdfMinDistancePercent;\n      uniforms.uTroikaTotalBounds.value.fromArray(totalBounds);\n\n      var clipRect = this.clipRect;\n      if (!(clipRect && Array.isArray(clipRect) && clipRect.length === 4)) {\n        uniforms.uTroikaClipRect.value.fromArray(totalBounds);\n      } else {\n        uniforms.uTroikaClipRect.value.set(\n          Math.max(totalBounds[0], clipRect[0]),\n          Math.max(totalBounds[1], clipRect[1]),\n          Math.min(totalBounds[2], clipRect[2]),\n          Math.min(totalBounds[3], clipRect[3])\n        );\n      }\n    }\n    return material\n  };\n\n  /**\n   * @override Custom raycasting to test against the whole text block's max rectangular bounds\n   * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n   */\n  TextMesh.prototype.raycast = function raycast (raycaster, intersects) {\n    var textInfo = this.textRenderInfo;\n    if (textInfo) {\n      var bounds = textInfo.totalBounds;\n      raycastMesh.matrixWorld.multiplyMatrices(\n        this.matrixWorld,\n        tempMat4.set(\n          bounds[2] - bounds[0], 0, 0, bounds[0],\n          0, bounds[3] - bounds[1], 0, bounds[1],\n          0, 0, 1, 0,\n          0, 0, 0, 1\n        )\n      );\n      raycastMesh.raycast(raycaster, intersects);\n    }\n  };\n\n  Object.defineProperties( TextMesh.prototype, prototypeAccessors );\n\n  return TextMesh;\n}(three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]));\n\n\n// Create setters for properties that affect text layout:\nvar SYNCABLE_PROPS = [\n  'font',\n  'fontSize',\n  'letterSpacing',\n  'lineHeight',\n  'maxWidth',\n  'overflowWrap',\n  'text',\n  'textAlign',\n  'whiteSpace',\n  'anchor'\n];\nSYNCABLE_PROPS.forEach(function (prop) {\n  var privateKey = '_private_' + prop;\n  Object.defineProperty(TextMesh.prototype, prop, {\n    get: function() {\n      return this[privateKey]\n    },\n    set: prop === 'anchor'\n      ? function(value) {\n        if (JSON.stringify(value) !== JSON.stringify(this[privateKey])) {\n          this[privateKey] = value;\n          this._needsSync = true;\n        }\n      }\n      : function(value) {\n        if (value !== this[privateKey]) {\n          this[privateKey] = value;\n          this._needsSync = true;\n        }\n      }\n  });\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHJvaWthLTNkLXRleHQvZGlzdC90ZXh0bWVzaC1zdGFuZGFsb25lLmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90cm9pa2EtM2QtdGV4dC9kaXN0L3RleHRtZXNoLXN0YW5kYWxvbmUuZXNtLmpzPzJiNzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0YVRleHR1cmUsIEx1bWluYW5jZUZvcm1hdCwgTGluZWFyRmlsdGVyLCBQbGFuZUJ1ZmZlckdlb21ldHJ5LCBWZWN0b3IzLCBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSwgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLCBTcGhlcmUsIFZlY3RvcjIsIFZlY3RvcjQsIE1lc2hCYXNpY01hdGVyaWFsLCBEb3VibGVTaWRlLCBNYXRyaXg0LCBNZXNoIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgZGVmaW5lV29ya2VyTW9kdWxlLCBUaGVuYWJsZVdvcmtlck1vZHVsZSB9IGZyb20gJ3Ryb2lrYS13b3JrZXItdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlRGVyaXZlZE1hdGVyaWFsIH0gZnJvbSAndHJvaWthLXRocmVlLXV0aWxzJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGFuIFNERiB0ZXh0dXJlIGZvciBhIGdpdmVuIGdseXBoLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5zZGZUZXh0dXJlU2l6ZSAtIHRoZSBsZW5ndGggb2Ygb25lIHNpZGUgb2YgdGhlIHJlc3VsdGluZyB0ZXh0dXJlIGltYWdlLlxuICogICAgICAgICAgICAgICAgIExhcmdlciBpbWFnZXMgZW5jb2RlIG1vcmUgZGV0YWlscy4gU2hvdWxkIGJlIGEgcG93ZXIgb2YgMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcuc2RmRGlzdGFuY2VQZXJjZW50IC0gc2VlIGRvY3MgZm9yIFNERl9ESVNUQU5DRV9QRVJDRU5UIGluIFRleHRCdWlsZGVyLmpzXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb24oT2JqZWN0KToge3JlbmRlcmluZ0JvdW5kczogW21pblgsIG1pblksIG1heFgsIG1heFldLCB0ZXh0dXJlRGF0YTogVWludDhBcnJheX19XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNERkdlbmVyYXRvcihjb25maWcpIHtcbiAgdmFyIHNkZlRleHR1cmVTaXplID0gY29uZmlnLnNkZlRleHR1cmVTaXplO1xuICB2YXIgc2RmRGlzdGFuY2VQZXJjZW50ID0gY29uZmlnLnNkZkRpc3RhbmNlUGVyY2VudDtcblxuICAvKipcbiAgICogSG93IG1hbnkgc3RyYWlnaHQgbGluZSBzZWdtZW50cyB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIGEgZ2x5cGgncyBxdWFkcmF0aWMvY3ViaWMgYmV6aWVyIGN1cnZlcy5cbiAgICovXG4gIHZhciBDVVJWRV9QT0lOVFMgPSAxNjtcblxuICB2YXIgSU5GID0gSW5maW5pdHk7XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHBvaW50IG9uIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBhdCB0IHdoZXJlIHQgaXMgaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgKi9cbiAgZnVuY3Rpb24gcG9pbnRPblF1YWRyYXRpY0Jlemllcih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB0KSB7XG4gICAgdmFyIHQyID0gMSAtIHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHQyICogdDIgKiB4MCArIDIgKiB0MiAqIHQgKiB4MSArIHQgKiB0ICogeDIsXG4gICAgICB5OiB0MiAqIHQyICogeTAgKyAyICogdDIgKiB0ICogeTEgKyB0ICogdCAqIHkyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHBvaW50IG9uIGEgY3ViaWMgYmV6aWVyIGN1cnZlIGF0IHQgd2hlcmUgdCBpcyBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAqL1xuICBmdW5jdGlvbiBwb2ludE9uQ3ViaWNCZXppZXIoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0KSB7XG4gICAgdmFyIHQyID0gMSAtIHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHQyICogdDIgKiB0MiAqIHgwICsgMyAqIHQyICogdDIgKiB0ICogeDEgKyAzICogdDIgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDMsXG4gICAgICB5OiB0MiAqIHQyICogdDIgKiB5MCArIDMgKiB0MiAqIHQyICogdCAqIHkxICsgMyAqIHQyICogdCAqIHQgKiB5MiArIHQgKiB0ICogdCAqIHkzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFlvdSdyZSBzdWNoIGEgc3F1YXJlLlxuICAgKi9cbiAgZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICByZXR1cm4gbiAqIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBsaW5lIHNlZ21lbnQgYXQgY2xvc2VzdCBhcHByb2FjaFxuICAgKi9cbiAgZnVuY3Rpb24gYWJzRGlzdGFuY2VUb0xpbmVTZWdtZW50KHgsIHksIGxpbmVYMCwgbGluZVkwLCBsaW5lWDEsIGxpbmVZMSkge1xuICAgIHZhciBsZHggPSBsaW5lWDEgLSBsaW5lWDA7XG4gICAgdmFyIGxkeSA9IGxpbmVZMSAtIGxpbmVZMDtcbiAgICB2YXIgbGVuZ3RoU3EgPSBzcXVhcmUobGR4KSArIHNxdWFyZShsZHkpO1xuICAgIHZhciB0ID0gbGVuZ3RoU3EgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoKHggLSBsaW5lWDApICogbGR4ICsgKHkgLSBsaW5lWTApICogbGR5KSAvIGxlbmd0aFNxKSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlKHggLSAobGluZVgwICsgdCAqIGxkeCkpICsgc3F1YXJlKHkgLSAobGluZVkwICsgdCAqIGxkeSkpKVxuICB9XG5cblxuICAvKipcbiAgICogQmFzaWMgcXVhZHRyZWUgaW1wbCBmb3IgcGVyZm9ybWluZyBmYXN0IHNwYXRpYWwgc2VhcmNoZXMgb2YgYSBnbHlwaCdzIGxpbmUgc2VnbWVudHNcbiAgICovXG4gIHZhciBHbHlwaFNlZ21lbnRzUXVhZHRyZWUgPSBmdW5jdGlvbiBHbHlwaFNlZ21lbnRzUXVhZHRyZWUoZ2x5cGhPYmopIHtcbiAgICAvLyBQaWNrIGEgZ29vZCBpbml0aWFsIHBvd2VyLW9mLXR3byBib3VuZGluZyBib3ggdGhhdCB3aWxsIGhvbGQgYWxsIHBvc3NpYmxlIHNlZ21lbnRzXG4gICAgdmFyIHhNaW4gPSBnbHlwaE9iai54TWluO1xuICAgIHZhciB5TWluID0gZ2x5cGhPYmoueU1pbjtcbiAgICB2YXIgeE1heCA9IGdseXBoT2JqLnhNYXg7XG4gICAgdmFyIHlNYXggPSBnbHlwaE9iai55TWF4O1xuICAgIHZhciBkeCA9IHhNYXggLSB4TWluO1xuICAgIHZhciBkeSA9IHlNYXggLSB5TWluO1xuICAgIHZhciBjeCA9IE1hdGgucm91bmQoeE1pbiArIGR4IC8gMik7XG4gICAgdmFyIGN5ID0gTWF0aC5yb3VuZCh5TWluICsgZHkgLyAyKTtcbiAgICB2YXIgciA9IE1hdGgucG93KDIsIE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5tYXgoZHgsIGR5KSkgKiBNYXRoLkxPRzJFKSk7XG5cbiAgICB0aGlzLl9yb290ID0ge1xuICAgICAgMDogbnVsbCxcbiAgICAgIDE6IG51bGwsXG4gICAgICAyOiBudWxsLFxuICAgICAgMzogbnVsbCxcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICBjeDogY3gsXG4gICAgICBjeTogY3ksXG4gICAgICByOiByLFxuICAgICAgbWluWDogSU5GLFxuICAgICAgbWluWTogSU5GLFxuICAgICAgbWF4WDogLUlORixcbiAgICAgIG1heFk6IC1JTkZcbiAgICB9O1xuICB9O1xuXG4gIEdseXBoU2VnbWVudHNRdWFkdHJlZS5wcm90b3R5cGUuYWRkTGluZVNlZ21lbnQgPSBmdW5jdGlvbiBhZGRMaW5lU2VnbWVudCAoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB2YXIgY3ggPSAoeDAgKyB4MSkgLyAyO1xuICAgIHZhciBjeSA9ICh5MCArIHkxKSAvIDI7XG4gICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICB4MDogeDAsIHkwOiB5MCwgeDE6IHgxLCB5MTogeTEsIGN4OiBjeCwgY3k6IGN5LFxuICAgICAgbWluWDogTWF0aC5taW4oeDAsIHgxKSxcbiAgICAgIG1pblk6IE1hdGgubWluKHkwLCB5MSksXG4gICAgICBtYXhYOiBNYXRoLm1heCh4MCwgeDEpLFxuICAgICAgbWF4WTogTWF0aC5tYXgoeTAsIHkxKSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuX2luc2VydFNlZ21lbnQoc2VnbWVudCwgdGhpcy5fcm9vdCk7XG4gIH07XG5cbiAgR2x5cGhTZWdtZW50c1F1YWR0cmVlLnByb3RvdHlwZS5faW5zZXJ0U2VnbWVudCA9IGZ1bmN0aW9uIF9pbnNlcnRTZWdtZW50IChzZWdtZW50LCBub2RlKSB7XG4gICAgLy8gdXBkYXRlIG5vZGUgbWluL21heCBzdGF0c1xuICAgIHZhciBtaW5YID0gc2VnbWVudC5taW5YO1xuICAgICAgdmFyIG1pblkgPSBzZWdtZW50Lm1pblk7XG4gICAgICB2YXIgbWF4WCA9IHNlZ21lbnQubWF4WDtcbiAgICAgIHZhciBtYXhZID0gc2VnbWVudC5tYXhZO1xuICAgICAgdmFyIGN4ID0gc2VnbWVudC5jeDtcbiAgICAgIHZhciBjeSA9IHNlZ21lbnQuY3k7XG4gICAgaWYgKG1pblggPCBub2RlLm1pblgpIHsgbm9kZS5taW5YID0gbWluWDsgfVxuICAgIGlmIChtaW5ZIDwgbm9kZS5taW5ZKSB7IG5vZGUubWluWSA9IG1pblk7IH1cbiAgICBpZiAobWF4WCA+IG5vZGUubWF4WCkgeyBub2RlLm1heFggPSBtYXhYOyB9XG4gICAgaWYgKG1heFkgPiBub2RlLm1heFkpIHsgbm9kZS5tYXhZID0gbWF4WTsgfVxuXG4gICAgLy8gbGVhZlxuICAgIHZhciBsZWFmU2VnbWVudCA9IG5vZGUuZGF0YTtcbiAgICBpZiAobGVhZlNlZ21lbnQpIHtcbiAgICAgIC8vIGNvaW5jaWRlbnQ7IHB1c2ggYXMgbGlua2VkIGxpc3RcbiAgICAgIGlmIChsZWFmU2VnbWVudC5jeCA9PT0gY3ggJiYgbGVhZlNlZ21lbnQuY3kgPT09IGN5KSB7XG4gICAgICAgIHdoaWxlIChsZWFmU2VnbWVudC5uZXh0KSB7IGxlYWZTZWdtZW50ID0gbGVhZlNlZ21lbnQubmV4dDsgfVxuICAgICAgICBsZWFmU2VnbWVudC5uZXh0ID0gc2VnbWVudDtcbiAgICAgIH1cbiAgICAgIC8vIG5vbi1jb2luY2lkZW50OyBzcGxpdCBsZWFmIHRvIGJyYW5jaFxuICAgICAgZWxzZSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luc2VydFNlZ21lbnQobGVhZlNlZ21lbnQsIG5vZGUpO1xuICAgICAgICB0aGlzLl9pbnNlcnRTZWdtZW50KHNlZ21lbnQsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBicmFuY2hcbiAgICBlbHNlIHtcbiAgICAgIC8vIGZpbmQgdGFyZ2V0IHN1Yi1pbmRleCBmb3IgdGhlIHNlZ21lbnQncyBjZW50ZXJwb2ludFxuICAgICAgdmFyIHN1YkluZGV4ID0gKGN5IDwgbm9kZS5jeSA/IDAgOiAyKSArIChjeCA8IG5vZGUuY3ggPyAwIDogMSk7XG5cbiAgICAgIC8vIHN1Ym5vZGUgYWxyZWFkeSBhdCBpbmRleDogcmVjdXJzZVxuICAgICAgaWYgKG5vZGVbc3ViSW5kZXhdKSB7XG4gICAgICAgIHRoaXMuX2luc2VydFNlZ21lbnQoc2VnbWVudCwgbm9kZVtzdWJJbmRleF0pO1xuICAgICAgfVxuICAgICAgLy8gY3JlYXRlIG5ldyBsZWFmXG4gICAgICBlbHNlIHtcbiAgICAgICAgbm9kZVtzdWJJbmRleF0gPSB7XG4gICAgICAgICAgMDogbnVsbCxcbiAgICAgICAgICAxOiBudWxsLFxuICAgICAgICAgIDI6IG51bGwsXG4gICAgICAgICAgMzogbnVsbCxcbiAgICAgICAgICBkYXRhOiBzZWdtZW50LFxuICAgICAgICAgIGN4OiBub2RlLmN4ICsgbm9kZS5yIC8gMiAqIChzdWJJbmRleCAlIDIgPyAxIDogLTEpLFxuICAgICAgICAgIGN5OiBub2RlLmN5ICsgbm9kZS5yIC8gMiAqIChzdWJJbmRleCA8IDIgPyAtMSA6IDEpLFxuICAgICAgICAgIHI6IG5vZGUuciAvIDIsXG4gICAgICAgICAgbWluWDogbWluWCxcbiAgICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICAgIG1heFg6IG1heFgsXG4gICAgICAgICAgbWF4WTogbWF4WVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBHbHlwaFNlZ21lbnRzUXVhZHRyZWUucHJvdG90eXBlLndhbGtUcmVlID0gZnVuY3Rpb24gd2Fsa1RyZWUgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy53YWxrQnJhbmNoKHRoaXMuX3Jvb3QsIGNhbGxiYWNrKTtcbiAgfTtcbiAgR2x5cGhTZWdtZW50c1F1YWR0cmVlLnByb3RvdHlwZS53YWxrQnJhbmNoID0gZnVuY3Rpb24gd2Fsa0JyYW5jaCAocm9vdCwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2socm9vdCkgIT09IGZhbHNlICYmICFyb290LmRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGlmIChyb290W2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy53YWxrQnJhbmNoKHJvb3RbaV0sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBHbHlwaFNlZ21lbnRzUXVhZHRyZWUucHJvdG90eXBlLmZpbmROZWFyZXN0U2lnbmVkRGlzdGFuY2UgPSBmdW5jdGlvbiBmaW5kTmVhcmVzdFNpZ25lZERpc3RhbmNlICh4LCB5LCBtYXhTZWFyY2hSYWRpdXMpIHtcbiAgICB2YXIgY2xvc2VzdERpc3QgPSBtYXhTZWFyY2hSYWRpdXM7XG5cbiAgICB0aGlzLndhbGtUcmVlKGZ1bmN0aW9uIHZpc2l0KG5vZGUpIHtcbiAgICAgIC8vIElnbm9yZSBub2RlcyB0aGF0IGNhbid0IHBvc3NpYmx5IGhhdmUgc2VnbWVudHMgY2xvc2VyIHRoYW4gd2hhdCB3ZSd2ZSBhbHJlYWR5IGZvdW5kLiBXZSBiYXNlXG4gICAgICAvLyB0aGlzIG9uIGEgc2ltcGxlIHJlY3QgYm91bmRzIGNoZWNrOyByYWRpYWwgd291bGQgYmUgbW9yZSBhY2N1cmF0ZSBidXQgbXVjaCBzbG93ZXIuXG4gICAgICBpZiAoXG4gICAgICAgIHggLSBjbG9zZXN0RGlzdCA+IG5vZGUubWF4WCB8fCB4ICsgY2xvc2VzdERpc3QgPCBub2RlLm1pblggfHxcbiAgICAgICAgeSAtIGNsb3Nlc3REaXN0ID4gbm9kZS5tYXhZIHx8IHkgKyBjbG9zZXN0RGlzdCA8IG5vZGUubWluWVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBMZWFmIC0gY2hlY2sgZWFjaCBzZWdtZW50J3MgYWN0dWFsIGRpc3RhbmNlXG4gICAgICBpZiAobm9kZS5kYXRhKSB7XG4gICAgICAgIGZvciAodmFyIHNlZ21lbnQgPSBub2RlLmRhdGE7IHNlZ21lbnQ7IHNlZ21lbnQgPSBzZWdtZW50Lm5leHQpIHtcbiAgICAgICAgICBpZiAoIC8vZmFzdCBwcmVmaWx0ZXIgZm9yIHNlZ21lbnQgdG8gYXZvaWQgZGlzdCBjYWxjXG4gICAgICAgICAgICB4IC0gY2xvc2VzdERpc3QgPCBzZWdtZW50Lm1heFggfHwgeCArIGNsb3Nlc3REaXN0ID4gc2VnbWVudC5taW5YIHx8XG4gICAgICAgICAgICB5IC0gY2xvc2VzdERpc3QgPCBzZWdtZW50Lm1heFkgfHwgeSArIGNsb3Nlc3REaXN0ID4gc2VnbWVudC5taW5ZXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IGFic0Rpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCBzZWdtZW50LngwLCBzZWdtZW50LnkwLCBzZWdtZW50LngxLCBzZWdtZW50LnkxKTtcbiAgICAgICAgICAgIGlmIChkaXN0IDwgY2xvc2VzdERpc3QpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRmxpcCB0byBuZWdhdGl2ZSBkaXN0YW5jZSBpZiBvdXRzaWRlIHRoZSBwb2x5XG4gICAgaWYgKCF0aGlzLmlzUG9pbnRJblBvbHkoeCwgeSkpIHtcbiAgICAgIGNsb3Nlc3REaXN0ID0gLWNsb3Nlc3REaXN0O1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdERpc3RcbiAgfTtcblxuICBHbHlwaFNlZ21lbnRzUXVhZHRyZWUucHJvdG90eXBlLmlzUG9pbnRJblBvbHkgPSBmdW5jdGlvbiBpc1BvaW50SW5Qb2x5ICh4LCB5KSB7XG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgIHRoaXMud2Fsa1RyZWUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIC8vIElnbm9yZSBub2RlcyB3aG9zZSBib3VuZHMgY2FuJ3QgcG9zc2libHkgY3Jvc3Mgb3VyIGVhc3QtcG9pbnRpbmcgcmF5XG4gICAgICBpZiAobm9kZS5tYXhYIDwgeCB8fCBub2RlLm1pblkgPiB5IHx8IG5vZGUubWF4WSA8IHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIExlYWYgLSB0ZXN0IGVhY2ggc2VnbWVudCBmb3Igd2hldGhlciBpdCBjcm9zc2VzIG91ciBlYXN0LXBvaW50aW5nIHJheVxuICAgICAgaWYgKG5vZGUuZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBzZWdtZW50ID0gbm9kZS5kYXRhOyBzZWdtZW50OyBzZWdtZW50ID0gc2VnbWVudC5uZXh0KSB7XG4gICAgICAgICAgdmFyIHgwID0gc2VnbWVudC54MDtcbiAgICAgICAgICAgIHZhciB5MCA9IHNlZ21lbnQueTA7XG4gICAgICAgICAgICB2YXIgeDEgPSBzZWdtZW50LngxO1xuICAgICAgICAgICAgdmFyIHkxID0gc2VnbWVudC55MTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0cyA9ICgoeTAgPiB5KSAhPT0gKHkxID4geSkpICYmICh4IDwgKHgxIC0geDApICogKHkgLSB5MCkgLyAoeTEgLSB5MCkgKyB4MCk7XG4gICAgICAgICAgaWYgKGludGVyc2VjdHMpIHtcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGluc2lkZVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBTREYgdGV4dHVyZSBzZWdtZW50IGZvciBhIHNpbmdsZSBnbHlwaC5cbiAgICogQHBhcmFtIHtvYmplY3R9IGdseXBoT2JqXG4gICAqIEByZXR1cm4ge3t0ZXh0dXJlRGF0YTogVWludDhBcnJheSwgcmVuZGVyaW5nQm91bmRzOiAqW119fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGVTREYoZ2x5cGhPYmopIHtcbiAgICAvL2NvbnNvbGUudGltZSgnZ2x5cGhTREYnKVxuXG4gICAgdmFyIHRleHR1cmVEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3F1YXJlKHNkZlRleHR1cmVTaXplKSk7XG5cbiAgICAvLyBEZXRlcm1pbmUgbWFwcGluZyBiZXR3ZWVuIGdseXBoIGdyaWQgY29vcmRzIGFuZCBzZGYgZ3JpZCBjb29yZHNcbiAgICB2YXIgZ2x5cGhXID0gZ2x5cGhPYmoueE1heCAtIGdseXBoT2JqLnhNaW47XG4gICAgdmFyIGdseXBoSCA9IGdseXBoT2JqLnlNYXggLSBnbHlwaE9iai55TWluO1xuXG4gICAgLy8gQ2hvb3NlIGEgbWF4aW11bSBkaXN0YW5jZSByYWRpdXMgaW4gZm9udCB1bml0cywgYmFzZWQgb24gdGhlIGdseXBoJ3MgbWF4IGRpbWVuc2lvbnNcbiAgICB2YXIgZm9udFVuaXRzTWF4RGlzdCA9IE1hdGgubWF4KGdseXBoVywgZ2x5cGhIKSAqIHNkZkRpc3RhbmNlUGVyY2VudDtcblxuICAgIC8vIFVzZSB0aGF0LCBleHRlbmRpbmcgdG8gdGhlIHRleHR1cmUgZWRnZXMsIHRvIGZpbmQgY29udmVyc2lvbiByYXRpb3MgYmV0d2VlbiB0ZXh0dXJlIHVuaXRzIGFuZCBmb250IHVuaXRzXG4gICAgdmFyIGZvbnRVbml0c1BlclhUZXhlbCA9IChnbHlwaFcgKyBmb250VW5pdHNNYXhEaXN0ICogMikgLyBzZGZUZXh0dXJlU2l6ZTtcbiAgICB2YXIgZm9udFVuaXRzUGVyWVRleGVsID0gKGdseXBoSCArIGZvbnRVbml0c01heERpc3QgKiAyKSAvIHNkZlRleHR1cmVTaXplO1xuXG4gICAgdmFyIHRleHR1cmVNaW5Gb250WCA9IGdseXBoT2JqLnhNaW4gLSBmb250VW5pdHNNYXhEaXN0IC0gZm9udFVuaXRzUGVyWFRleGVsO1xuICAgIHZhciB0ZXh0dXJlTWluRm9udFkgPSBnbHlwaE9iai55TWluIC0gZm9udFVuaXRzTWF4RGlzdCAtIGZvbnRVbml0c1BlcllUZXhlbDtcbiAgICB2YXIgdGV4dHVyZU1heEZvbnRYID0gZ2x5cGhPYmoueE1heCArIGZvbnRVbml0c01heERpc3QgKyBmb250VW5pdHNQZXJYVGV4ZWw7XG4gICAgdmFyIHRleHR1cmVNYXhGb250WSA9IGdseXBoT2JqLnlNYXggKyBmb250VW5pdHNNYXhEaXN0ICsgZm9udFVuaXRzUGVyWVRleGVsO1xuXG4gICAgZnVuY3Rpb24gdGV4dHVyZVhUb0ZvbnRYKHgpIHtcbiAgICAgIHJldHVybiB0ZXh0dXJlTWluRm9udFggKyAodGV4dHVyZU1heEZvbnRYIC0gdGV4dHVyZU1pbkZvbnRYKSAqIHggLyBzZGZUZXh0dXJlU2l6ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRleHR1cmVZVG9Gb250WSh5KSB7XG4gICAgICByZXR1cm4gdGV4dHVyZU1pbkZvbnRZICsgKHRleHR1cmVNYXhGb250WSAtIHRleHR1cmVNaW5Gb250WSkgKiB5IC8gc2RmVGV4dHVyZVNpemVcbiAgICB9XG5cbiAgICBpZiAoZ2x5cGhPYmoucGF0aENvbW1hbmRDb3VudCkgeyAvL3doaXRlc3BhY2UgY2hhcnMgd2lsbCBoYXZlIG5vIGNvbW1hbmRzLCBzbyB3ZSBjYW4gc2tpcCBhbGwgdGhpc1xuICAgICAgLy8gRGVjb21wb3NlIGFsbCBwYXRocyBpbnRvIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHMgYW5kIGFkZCB0aGVtIHRvIGEgcXVhZHRyZWVcbiAgICAgIHZhciBsaW5lU2VnbWVudHNJbmRleCA9IG5ldyBHbHlwaFNlZ21lbnRzUXVhZHRyZWUoZ2x5cGhPYmopO1xuICAgICAgdmFyIGZpcnN0WCwgZmlyc3RZLCBwcmV2WCwgcHJldlk7XG4gICAgICBnbHlwaE9iai5mb3JFYWNoUGF0aENvbW1hbmQoZnVuY3Rpb24gKHR5cGUsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICBwcmV2WCA9IGZpcnN0WCA9IHgwO1xuICAgICAgICAgICAgcHJldlkgPSBmaXJzdFkgPSB5MDtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICBpZiAoeDAgIT09IHByZXZYIHx8IHkwICE9PSBwcmV2WSkgeyAvL3l1cCwgc29tZSBmb250cyBoYXZlIHplcm8tbGVuZ3RoIGxpbmUgY29tbWFuZHNcbiAgICAgICAgICAgICAgbGluZVNlZ21lbnRzSW5kZXguYWRkTGluZVNlZ21lbnQocHJldlgsIHByZXZZLCAocHJldlggPSB4MCksIChwcmV2WSA9IHkwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ1EnOiB7XG4gICAgICAgICAgICB2YXIgcHJldlBvaW50ID0ge3g6IHByZXZYLCB5OiBwcmV2WX07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IENVUlZFX1BPSU5UUzsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBuZXh0UG9pbnQgPSBwb2ludE9uUXVhZHJhdGljQmV6aWVyKFxuICAgICAgICAgICAgICAgIHByZXZYLCBwcmV2WSxcbiAgICAgICAgICAgICAgICB4MCwgeTAsXG4gICAgICAgICAgICAgICAgeDEsIHkxLFxuICAgICAgICAgICAgICAgIGkgLyAoQ1VSVkVfUE9JTlRTIC0gMSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbGluZVNlZ21lbnRzSW5kZXguYWRkTGluZVNlZ21lbnQocHJldlBvaW50LngsIHByZXZQb2ludC55LCBuZXh0UG9pbnQueCwgbmV4dFBvaW50LnkpO1xuICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2WCA9IHgxO1xuICAgICAgICAgICAgcHJldlkgPSB5MTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0MnOiB7XG4gICAgICAgICAgICB2YXIgcHJldlBvaW50JDEgPSB7eDogcHJldlgsIHk6IHByZXZZfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IENVUlZFX1BPSU5UUzsgaSQxKyspIHtcbiAgICAgICAgICAgICAgdmFyIG5leHRQb2ludCQxID0gcG9pbnRPbkN1YmljQmV6aWVyKFxuICAgICAgICAgICAgICAgIHByZXZYLCBwcmV2WSxcbiAgICAgICAgICAgICAgICB4MCwgeTAsXG4gICAgICAgICAgICAgICAgeDEsIHkxLFxuICAgICAgICAgICAgICAgIHgyLCB5MixcbiAgICAgICAgICAgICAgICBpJDEgLyAoQ1VSVkVfUE9JTlRTIC0gMSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbGluZVNlZ21lbnRzSW5kZXguYWRkTGluZVNlZ21lbnQocHJldlBvaW50JDEueCwgcHJldlBvaW50JDEueSwgbmV4dFBvaW50JDEueCwgbmV4dFBvaW50JDEueSk7XG4gICAgICAgICAgICAgIHByZXZQb2ludCQxID0gbmV4dFBvaW50JDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2WCA9IHgyO1xuICAgICAgICAgICAgcHJldlkgPSB5MjtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgaWYgKHByZXZYICE9PSBmaXJzdFggfHwgcHJldlkgIT09IGZpcnN0WSkge1xuICAgICAgICAgICAgICBsaW5lU2VnbWVudHNJbmRleC5hZGRMaW5lU2VnbWVudChwcmV2WCwgcHJldlksIGZpcnN0WCwgZmlyc3RZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBGb3IgZWFjaCB0YXJnZXQgU0RGIHRleGVsLCBmaW5kIHRoZSBkaXN0YW5jZSBmcm9tIGl0cyBjZW50ZXIgdG8gaXRzIG5lYXJlc3QgbGluZSBzZWdtZW50LFxuICAgICAgLy8gbWFwIHRoYXQgZGlzdGFuY2UgdG8gYW4gYWxwaGEgdmFsdWUsIGFuZCB3cml0ZSB0aGF0IGFscGhhIHRvIHRoZSB0ZXhlbFxuICAgICAgZm9yICh2YXIgc2RmWCA9IDA7IHNkZlggPCBzZGZUZXh0dXJlU2l6ZTsgc2RmWCsrKSB7XG4gICAgICAgIGZvciAodmFyIHNkZlkgPSAwOyBzZGZZIDwgc2RmVGV4dHVyZVNpemU7IHNkZlkrKykge1xuICAgICAgICAgIHZhciBzaWduZWREaXN0ID0gbGluZVNlZ21lbnRzSW5kZXguZmluZE5lYXJlc3RTaWduZWREaXN0YW5jZShcbiAgICAgICAgICAgIHRleHR1cmVYVG9Gb250WChzZGZYICsgMC41KSxcbiAgICAgICAgICAgIHRleHR1cmVZVG9Gb250WShzZGZZICsgMC41KSxcbiAgICAgICAgICAgIGZvbnRVbml0c01heERpc3RcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vaWYgKCFpc0Zpbml0ZShzaWduZWREaXN0KSkgdGhyb3cgJ2luZmluaXRlIGRpc3RhbmNlISdcbiAgICAgICAgICB2YXIgYWxwaGEgPSBpc0Zpbml0ZShzaWduZWREaXN0KSA/IE1hdGgucm91bmQoMjU1ICogKDEgKyBzaWduZWREaXN0IC8gZm9udFVuaXRzTWF4RGlzdCkgKiAwLjUpIDogc2lnbmVkRGlzdDtcbiAgICAgICAgICBhbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgYWxwaGEpKTsgLy9jbGFtcFxuICAgICAgICAgIHRleHR1cmVEYXRhW3NkZlkgKiBzZGZUZXh0dXJlU2l6ZSArIHNkZlhdID0gYWxwaGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL2NvbnNvbGUudGltZUVuZCgnZ2x5cGhTREYnKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHR1cmVEYXRhOiB0ZXh0dXJlRGF0YSxcblxuICAgICAgcmVuZGVyaW5nQm91bmRzOiBbXG4gICAgICAgIHRleHR1cmVNaW5Gb250WCxcbiAgICAgICAgdGV4dHVyZU1pbkZvbnRZLFxuICAgICAgICB0ZXh0dXJlTWF4Rm9udFgsXG4gICAgICAgIHRleHR1cmVNYXhGb250WVxuICAgICAgXVxuICAgIH1cbiAgfVxuXG5cbiAgcmV0dXJuIGdlbmVyYXRlU0RGXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlbGYtY29udGFpbmVkIGVudmlyb25tZW50IGZvciBwcm9jZXNzaW5nIHRleHQgcmVuZGVyaW5nIHJlcXVlc3RzLlxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0aGF0IHRoaXMgZnVuY3Rpb24gaGFzIG5vIGV4dGVybmFsIGRlcGVuZGVuY2llcywgc28gdGhhdCBpdCBjYW4gYmUgZWFzaWx5IGluamVjdGVkXG4gKiBpbnRvIHRoZSBzb3VyY2UgZm9yIGEgV29ya2VyIHdpdGhvdXQgcmVxdWlyaW5nIGEgYnVpbGQgc3RlcCBvciBjb21wbGV4IGRlcGVuZGVuY3kgbG9hZGluZy4gSXRzIHNvbGVcbiAqIGRlcGVuZGVuY3ksIGEgYGZvbnRQYXJzZXJgIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uLCBtdXN0IGJlIHBhc3NlZCBpbiBhdCBpbml0aWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmb250UGFyc2VyIC0gYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYW4gQXJyYXlCdWZmZXIgb2YgdGhlIGZvbnQgZGF0YSBhbmQgcmV0dXJuc1xuICogYSBzdGFuZGFyZGl6ZWQgc3RydWN0dXJlIGdpdmluZyBhY2Nlc3MgdG8gdGhlIGZvbnQgYW5kIGl0cyBnbHlwaHM6XG4gKiAgIHtcbiAqICAgICB1bml0c1BlckVtOiBudW1iZXIsXG4gKiAgICAgYXNjZW5kZXI6IG51bWJlcixcbiAqICAgICBkZXNjZW5kZXI6IG51bWJlcixcbiAqICAgICBmb3JFYWNoR2x5cGgoc3RyaW5nLCBmb250U2l6ZSwgbGV0dGVyU3BhY2luZywgY2FsbGJhY2spIHtcbiAqICAgICAgIC8vaW52b2tlcyBjYWxsYmFjayBmb3IgZWFjaCBnbHlwaCB0byByZW5kZXIsIHBhc3NpbmcgaXQgYW4gb2JqZWN0OlxuICogICAgICAgY2FsbGJhY2soe1xuICogICAgICAgICBpbmRleDogbnVtYmVyLFxuICogICAgICAgICBhZHZhbmNlV2lkdGg6IG51bWJlcixcbiAqICAgICAgICAgeE1pbjogbnVtYmVyLFxuICogICAgICAgICB5TWluOiBudW1iZXIsXG4gKiAgICAgICAgIHhNYXg6IG51bWJlcixcbiAqICAgICAgICAgeU1heDogbnVtYmVyLFxuICogICAgICAgICBwYXRoQ29tbWFuZENvdW50OiBudW1iZXIsXG4gKiAgICAgICAgIGZvckVhY2hQYXRoQ29tbWFuZChjYWxsYmFjaykge1xuICogICAgICAgICAgIC8vaW52b2tlcyBjYWxsYmFjayBmb3IgZWFjaCBwYXRoIGNvbW1hbmQsIHdpdGggYXJnczpcbiAqICAgICAgICAgICBjYWxsYmFjayhcbiAqICAgICAgICAgICAgIHR5cGU6ICdNfEx8Q3xRfFonLFxuICogICAgICAgICAgICAgLi4uYXJncyAvLzAgdG8gNiBhcmdzIGRlcGVuZGluZyBvbiB0aGUgdHlwZVxuICogICAgICAgICAgIClcbiAqICAgICAgICAgfVxuICogICAgICAgfSlcbiAqICAgICB9XG4gKiAgIH1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHNkZkdlbmVyYXRvciAtIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgZ2x5cGggb2JqZWN0IGFuZCBnZW5lcmF0ZXMgYW4gU0RGIHRleHR1cmVcbiAqIGZyb20gaXQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZvbnRQcm9jZXNzb3IoZm9udFBhcnNlciwgc2RmR2VuZXJhdG9yLCBjb25maWcpIHtcblxuICB2YXIgZGVmYXVsdEZvbnRVcmwgPSBjb25maWcuZGVmYXVsdEZvbnRVcmw7XG5cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogSG9sZHMgdGhlIGxvYWRlZCBkYXRhIGZvciBhbGwgZm9udHNcbiAgICpcbiAgICoge1xuICAgKiAgIGZvbnRVcmw6IHtcbiAgICogICAgIGZvbnRPYmo6IHt9LCAvL3Jlc3VsdCBvZiB0aGUgZm9udFBhcnNlclxuICAgKiAgICAgZ2x5cGhzOiB7XG4gICAqICAgICAgIFtnbHlwaEluZGV4XToge1xuICAgKiAgICAgICAgIGF0bGFzSW5kZXg6IDAsXG4gICAqICAgICAgICAgZ2x5cGhPYmo6IHt9LCAvL2dseXBoIG9iamVjdCBmcm9tIHRoZSBmb250UGFyc2VyXG4gICAqICAgICAgICAgcmVuZGVyaW5nQm91bmRzOiBbeDAsIHkwLCB4MSwgeTFdXG4gICAqICAgICAgIH0sXG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfSxcbiAgICogICAgIGdseXBoQ291bnQ6IDEyM1xuICAgKiAgIH1cbiAgICogfVxuICAgKi9cbiAgdmFyIGZvbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB2YXIgSU5GID0gSW5maW5pdHk7XG5cblxuICAvKipcbiAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsXG4gICAqL1xuICBmdW5jdGlvbiBkb0xvYWRGb250KHVybCwgY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiB0cnlMb2FkKCkge1xuICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiRmFpbHVyZSBsb2FkaW5nIGZvbnQgXCIgKyB1cmwgKyAodXJsID09PSBkZWZhdWx0Rm9udFVybCA/ICcnIDogJzsgdHJ5aW5nIGZhbGxiYWNrJykpLCBlcnIpO1xuICAgICAgICBpZiAodXJsICE9PSBkZWZhdWx0Rm9udFVybCkge1xuICAgICAgICAgIHVybCA9IGRlZmF1bHRGb250VXJsO1xuICAgICAgICAgIHRyeUxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3Qub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgZm9udE9iaiA9IGZvbnRQYXJzZXIocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGZvbnRPYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeUxvYWQoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIExvYWQgYSBnaXZlbiBmb250IHVybCBpZiBuZWVkZWQsIGludm9raW5nIGEgY2FsbGJhY2sgd2hlbiBpdCdzIGxvYWRlZC4gSWYgYWxyZWFkeVxuICAgKiBsb2FkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICAgKi9cbiAgZnVuY3Rpb24gbG9hZEZvbnQoZm9udFVybCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWZvbnRVcmwpIHsgZm9udFVybCA9IGRlZmF1bHRGb250VXJsOyB9XG4gICAgdmFyIGF0bGFzID0gZm9udHNbZm9udFVybF07XG4gICAgaWYgKGF0bGFzKSB7XG4gICAgICAvLyBpZiBjdXJyZW50bHkgbG9hZGluZyBmb250LCBhZGQgdG8gY2FsbGJhY2tzLCBvdGhlcndpc2UgZXhlY3V0ZSBpbW1lZGlhdGVseVxuICAgICAgaWYgKGF0bGFzLm9ubG9hZCkge1xuICAgICAgICBhdGxhcy5vbmxvYWQucHVzaChjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9hZGluZ0F0bGFzID0gZm9udHNbZm9udFVybF0gPSB7b25sb2FkOiBbY2FsbGJhY2tdfTtcbiAgICAgIGRvTG9hZEZvbnQoZm9udFVybCwgZnVuY3Rpb24gKGZvbnRPYmopIHtcbiAgICAgICAgYXRsYXMgPSBmb250c1tmb250VXJsXSA9IHtcbiAgICAgICAgICBmb250T2JqOiBmb250T2JqLFxuICAgICAgICAgIGdseXBoczoge30sXG4gICAgICAgICAgZ2x5cGhDb3VudDogMFxuICAgICAgICB9O1xuICAgICAgICBsb2FkaW5nQXRsYXMub25sb2FkLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXRsYXMgZGF0YSBmb3IgYSBnaXZlbiBmb250IHVybCwgbG9hZGluZyBpdCBmcm9tIHRoZSBuZXR3b3JrIGFuZCBpbml0aWFsaXppbmdcbiAgICogaXRzIGF0bGFzIGRhdGEgb2JqZWN0cyBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTZGZBdGxhcyhmb250VXJsLCBjYWxsYmFjaykge1xuICAgIGlmICghZm9udFVybCkgeyBmb250VXJsID0gZGVmYXVsdEZvbnRVcmw7IH1cbiAgICBsb2FkRm9udChmb250VXJsLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhmb250c1tmb250VXJsXSk7XG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBNYWluIGVudHJ5IHBvaW50LlxuICAgKiBQcm9jZXNzIGEgdGV4dCBzdHJpbmcgd2l0aCBnaXZlbiBmb250IGFuZCBmb3JtYXR0aW5nIHBhcmFtZXRlcnMsIGFuZCByZXR1cm4gYWxsIGluZm9cbiAgICogbmVjZXNzYXJ5IHRvIHJlbmRlciBhbGwgaXRzIGdseXBocy5cbiAgICovXG4gIGZ1bmN0aW9uIHByb2Nlc3MoXG4gICAgcmVmLFxuICAgIGNhbGxiYWNrLFxuICAgIG1ldHJpY3NPbmx5XG4gICkge1xuICAgIHZhciB0ZXh0ID0gcmVmLnRleHQ7IGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuICAgIHZhciBmb250ID0gcmVmLmZvbnQ7IGlmICggZm9udCA9PT0gdm9pZCAwICkgZm9udCA9IGRlZmF1bHRGb250VXJsO1xuICAgIHZhciBmb250U2l6ZSA9IHJlZi5mb250U2l6ZTsgaWYgKCBmb250U2l6ZSA9PT0gdm9pZCAwICkgZm9udFNpemUgPSAxO1xuICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gcmVmLmxldHRlclNwYWNpbmc7IGlmICggbGV0dGVyU3BhY2luZyA9PT0gdm9pZCAwICkgbGV0dGVyU3BhY2luZyA9IDA7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSByZWYubGluZUhlaWdodDsgaWYgKCBsaW5lSGVpZ2h0ID09PSB2b2lkIDAgKSBsaW5lSGVpZ2h0ID0gJ25vcm1hbCc7XG4gICAgdmFyIG1heFdpZHRoID0gcmVmLm1heFdpZHRoOyBpZiAoIG1heFdpZHRoID09PSB2b2lkIDAgKSBtYXhXaWR0aCA9IElORjtcbiAgICB2YXIgdGV4dEFsaWduID0gcmVmLnRleHRBbGlnbjsgaWYgKCB0ZXh0QWxpZ24gPT09IHZvaWQgMCApIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICB2YXIgd2hpdGVTcGFjZSA9IHJlZi53aGl0ZVNwYWNlOyBpZiAoIHdoaXRlU3BhY2UgPT09IHZvaWQgMCApIHdoaXRlU3BhY2UgPSAnbm9ybWFsJztcbiAgICB2YXIgb3ZlcmZsb3dXcmFwID0gcmVmLm92ZXJmbG93V3JhcDsgaWYgKCBvdmVyZmxvd1dyYXAgPT09IHZvaWQgMCApIG92ZXJmbG93V3JhcCA9ICdub3JtYWwnO1xuICAgIHZhciBhbmNob3IgPSByZWYuYW5jaG9yO1xuICAgIHZhciBpbmNsdWRlQ2FyZXRQb3NpdGlvbnMgPSByZWYuaW5jbHVkZUNhcmV0UG9zaXRpb25zOyBpZiAoIGluY2x1ZGVDYXJldFBvc2l0aW9ucyA9PT0gdm9pZCAwICkgaW5jbHVkZUNhcmV0UG9zaXRpb25zID0gZmFsc2U7XG4gICAgaWYgKCBtZXRyaWNzT25seSA9PT0gdm9pZCAwICkgbWV0cmljc09ubHk9ZmFsc2U7XG5cbiAgICAvLyBFbnN1cmUgbmV3bGluZXMgYXJlIG5vcm1hbGl6ZWRcbiAgICBpZiAodGV4dC5pbmRleE9mKCdcXHInKSA+IC0xKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZvbnRQcm9jZXNzb3IucHJvY2VzczogZ290IHRleHQgd2l0aCBcXFxcciBjaGFyczsgbm9ybWFsaXppbmcgdG8gXFxcXG4nKTtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcbiAgICB9XG5cbiAgICBnZXRTZGZBdGxhcyhmb250LCBmdW5jdGlvbiAoYXRsYXMpIHtcbiAgICAgIHZhciBmb250T2JqID0gYXRsYXMuZm9udE9iajtcbiAgICAgIHZhciBoYXNNYXhXaWR0aCA9IGlzRmluaXRlKG1heFdpZHRoKTtcbiAgICAgIHZhciBuZXdHbHlwaHMgPSBudWxsO1xuICAgICAgdmFyIGdseXBoQm91bmRzID0gbnVsbDtcbiAgICAgIHZhciBnbHlwaEF0bGFzSW5kaWNlcyA9IG51bGw7XG4gICAgICB2YXIgY2FyZXRQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgdmFyIHRvdGFsQm91bmRzID0gbnVsbDtcbiAgICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgdmFyIGNhbldyYXAgPSB3aGl0ZVNwYWNlICE9PSAnbm93cmFwJztcbiAgICAgIHZhciBhc2NlbmRlciA9IGZvbnRPYmouYXNjZW5kZXI7XG4gICAgICB2YXIgZGVzY2VuZGVyID0gZm9udE9iai5kZXNjZW5kZXI7XG4gICAgICB2YXIgdW5pdHNQZXJFbSA9IGZvbnRPYmoudW5pdHNQZXJFbTtcblxuICAgICAgLy8gRmluZCBjb252ZXJzaW9uIGJldHdlZW4gbmF0aXZlIGZvbnQgdW5pdHMgYW5kIGZvbnRTaXplIHVuaXRzOyB0aGlzIHdpbGwgYWxyZWFkeSBiZSBkb25lXG4gICAgICAvLyBmb3IgdGhlIGd4L2d5IHZhbHVlcyBiZWxvdyBidXQgZXZlcnl0aGluZyBlbHNlIHdlJ2xsIG5lZWQgdG8gY29udmVydFxuICAgICAgdmFyIGZvbnRTaXplTXVsdCA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGFwcHJvcHJpYXRlIHZhbHVlIGZvciAnbm9ybWFsJyBsaW5lIGhlaWdodCBiYXNlZCBvbiB0aGUgZm9udCdzIGFjdHVhbCBtZXRyaWNzXG4gICAgICAvLyBUT0RPIHRoaXMgZG9lcyBub3QgZ3VhcmFudGVlIGluZGl2aWR1YWwgZ2x5cGhzIHdvbid0IGV4Y2VlZCB0aGUgbGluZSBoZWlnaHQsIGUuZy4gUm9ib3RvOyBzaG91bGQgd2UgdXNlIHlNaW4vTWF4IGluc3RlYWQ/XG4gICAgICBpZiAobGluZUhlaWdodCA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgbGluZUhlaWdodCA9IChhc2NlbmRlciAtIGRlc2NlbmRlcikgLyB1bml0c1BlckVtO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgbGluZSBoZWlnaHQgYW5kIGxlYWRpbmcgYWRqdXN0bWVudHNcbiAgICAgIGxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ICogZm9udFNpemU7XG4gICAgICB2YXIgaGFsZkxlYWRpbmcgPSAobGluZUhlaWdodCAtIChhc2NlbmRlciAtIGRlc2NlbmRlcikgKiBmb250U2l6ZU11bHQpIC8gMjtcbiAgICAgIHZhciBjYXJldEhlaWdodCA9IE1hdGgubWluKGxpbmVIZWlnaHQsIChhc2NlbmRlciAtIGRlc2NlbmRlcikgKiBmb250U2l6ZU11bHQpO1xuICAgICAgdmFyIGNhcmV0Qm90dG9tT2Zmc2V0ID0gKGFzY2VuZGVyICsgZGVzY2VuZGVyKSAvIDIgKiBmb250U2l6ZU11bHQgLSBjYXJldEhlaWdodCAvIDI7XG5cbiAgICAgIC8vIERpc3RyaWJ1dGUgZ2x5cGhzIGludG8gbGluZXMgYmFzZWQgb24gd3JhcHBpbmdcbiAgICAgIHZhciBsaW5lWE9mZnNldCA9IDA7XG4gICAgICB2YXIgY3VycmVudExpbmUgPSB7Z2x5cGhzOiBbXSwgd2lkdGg6IDB9O1xuICAgICAgdmFyIGxpbmVzID0gW2N1cnJlbnRMaW5lXTtcbiAgICAgIGZvbnRPYmouZm9yRWFjaEdseXBoKHRleHQsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nLCBmdW5jdGlvbiAoZ2x5cGhPYmosIGdseXBoWCwgY2hhckluZGV4KSB7XG4gICAgICAgIHZhciBjaGFyID0gdGV4dC5jaGFyQXQoY2hhckluZGV4KTtcbiAgICAgICAgdmFyIGdseXBoV2lkdGggPSBnbHlwaE9iai5hZHZhbmNlV2lkdGggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgIHZhciBpc1doaXRlc3BhY2UgPSAhIWNoYXIgJiYgL1xccy8udGVzdChjaGFyKTtcbiAgICAgICAgdmFyIGN1ckxpbmVHbHlwaHMgPSBjdXJyZW50TGluZS5nbHlwaHM7XG4gICAgICAgIHZhciBuZXh0TGluZUdseXBocztcblxuICAgICAgICAvLyBJZiBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBvdmVyZmxvd3MgdGhlIG1heCB3aWR0aCwgd2UgbmVlZCB0byBzb2Z0LXdyYXBcbiAgICAgICAgaWYgKGNhbldyYXAgJiYgaGFzTWF4V2lkdGggJiYgIWlzV2hpdGVzcGFjZSAmJiBnbHlwaFggKyBnbHlwaFdpZHRoICsgbGluZVhPZmZzZXQgPiBtYXhXaWR0aCAmJiBjdXJMaW5lR2x5cGhzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIElmIGl0J3MgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgYSB3aGl0ZXNwYWNlLCBzdGFydCBhIG5ldyBsaW5lXG4gICAgICAgICAgaWYgKGN1ckxpbmVHbHlwaHNbY3VyTGluZUdseXBocy5sZW5ndGggLSAxXS5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIG5leHRMaW5lR2x5cGhzID0gW107XG4gICAgICAgICAgICBsaW5lWE9mZnNldCA9IC1nbHlwaFg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEJhY2sgdXAgbG9va2luZyBmb3IgYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciB0byB3cmFwIGF0XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY3VyTGluZUdseXBocy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgLy8gSWYgd2UgZ290IHRoZSBzdGFydCBvZiB0aGUgbGluZSB0aGVyZSdzIG5vIHNvZnQgYnJlYWsgcG9pbnQ7IG1ha2UgaGFyZCBicmVhayBpZiBvdmVyZmxvd1dyYXA9J2JyZWFrLXdvcmQnXG4gICAgICAgICAgICAgIGlmIChpID09PSAwICYmIG92ZXJmbG93V3JhcCA9PT0gJ2JyZWFrLXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgbmV4dExpbmVHbHlwaHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IC1nbHlwaFg7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBGb3VuZCBhIHNvZnQgYnJlYWsgcG9pbnQ7IG1vdmUgYWxsIGNoYXJzIHNpbmNlIGl0IHRvIGEgbmV3IGxpbmVcbiAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyTGluZUdseXBoc1tpXS5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0TGluZUdseXBocyA9IGN1ckxpbmVHbHlwaHMuc3BsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgYWRqdXN0WCA9IG5leHRMaW5lR2x5cGhzWzBdLng7XG4gICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgLT0gYWRqdXN0WDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5leHRMaW5lR2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0TGluZUdseXBoc1tqXS54IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHRMaW5lR2x5cGhzKSB7XG4gICAgICAgICAgICBjdXJyZW50TGluZS5pc1NvZnRXcmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lID0ge2dseXBoczogbmV4dExpbmVHbHlwaHMsIHdpZHRoOiAwfTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gbWF4V2lkdGg7IC8vYWZ0ZXIgc29mdCB3cmFwcGluZyB1c2UgbWF4V2lkdGggYXMgY2FsY3VsYXRlZCB3aWR0aFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRMaW5lLmdseXBocy5wdXNoKHtcbiAgICAgICAgICBnbHlwaE9iajogZ2x5cGhPYmosXG4gICAgICAgICAgeDogZ2x5cGhYICsgbGluZVhPZmZzZXQsXG4gICAgICAgICAgeTogMCwgLy9hZGRlZCBsYXRlclxuICAgICAgICAgIHdpZHRoOiBnbHlwaFdpZHRoLFxuICAgICAgICAgIGNoYXI6IGNoYXIsXG4gICAgICAgICAgY2hhckluZGV4OiBjaGFySW5kZXgsXG4gICAgICAgICAgaXNXaGl0ZXNwYWNlOiBpc1doaXRlc3BhY2UsXG4gICAgICAgICAgaXNFbXB0eTogZ2x5cGhPYmoueE1pbiA9PT0gZ2x5cGhPYmoueE1heCB8fCBnbHlwaE9iai55TWluID09PSBnbHlwaE9iai55TWF4LFxuICAgICAgICAgIGF0bGFzSW5mbzogbnVsbCAvL2FkZGVkIGxhdGVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEhhbmRsZSBoYXJkIGxpbmUgYnJlYWtzXG4gICAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICAgIGN1cnJlbnRMaW5lID0ge2dseXBoczogW10sIHdpZHRoOiAwfTtcbiAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgICBsaW5lWE9mZnNldCA9IC0oZ2x5cGhYICsgZ2x5cGhXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgd2lkdGggb2YgZWFjaCBsaW5lIChleGNsdWRpbmcgdHJhaWxpbmcgd2hpdGVzcGFjZSkgYW5kIG1heGltdW0gYmxvY2sgd2lkdGhcbiAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIGxpbmVHbHlwaHMgPSBsaW5lLmdseXBocztcbiAgICAgICAgZm9yICh2YXIgaSA9IGxpbmVHbHlwaHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgdmFyIGxhc3RDaGFyID0gbGluZUdseXBoc1tpXTtcbiAgICAgICAgICBpZiAoIWxhc3RDaGFyLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgbGluZS53aWR0aCA9IGxhc3RDaGFyLnggKyBsYXN0Q2hhci53aWR0aDtcbiAgICAgICAgICAgIGlmIChsaW5lLndpZHRoID4gbWF4TGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW1ldHJpY3NPbmx5KSB7XG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBsaW5lLCBhcHBseWluZyBhbGlnbm1lbnQgb2Zmc2V0cywgYWRkaW5nIGVhY2ggZ2x5cGggdG8gdGhlIGF0bGFzLCBhbmRcbiAgICAgICAgLy8gY29sbGVjdGluZyBhbGwgcmVuZGVyYWJsZSBnbHlwaHMgaW50byBhIHNpbmdsZSBjb2xsZWN0aW9uLlxuICAgICAgICB2YXIgcmVuZGVyYWJsZUdseXBocyA9IFtdO1xuICAgICAgICB2YXIgbGluZVlPZmZzZXQgPSAtKGZvbnRTaXplICsgaGFsZkxlYWRpbmcpO1xuICAgICAgICBpZiAoaW5jbHVkZUNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgY2FyZXRQb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHRleHQubGVuZ3RoICogMyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZDaGFySW5kZXggPSAtMTtcbiAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgIHZhciBsaW5lR2x5cGhzID0gbGluZS5nbHlwaHM7XG4gICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGxpbmUud2lkdGg7XG5cbiAgICAgICAgICAvLyBJZ25vcmUgZW1wdHkgbGluZXNcbiAgICAgICAgICBpZiAobGluZUdseXBocy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgeCBvZmZzZXQgZm9yIGhvcml6b250YWwgYWxpZ25tZW50XG4gICAgICAgICAgICB2YXIgbGluZVhPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIHdoaXRlc3BhY2VDb3VudCA9IDA7XG4gICAgICAgICAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGgpIC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5Jykge1xuICAgICAgICAgICAgICAvLyBqdXN0IGNvdW50IHRoZSBub24tdHJhaWxpbmcgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLCBhbmQgd2UnbGwgYWRqdXN0IHRoZSBvZmZzZXRzIHBlclxuICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgaW4gdGhlIG5leHQgbG9vcFxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbGluZUdseXBocy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmVHbHlwaHNbaV0uaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lR2x5cGhzW2ldLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsZW4gPSBsaW5lR2x5cGhzLmxlbmd0aDsgaSQxIDwgbGVuOyBpJDErKykge1xuICAgICAgICAgICAgICB2YXIgZ2x5cGhJbmZvID0gbGluZUdseXBoc1tpJDFdO1xuXG4gICAgICAgICAgICAgIC8vIEFwcGx5IHBvc2l0aW9uIGFkanVzdG1lbnRzXG4gICAgICAgICAgICAgIGlmIChsaW5lWE9mZnNldCkgeyBnbHlwaEluZm8ueCArPSBsaW5lWE9mZnNldDsgfVxuICAgICAgICAgICAgICBnbHlwaEluZm8ueSA9IGxpbmVZT2Zmc2V0O1xuXG4gICAgICAgICAgICAgIC8vIEV4cGFuZCB3aGl0ZXNwYWNlcyBmb3IganVzdGlmeSBhbGlnbm1lbnRcbiAgICAgICAgICAgICAgaWYgKGdseXBoSW5mby5pc1doaXRlc3BhY2UgJiYgdGV4dEFsaWduID09PSAnanVzdGlmeScgJiYgbGluZS5pc1NvZnRXcmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkanVzdCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGgpIC8gd2hpdGVzcGFjZUNvdW50O1xuICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ICs9IGFkanVzdDtcbiAgICAgICAgICAgICAgICBnbHlwaEluZm8ud2lkdGggKz0gYWRqdXN0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQWRkIGluaXRpYWwgY2FyZXQgcG9zaXRpb25zXG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlQ2FyZXRQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhckluZGV4ID0gZ2x5cGhJbmZvLmNoYXJJbmRleDtcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiAzXSA9IGdseXBoSW5mby54OyAvL2xlZnQgZWRnZSB4XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogMyArIDFdID0gZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGg7IC8vcmlnaHQgZWRnZSB4XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogMyArIDJdID0gZ2x5cGhJbmZvLnkgKyBjYXJldEJvdHRvbU9mZnNldDsgLy9jb21tb24gYm90dG9tIHlcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHNraXBwZWQgYW55IGNoYXJzIGZyb20gdGhlIHByZXZpb3VzIGdseXBoIChkdWUgdG8gbGlnYXR1cmUgc3VicyksIGNvcHkgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgZ2x5cGgncyBpbmZvIHRvIHRob3NlIG1pc3NpbmcgY2hhciBpbmRpY2VzLiBJbiB0aGUgZnV0dXJlIHdlIG1heSB0cnkgdG9cbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGZvbnQncyBMaWdhdHVyZUNhcmV0TGlzdCB0YWJsZSB0byBnZXQgaW50ZXJpb3IgY2FyZXQgcG9zaXRpb25zLlxuICAgICAgICAgICAgICAgIHdoaWxlIChjaGFySW5kZXggLSBwcmV2Q2hhckluZGV4ID4gMSkge1xuICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbKHByZXZDaGFySW5kZXggKyAxKSAqIDNdID0gY2FyZXRQb3NpdGlvbnNbcHJldkNoYXJJbmRleCAqIDMgKyAxXTtcbiAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zWyhwcmV2Q2hhckluZGV4ICsgMSkgKiAzICsgMV0gPSBjYXJldFBvc2l0aW9uc1twcmV2Q2hhckluZGV4ICogMyArIDFdO1xuICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbKHByZXZDaGFySW5kZXggKyAxKSAqIDMgKyAyXSA9IGNhcmV0UG9zaXRpb25zW3ByZXZDaGFySW5kZXggKiAzICsgMl07XG4gICAgICAgICAgICAgICAgICBwcmV2Q2hhckluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZDaGFySW5kZXggPSBjaGFySW5kZXg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBHZXQgYXRsYXMgZGF0YSBmb3IgcmVuZGVyYWJsZSBnbHlwaHNcbiAgICAgICAgICAgICAgaWYgKCFnbHlwaEluZm8uaXNXaGl0ZXNwYWNlICYmICFnbHlwaEluZm8uaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaE9iaiA9IGdseXBoSW5mby5nbHlwaE9iajtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmVuJ3Qgc2VlbiB0aGlzIGdseXBoIHlldCwgZ2VuZXJhdGUgaXRzIFNERlxuICAgICAgICAgICAgICAgIHZhciBnbHlwaEF0bGFzSW5mbyA9IGF0bGFzLmdseXBoc1tnbHlwaE9iai5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCFnbHlwaEF0bGFzSW5mbykge1xuICAgICAgICAgICAgICAgICAgdmFyIGdseXBoU0RGRGF0YSA9IHNkZkdlbmVyYXRvcihnbHlwaE9iaik7XG5cbiAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0aGlzIGdseXBoIHRoZSBuZXh0IGF2YWlsYWJsZSBhdGxhcyBpbmRleFxuICAgICAgICAgICAgICAgICAgZ2x5cGhTREZEYXRhLmF0bGFzSW5kZXggPSBhdGxhcy5nbHlwaENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFF1ZXVlIGl0IHVwIGluIHRoZSByZXNwb25zZSdzIG5ld0dseXBocyBsaXN0XG4gICAgICAgICAgICAgICAgICBpZiAoIW5ld0dseXBocykgeyBuZXdHbHlwaHMgPSBbXTsgfVxuICAgICAgICAgICAgICAgICAgbmV3R2x5cGhzLnB1c2goZ2x5cGhTREZEYXRhKTtcblxuICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgaXRzIG1ldGFkYXRhIChub3QgdGhlIHRleHR1cmUpIGluIG91ciBhdGxhcyBpbmZvXG4gICAgICAgICAgICAgICAgICBnbHlwaEF0bGFzSW5mbyA9IGF0bGFzLmdseXBoc1tnbHlwaE9iai5pbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGF0bGFzSW5kZXg6IGdseXBoU0RGRGF0YS5hdGxhc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBnbHlwaE9iajogZ2x5cGhPYmosXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmluZ0JvdW5kczogZ2x5cGhTREZEYXRhLnJlbmRlcmluZ0JvdW5kc1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmZvLmF0bGFzSW5mbyA9IGdseXBoQXRsYXNJbmZvO1xuXG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZUdseXBocy5wdXNoKGdseXBoSW5mbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJbmNyZW1lbnQgeSBvZmZzZXQgZm9yIG5leHQgbGluZVxuICAgICAgICAgIGxpbmVZT2Zmc2V0IC09IGxpbmVIZWlnaHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpbmQgb3ZlcmFsbCBwb3NpdGlvbiBhZGp1c3RtZW50cyBmb3IgYW5jaG9yaW5nXG4gICAgICAgIHZhciBhbmNob3JYT2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGFuY2hvcllPZmZzZXQgPSAwO1xuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgLy8gVE9ETyBhbGxvdyBzdHJpbmcga2V5d29yZHM/XG4gICAgICAgICAgaWYgKGFuY2hvclswXSkge1xuICAgICAgICAgICAgYW5jaG9yWE9mZnNldCA9IC1tYXhMaW5lV2lkdGggKiBhbmNob3JbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhbmNob3JbMV0pIHtcbiAgICAgICAgICAgIGFuY2hvcllPZmZzZXQgPSBsaW5lcy5sZW5ndGggKiBsaW5lSGVpZ2h0ICogYW5jaG9yWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkanVzdCBjYXJldCBwb3NpdGlvbnMgYnkgYW5jaG9yaW5nIG9mZnNldHNcbiAgICAgICAgaWYgKGluY2x1ZGVDYXJldFBvc2l0aW9ucyAmJiAoYW5jaG9yWE9mZnNldCB8fCBhbmNob3JZT2Zmc2V0KSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYXJldFBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbaV0gKz0gYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zW2kgKyAxXSArPSBhbmNob3JYT2Zmc2V0O1xuICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbaSArIDJdICs9IGFuY2hvcllPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvdXRwdXQgZm9yIHRoZSByZW5kZWFibGUgZ2x5cGhzXG4gICAgICAgIGdseXBoQm91bmRzID0gbmV3IEZsb2F0MzJBcnJheShyZW5kZXJhYmxlR2x5cGhzLmxlbmd0aCAqIDQpO1xuICAgICAgICBnbHlwaEF0bGFzSW5kaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkocmVuZGVyYWJsZUdseXBocy5sZW5ndGgpO1xuICAgICAgICB0b3RhbEJvdW5kcyA9IFtJTkYsIElORiwgLUlORiwgLUlORl07XG4gICAgICAgIHJlbmRlcmFibGVHbHlwaHMuZm9yRWFjaChmdW5jdGlvbiAoZ2x5cGhJbmZvLCBpKSB7XG4gICAgICAgICAgdmFyIHJlZiA9IGdseXBoSW5mby5hdGxhc0luZm87XG4gICAgICAgICAgdmFyIHJlbmRlcmluZ0JvdW5kcyA9IHJlZi5yZW5kZXJpbmdCb3VuZHM7XG4gICAgICAgICAgdmFyIGF0bGFzSW5kZXggPSByZWYuYXRsYXNJbmRleDtcbiAgICAgICAgICB2YXIgeDAgPSBnbHlwaEJvdW5kc1tpICogNF0gPSBnbHlwaEluZm8ueCArIHJlbmRlcmluZ0JvdW5kc1swXSAqIGZvbnRTaXplTXVsdCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgdmFyIHkwID0gZ2x5cGhCb3VuZHNbaSAqIDQgKyAxXSA9IGdseXBoSW5mby55ICsgcmVuZGVyaW5nQm91bmRzWzFdICogZm9udFNpemVNdWx0ICsgYW5jaG9yWU9mZnNldDtcbiAgICAgICAgICB2YXIgeDEgPSBnbHlwaEJvdW5kc1tpICogNCArIDJdID0gZ2x5cGhJbmZvLnggKyByZW5kZXJpbmdCb3VuZHNbMl0gKiBmb250U2l6ZU11bHQgKyBhbmNob3JYT2Zmc2V0O1xuICAgICAgICAgIHZhciB5MSA9IGdseXBoQm91bmRzW2kgKiA0ICsgM10gPSBnbHlwaEluZm8ueSArIHJlbmRlcmluZ0JvdW5kc1szXSAqIGZvbnRTaXplTXVsdCArIGFuY2hvcllPZmZzZXQ7XG5cbiAgICAgICAgICBpZiAoeDAgPCB0b3RhbEJvdW5kc1swXSkgeyB0b3RhbEJvdW5kc1swXSA9IHgwOyB9XG4gICAgICAgICAgaWYgKHkwIDwgdG90YWxCb3VuZHNbMV0pIHsgdG90YWxCb3VuZHNbMV0gPSB5MDsgfVxuICAgICAgICAgIGlmICh4MSA+IHRvdGFsQm91bmRzWzJdKSB7IHRvdGFsQm91bmRzWzJdID0geDE7IH1cbiAgICAgICAgICBpZiAoeTEgPiB0b3RhbEJvdW5kc1szXSkgeyB0b3RhbEJvdW5kc1szXSA9IHkxOyB9XG5cbiAgICAgICAgICBnbHlwaEF0bGFzSW5kaWNlc1tpXSA9IGF0bGFzSW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIGdseXBoQm91bmRzOiBnbHlwaEJvdW5kcywgLy9yZW5kZXJpbmcgcXVhZCBib3VuZHMgZm9yIGVhY2ggZ2x5cGggW3gxLCB5MSwgeDIsIHkyXVxuICAgICAgICBnbHlwaEF0bGFzSW5kaWNlczogZ2x5cGhBdGxhc0luZGljZXMsIC8vYXRsYXMgaW5kaWNlcyBmb3IgZWFjaCBnbHlwaFxuICAgICAgICBjYXJldFBvc2l0aW9uczogY2FyZXRQb3NpdGlvbnMsIC8veCx5IG9mIGJvdHRvbSBvZiBjdXJzb3IgcG9zaXRpb24gYmVmb3JlIGVhY2ggY2hhciwgcGx1cyBvbmUgYWZ0ZXIgbGFzdCBjaGFyXG4gICAgICAgIGNhcmV0SGVpZ2h0OiBjYXJldEhlaWdodCwgLy9oZWlnaHQgb2YgY3Vyc29yIGZyb20gYm90dG9tIHRvIHRvcFxuICAgICAgICB0b3RhbEJvdW5kczogdG90YWxCb3VuZHMsIC8vdG90YWwgcmVjdCBpbmNsdWRpbmcgYWxsIGdseXBoQm91bmRzOyB3aWxsIGJlIHNsaWdodGx5IGxhcmdlciB0aGFuIGdseXBoIGVkZ2VzIGR1ZSB0byBTREYgcGFkZGluZ1xuICAgICAgICB0b3RhbEJsb2NrU2l6ZTogW21heExpbmVXaWR0aCwgbGluZXMubGVuZ3RoICogbGluZUhlaWdodF0sIC8vd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdGV4dCBibG9jazsgYWNjdXJhdGUgZm9yIGxheW91dCBtZWFzdXJlbWVudFxuICAgICAgICBuZXdHbHlwaFNERnM6IG5ld0dseXBocyAvL2lmIHRoaXMgcmVxdWVzdCBpbmNsdWRlZCBhbnkgbmV3IFNERnMgZm9yIHRoZSBhdGxhcywgdGhleSdsbCBiZSBpbmNsdWRlZCBoZXJlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEZvciBhIGdpdmVuIHRleHQgc3RyaW5nIGFuZCBmb250IHBhcmFtZXRlcnMsIGRldGVybWluZSB0aGUgcmVzdWx0aW5nIGJsb2NrIGRpbWVuc2lvbnNcbiAgICogYWZ0ZXIgd3JhcHBpbmcgZm9yIHRoZSBnaXZlbiBtYXhXaWR0aC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBtZWFzdXJlKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgcHJvY2VzcyhhcmdzLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIHdpZHRoOiByZXN1bHQudG90YWxCbG9ja1NpemVbMF0sXG4gICAgICAgIGhlaWdodDogcmVzdWx0LnRvdGFsQmxvY2tTaXplWzFdXG4gICAgICB9KTtcbiAgICB9LCB7bWV0cmljc09ubHk6IHRydWV9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHJvY2VzczogcHJvY2VzcyxcbiAgICBtZWFzdXJlOiBtZWFzdXJlLFxuICAgIGxvYWRGb250OiBsb2FkRm9udFxuICB9XG59XG5cbi8vIEN1c3RvbSBidW5kbGUgb2YgVHlwci5qcyAoaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvcGVhL1R5cHIuanMpIGZvciB1c2UgaW4gdHJvaWthLTNkLXRleHQuIFxuLy8gT3JpZ2luYWwgTUlUIGxpY2Vuc2UgYXBwbGllczogaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvcGVhL1R5cHIuanMvYmxvYi9naC1wYWdlcy9MSUNFTlNFXG5cbmZ1bmN0aW9uIHR5cHJGYWN0b3J5KCkge1xuXG52YXIgd2luZG93ID0gc2VsZjtcblxuLy8gQmVnaW4gVHlwci5qc1xuXG5cbnZhciBUeXByID0ge307XG5cblR5cHIucGFyc2UgPSBmdW5jdGlvbihidWZmKVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpO1xuXHRcblx0dmFyIHRhZyA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgMCwgNCk7ICBcblx0aWYodGFnPT1cInR0Y2ZcIikge1xuXHRcdHZhciBvZmZzZXQgPSA0O1xuXHRcdHZhciBtYWpWID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XHR2YXIgbWluViA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0dmFyIG51bUYgPSBiaW4ucmVhZFVpbnQgIChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz00O1xuXHRcdHZhciBmbnRzID0gW107XG5cdFx0Zm9yKHZhciBpPTA7IGk8bnVtRjsgaSsrKSB7XG5cdFx0XHR2YXIgZm9mZiA9IGJpbi5yZWFkVWludCAgKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTQ7XG5cdFx0XHRmbnRzLnB1c2goVHlwci5fcmVhZEZvbnQoZGF0YSwgZm9mZikpO1xuXHRcdH1cblx0XHRyZXR1cm4gZm50cztcblx0fVxuXHRlbHNlIHsgcmV0dXJuIFtUeXByLl9yZWFkRm9udChkYXRhLCAwKV07IH1cbn07XG5cblR5cHIuX3JlYWRGb250ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KSB7XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdHZhciBvb2ZmID0gb2Zmc2V0O1xuXHRcblx0dmFyIHNmbnRfdmVyc2lvbiA9IGJpbi5yZWFkRml4ZWQoZGF0YSwgb2Zmc2V0KTtcblx0b2Zmc2V0ICs9IDQ7XG5cdHZhciBudW1UYWJsZXMgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpO1xuXHRvZmZzZXQgKz0gMjtcblx0dmFyIHNlYXJjaFJhbmdlID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTtcblx0b2Zmc2V0ICs9IDI7XG5cdHZhciBlbnRyeVNlbGVjdG9yID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTtcblx0b2Zmc2V0ICs9IDI7XG5cdHZhciByYW5nZVNoaWZ0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTtcblx0b2Zmc2V0ICs9IDI7XG5cdFxuXHR2YXIgdGFncyA9IFtcblx0XHRcImNtYXBcIixcblx0XHRcImhlYWRcIixcblx0XHRcImhoZWFcIixcblx0XHRcIm1heHBcIixcblx0XHRcImhtdHhcIixcblx0XHRcIm5hbWVcIixcblx0XHRcIk9TLzJcIixcblx0XHRcInBvc3RcIixcblx0XHRcblx0XHQvL1wiY3Z0XCIsXG5cdFx0Ly9cImZwZ21cIixcblx0XHRcImxvY2FcIixcblx0XHRcImdseWZcIixcblx0XHRcImtlcm5cIixcblx0XHRcblx0XHQvL1wicHJlcFwiXG5cdFx0Ly9cImdhc3BcIlxuXHRcdFxuXHRcdFwiQ0ZGIFwiLFxuXHRcdFxuXHRcdFxuXHRcdFwiR1BPU1wiLFxuXHRcdFwiR1NVQlwiLFxuXHRcdFxuXHRcdFwiU1ZHIFwiIF07XG5cdFxuXHR2YXIgb2JqID0ge19kYXRhOmRhdGEsIF9vZmZzZXQ6b29mZn07XG5cdC8vY29uc29sZS5sb2coc2ZudF92ZXJzaW9uLCBudW1UYWJsZXMsIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0KTtcblx0XG5cdHZhciB0YWJzID0ge307XG5cdFxuXHRmb3IodmFyIGk9MDsgaTxudW1UYWJsZXM7IGkrKylcblx0e1xuXHRcdHZhciB0YWcgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG9mZnNldCwgNCk7ICAgb2Zmc2V0ICs9IDQ7XG5cdFx0dmFyIGNoZWNrU3VtID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0XHR2YXIgdG9mZnNldCA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgIG9mZnNldCArPSA0O1xuXHRcdHZhciBsZW5ndGggPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgICAgb2Zmc2V0ICs9IDQ7XG5cdFx0dGFic1t0YWddID0ge29mZnNldDp0b2Zmc2V0LCBsZW5ndGg6bGVuZ3RofTtcblx0XHRcblx0XHQvL2lmKHRhZ3MuaW5kZXhPZih0YWcpPT0tMSkgY29uc29sZS5sb2coXCJ1bmtub3duIHRhZ1wiLCB0YWcsIGxlbmd0aCk7XG5cdH1cblx0XG5cdGZvcih2YXIgaT0wOyBpPCB0YWdzLmxlbmd0aDsgaSsrKVxuXHR7XG5cdFx0dmFyIHQgPSB0YWdzW2ldO1xuXHRcdC8vY29uc29sZS5sb2codCk7XG5cdFx0Ly9pZih0YWJzW3RdKSBjb25zb2xlLmxvZyh0LCB0YWJzW3RdLm9mZnNldCwgdGFic1t0XS5sZW5ndGgpO1xuXHRcdGlmKHRhYnNbdF0pIHsgb2JqW3QudHJpbSgpXSA9IFR5cHJbdC50cmltKCldLnBhcnNlKGRhdGEsIHRhYnNbdF0ub2Zmc2V0LCB0YWJzW3RdLmxlbmd0aCwgb2JqKTsgfVxuXHR9XG5cdFxuXHRyZXR1cm4gb2JqO1xufTtcblxuVHlwci5fdGFiT2Zmc2V0ID0gZnVuY3Rpb24oZGF0YSwgdGFiLCBmb2ZmKVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgbnVtVGFibGVzID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgZm9mZis0KTtcblx0dmFyIG9mZnNldCA9IGZvZmYrMTI7XG5cdGZvcih2YXIgaT0wOyBpPG51bVRhYmxlczsgaSsrKVxuXHR7XG5cdFx0dmFyIHRhZyA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2Zmc2V0LCA0KTsgICBvZmZzZXQgKz0gNDtcblx0XHR2YXIgY2hlY2tTdW0gPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuXHRcdHZhciB0b2Zmc2V0ID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICAgb2Zmc2V0ICs9IDQ7XG5cdFx0dmFyIGxlbmd0aCA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgICBvZmZzZXQgKz0gNDtcblx0XHRpZih0YWc9PXRhYikgeyByZXR1cm4gdG9mZnNldDsgfVxuXHR9XG5cdHJldHVybiAwO1xufTtcblxuXG5cblxuXG5UeXByLl9iaW4gPSB7XG5cdHJlYWRGaXhlZCA6IGZ1bmN0aW9uKGRhdGEsIG8pXG5cdHtcblx0XHRyZXR1cm4gKChkYXRhW29dPDw4KSB8IGRhdGFbbysxXSkgKyAgKCgoZGF0YVtvKzJdPDw4KXxkYXRhW28rM10pLygyNTYqMjU2KzQpKTtcblx0fSxcblx0cmVhZEYyZG90MTQgOiBmdW5jdGlvbihkYXRhLCBvKVxuXHR7XG5cdFx0dmFyIG51bSA9IFR5cHIuX2Jpbi5yZWFkU2hvcnQoZGF0YSwgbyk7XG5cdFx0cmV0dXJuIG51bSAvIDE2Mzg0O1xuXHR9LFxuXHRyZWFkSW50IDogZnVuY3Rpb24oYnVmZiwgcClcblx0e1xuXHRcdC8vaWYocD49YnVmZi5sZW5ndGgpIHRocm93IFwiZXJyb3JcIjtcblx0XHR2YXIgYSA9IFR5cHIuX2Jpbi50LnVpbnQ4O1xuXHRcdGFbMF0gPSBidWZmW3ArM107XG5cdFx0YVsxXSA9IGJ1ZmZbcCsyXTtcblx0XHRhWzJdID0gYnVmZltwKzFdO1xuXHRcdGFbM10gPSBidWZmW3BdO1xuXHRcdHJldHVybiBUeXByLl9iaW4udC5pbnQzMlswXTtcblx0fSxcblx0XG5cdHJlYWRJbnQ4IDogZnVuY3Rpb24oYnVmZiwgcClcblx0e1xuXHRcdC8vaWYocD49YnVmZi5sZW5ndGgpIHRocm93IFwiZXJyb3JcIjtcblx0XHR2YXIgYSA9IFR5cHIuX2Jpbi50LnVpbnQ4O1xuXHRcdGFbMF0gPSBidWZmW3BdO1xuXHRcdHJldHVybiBUeXByLl9iaW4udC5pbnQ4WzBdO1xuXHR9LFxuXHRyZWFkU2hvcnQgOiBmdW5jdGlvbihidWZmLCBwKVxuXHR7XG5cdFx0Ly9pZihwPj1idWZmLmxlbmd0aCkgdGhyb3cgXCJlcnJvclwiO1xuXHRcdHZhciBhID0gVHlwci5fYmluLnQudWludDg7XG5cdFx0YVsxXSA9IGJ1ZmZbcF07IGFbMF0gPSBidWZmW3ArMV07XG5cdFx0cmV0dXJuIFR5cHIuX2Jpbi50LmludDE2WzBdO1xuXHR9LFxuXHRyZWFkVXNob3J0IDogZnVuY3Rpb24oYnVmZiwgcClcblx0e1xuXHRcdC8vaWYocD49YnVmZi5sZW5ndGgpIHRocm93IFwiZXJyb3JcIjtcblx0XHRyZXR1cm4gKGJ1ZmZbcF08PDgpIHwgYnVmZltwKzFdO1xuXHR9LFxuXHRyZWFkVXNob3J0cyA6IGZ1bmN0aW9uKGJ1ZmYsIHAsIGxlbilcblx0e1xuXHRcdHZhciBhcnIgPSBbXTtcblx0XHRmb3IodmFyIGk9MDsgaTxsZW47IGkrKykgeyBhcnIucHVzaChUeXByLl9iaW4ucmVhZFVzaG9ydChidWZmLCBwK2kqMikpOyB9XG5cdFx0cmV0dXJuIGFycjtcblx0fSxcblx0cmVhZFVpbnQgOiBmdW5jdGlvbihidWZmLCBwKVxuXHR7XG5cdFx0Ly9pZihwPj1idWZmLmxlbmd0aCkgdGhyb3cgXCJlcnJvclwiO1xuXHRcdHZhciBhID0gVHlwci5fYmluLnQudWludDg7XG5cdFx0YVszXSA9IGJ1ZmZbcF07ICBhWzJdID0gYnVmZltwKzFdOyAgYVsxXSA9IGJ1ZmZbcCsyXTsgIGFbMF0gPSBidWZmW3ArM107XG5cdFx0cmV0dXJuIFR5cHIuX2Jpbi50LnVpbnQzMlswXTtcblx0fSxcblx0cmVhZFVpbnQ2NCA6IGZ1bmN0aW9uKGJ1ZmYsIHApXG5cdHtcblx0XHQvL2lmKHA+PWJ1ZmYubGVuZ3RoKSB0aHJvdyBcImVycm9yXCI7XG5cdFx0cmV0dXJuIChUeXByLl9iaW4ucmVhZFVpbnQoYnVmZiwgcCkqKDB4ZmZmZmZmZmYrMSkpICsgVHlwci5fYmluLnJlYWRVaW50KGJ1ZmYsIHArNCk7XG5cdH0sXG5cdHJlYWRBU0NJSSA6IGZ1bmN0aW9uKGJ1ZmYsIHAsIGwpXHQvLyBsIDogbGVuZ3RoIGluIENoYXJhY3RlcnMgKG5vdCBCeXRlcylcblx0e1xuXHRcdC8vaWYocD49YnVmZi5sZW5ndGgpIHRocm93IFwiZXJyb3JcIjtcblx0XHR2YXIgcyA9IFwiXCI7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykgeyBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZltwK2ldKTsgfVxuXHRcdHJldHVybiBzO1xuXHR9LFxuXHRyZWFkVW5pY29kZSA6IGZ1bmN0aW9uKGJ1ZmYsIHAsIGwpXG5cdHtcblx0XHQvL2lmKHA+PWJ1ZmYubGVuZ3RoKSB0aHJvdyBcImVycm9yXCI7XG5cdFx0dmFyIHMgPSBcIlwiO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspXHRcblx0XHR7XG5cdFx0XHR2YXIgYyA9IChidWZmW3ArK108PDgpIHwgYnVmZltwKytdO1xuXHRcdFx0cyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuXHRcdH1cblx0XHRyZXR1cm4gcztcblx0fSxcblx0X3RkZWMgOiB3aW5kb3dbXCJUZXh0RGVjb2RlclwiXSA/IG5ldyB3aW5kb3dbXCJUZXh0RGVjb2RlclwiXSgpIDogbnVsbCxcblx0cmVhZFVURjggOiBmdW5jdGlvbihidWZmLCBwLCBsKSB7XG5cdFx0dmFyIHRkZWMgPSBUeXByLl9iaW4uX3RkZWM7XG5cdFx0aWYodGRlYyAmJiBwPT0wICYmIGw9PWJ1ZmYubGVuZ3RoKSB7IHJldHVybiB0ZGVjW1wiZGVjb2RlXCJdKGJ1ZmYpOyB9XG5cdFx0cmV0dXJuIFR5cHIuX2Jpbi5yZWFkQVNDSUkoYnVmZixwLGwpO1xuXHR9LFxuXHRyZWFkQnl0ZXMgOiBmdW5jdGlvbihidWZmLCBwLCBsKVxuXHR7XG5cdFx0Ly9pZihwPj1idWZmLmxlbmd0aCkgdGhyb3cgXCJlcnJvclwiO1xuXHRcdHZhciBhcnIgPSBbXTtcblx0XHRmb3IodmFyIGk9MDsgaTxsOyBpKyspIHsgYXJyLnB1c2goYnVmZltwK2ldKTsgfVxuXHRcdHJldHVybiBhcnI7XG5cdH0sXG5cdHJlYWRBU0NJSUFycmF5IDogZnVuY3Rpb24oYnVmZiwgcCwgbClcdC8vIGwgOiBsZW5ndGggaW4gQ2hhcmFjdGVycyAobm90IEJ5dGVzKVxuXHR7XG5cdFx0Ly9pZihwPj1idWZmLmxlbmd0aCkgdGhyb3cgXCJlcnJvclwiO1xuXHRcdHZhciBzID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKylcdFxuXHRcdFx0eyBzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShidWZmW3AraV0pKTsgfVxuXHRcdHJldHVybiBzO1xuXHR9XG59O1xuXG5UeXByLl9iaW4udCA9IHtcblx0YnVmZjogbmV3IEFycmF5QnVmZmVyKDgpLFxufTtcblR5cHIuX2Jpbi50LmludDggICA9IG5ldyBJbnQ4QXJyYXkgIChUeXByLl9iaW4udC5idWZmKTtcblR5cHIuX2Jpbi50LnVpbnQ4ICA9IG5ldyBVaW50OEFycmF5IChUeXByLl9iaW4udC5idWZmKTtcblR5cHIuX2Jpbi50LmludDE2ICA9IG5ldyBJbnQxNkFycmF5IChUeXByLl9iaW4udC5idWZmKTtcblR5cHIuX2Jpbi50LnVpbnQxNiA9IG5ldyBVaW50MTZBcnJheShUeXByLl9iaW4udC5idWZmKTtcblR5cHIuX2Jpbi50LmludDMyICA9IG5ldyBJbnQzMkFycmF5IChUeXByLl9iaW4udC5idWZmKTtcblR5cHIuX2Jpbi50LnVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShUeXByLl9iaW4udC5idWZmKTtcblxuXG5cblxuXG4vLyBPcGVuVHlwZSBMYXlvdXQgQ29tbW9uIFRhYmxlIEZvcm1hdHNcblxuVHlwci5fbGN0ZiA9IHt9O1xuXG5UeXByLl9sY3RmLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIGZvbnQsIHN1YnQpXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdHZhciBvYmogPSB7fTtcblx0dmFyIG9mZnNldDAgPSBvZmZzZXQ7XG5cdHZhciB0YWJsZVZlcnNpb24gPSBiaW4ucmVhZEZpeGVkKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0XG5cdHZhciBvZmZTY3JpcHRMaXN0ICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0dmFyIG9mZkZlYXR1cmVMaXN0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHR2YXIgb2ZmTG9va3VwTGlzdCAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFxuXHRcblx0b2JqLnNjcmlwdExpc3QgID0gVHlwci5fbGN0Zi5yZWFkU2NyaXB0TGlzdCAoZGF0YSwgb2Zmc2V0MCArIG9mZlNjcmlwdExpc3QpO1xuXHRvYmouZmVhdHVyZUxpc3QgPSBUeXByLl9sY3RmLnJlYWRGZWF0dXJlTGlzdChkYXRhLCBvZmZzZXQwICsgb2ZmRmVhdHVyZUxpc3QpO1xuXHRvYmoubG9va3VwTGlzdCAgPSBUeXByLl9sY3RmLnJlYWRMb29rdXBMaXN0IChkYXRhLCBvZmZzZXQwICsgb2ZmTG9va3VwTGlzdCwgc3VidCk7XG5cdFxuXHRyZXR1cm4gb2JqO1xufTtcblxuVHlwci5fbGN0Zi5yZWFkTG9va3VwTGlzdCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgc3VidClcbntcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0dmFyIG9mZnNldDAgPSBvZmZzZXQ7XG5cdHZhciBvYmogPSBbXTtcblx0dmFyIGNvdW50ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0Zm9yKHZhciBpPTA7IGk8Y291bnQ7IGkrKykgXG5cdHtcblx0XHR2YXIgbm9mZiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0dmFyIGx1dCA9IFR5cHIuX2xjdGYucmVhZExvb2t1cFRhYmxlKGRhdGEsIG9mZnNldDAgKyBub2ZmLCBzdWJ0KTtcblx0XHRvYmoucHVzaChsdXQpO1xuXHR9XG5cdHJldHVybiBvYmo7XG59O1xuXG5UeXByLl9sY3RmLnJlYWRMb29rdXBUYWJsZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgc3VidClcbntcblx0Ly9jb25zb2xlLmxvZyhcIlBhcnNpbmcgbG9va3VwIHRhYmxlXCIsIG9mZnNldCk7XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdHZhciBvZmZzZXQwID0gb2Zmc2V0O1xuXHR2YXIgb2JqID0ge3RhYnM6W119O1xuXHRcblx0b2JqLmx0eXBlID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0b2JqLmZsYWcgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0dmFyIGNudCAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XG5cdGZvcih2YXIgaT0wOyBpPGNudDsgaSsrKVxuXHR7XG5cdFx0dmFyIG5vZmYgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdHZhciB0YWIgPSBzdWJ0KGRhdGEsIG9iai5sdHlwZSwgb2Zmc2V0MCArIG5vZmYpO1xuXHRcdC8vY29uc29sZS5sb2cob2JqLnR5cGUsIHRhYik7XG5cdFx0b2JqLnRhYnMucHVzaCh0YWIpO1xuXHR9XG5cdHJldHVybiBvYmo7XG59O1xuXG5UeXByLl9sY3RmLm51bU9mT25lcyA9IGZ1bmN0aW9uKG4pXG57XG5cdHZhciBudW0gPSAwO1xuXHRmb3IodmFyIGk9MDsgaTwzMjsgaSsrKSB7IGlmKCgobj4+PmkpJjEpICE9IDApIHsgbnVtKys7IH0gfVxuXHRyZXR1cm4gbnVtO1xufTtcblxuVHlwci5fbGN0Zi5yZWFkQ2xhc3NEZWYgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQpXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdHZhciBvYmogPSBbXTtcblx0dmFyIGZvcm1hdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdGlmKGZvcm1hdD09MSkgXG5cdHtcblx0XHR2YXIgc3RhcnRHbHlwaCAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdHZhciBnbHlwaENvdW50ICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0Zm9yKHZhciBpPTA7IGk8Z2x5cGhDb3VudDsgaSsrKVxuXHRcdHtcblx0XHRcdG9iai5wdXNoKHN0YXJ0R2x5cGgraSk7XG5cdFx0XHRvYmoucHVzaChzdGFydEdseXBoK2kpO1xuXHRcdFx0b2JqLnB1c2goYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KSk7ICBvZmZzZXQrPTI7XG5cdFx0fVxuXHR9XG5cdGlmKGZvcm1hdD09Milcblx0e1xuXHRcdHZhciBjb3VudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0Zm9yKHZhciBpPTA7IGk8Y291bnQ7IGkrKylcblx0XHR7XG5cdFx0XHRvYmoucHVzaChiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9Mjtcblx0XHRcdG9iai5wdXNoKGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCkpOyAgb2Zmc2V0Kz0yO1xuXHRcdFx0b2JqLnB1c2goYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KSk7ICBvZmZzZXQrPTI7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvYmo7XG59O1xuVHlwci5fbGN0Zi5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKHRhYiwgdmFsKVxue1xuXHRmb3IodmFyIGk9MDsgaTx0YWIubGVuZ3RoOyBpKz0zKVxuXHR7XG5cdFx0dmFyIHN0YXJ0ID0gdGFiW2ldLCBlbmQgPSB0YWJbaSsxXSwgaW5kZXggPSB0YWJbaSsyXTtcblx0XHRpZihzdGFydDw9dmFsICYmIHZhbDw9ZW5kKSB7IHJldHVybiBpOyB9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcblxuXG5UeXByLl9sY3RmLnJlYWRDb3ZlcmFnZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbntcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0dmFyIGN2ZyA9IHt9O1xuXHRjdmcuZm10ICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHR2YXIgY291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHQvL2NvbnNvbGUubG9nKFwicGFyc2luZyBjb3ZlcmFnZVwiLCBvZmZzZXQtNCwgZm9ybWF0LCBjb3VudCk7XG5cdGlmKGN2Zy5mbXQ9PTEpIHsgY3ZnLnRhYiA9IGJpbi5yZWFkVXNob3J0cyhkYXRhLCBvZmZzZXQsIGNvdW50KTsgfSBcblx0aWYoY3ZnLmZtdD09MikgeyBjdmcudGFiID0gYmluLnJlYWRVc2hvcnRzKGRhdGEsIG9mZnNldCwgY291bnQqMyk7IH1cblx0cmV0dXJuIGN2Zztcbn07XG5cblR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleCA9IGZ1bmN0aW9uKGN2ZywgdmFsKVxue1xuXHR2YXIgdGFiID0gY3ZnLnRhYjtcblx0aWYoY3ZnLmZtdD09MSkgeyByZXR1cm4gdGFiLmluZGV4T2YodmFsKTsgfVxuXHRpZihjdmcuZm10PT0yKSB7XG5cdFx0dmFyIGluZCA9IFR5cHIuX2xjdGYuZ2V0SW50ZXJ2YWwodGFiLCB2YWwpO1xuXHRcdGlmKGluZCE9LTEpIHsgcmV0dXJuIHRhYltpbmQrMl0gKyAodmFsIC0gdGFiW2luZF0pOyB9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcblxuVHlwci5fbGN0Zi5yZWFkRmVhdHVyZUxpc3QgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQpXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdHZhciBvZmZzZXQwID0gb2Zmc2V0O1xuXHR2YXIgb2JqID0gW107XG5cdFxuXHR2YXIgY291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcblx0Zm9yKHZhciBpPTA7IGk8Y291bnQ7IGkrKylcblx0e1xuXHRcdHZhciB0YWcgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG9mZnNldCwgNCk7ICBvZmZzZXQrPTQ7XG5cdFx0dmFyIG5vZmYgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdG9iai5wdXNoKHt0YWc6IHRhZy50cmltKCksIHRhYjpUeXByLl9sY3RmLnJlYWRGZWF0dXJlVGFibGUoZGF0YSwgb2Zmc2V0MCArIG5vZmYpfSk7XG5cdH1cblx0cmV0dXJuIG9iajtcbn07XG5cblR5cHIuX2xjdGYucmVhZEZlYXR1cmVUYWJsZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbntcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0XG5cdHZhciBmZWF0dXJlUGFyYW1zID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcdC8vID0gMFxuXHR2YXIgbG9va3VwQ291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcblx0dmFyIGluZGljZXMgPSBbXTtcblx0Zm9yKHZhciBpPTA7IGk8bG9va3VwQ291bnQ7IGkrKykgeyBpbmRpY2VzLnB1c2goYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KzIqaSkpOyB9XG5cdHJldHVybiBpbmRpY2VzO1xufTtcblxuXG5UeXByLl9sY3RmLnJlYWRTY3JpcHRMaXN0ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgb2Zmc2V0MCA9IG9mZnNldDtcblx0dmFyIG9iaiA9IHt9O1xuXHRcblx0dmFyIGNvdW50ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XG5cdGZvcih2YXIgaT0wOyBpPGNvdW50OyBpKyspXG5cdHtcblx0XHR2YXIgdGFnID0gYmluLnJlYWRBU0NJSShkYXRhLCBvZmZzZXQsIDQpOyAgb2Zmc2V0Kz00O1xuXHRcdHZhciBub2ZmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XHRvYmpbdGFnLnRyaW0oKV0gPSBUeXByLl9sY3RmLnJlYWRTY3JpcHRUYWJsZShkYXRhLCBvZmZzZXQwICsgbm9mZik7XG5cdH1cblx0cmV0dXJuIG9iajtcbn07XG5cblR5cHIuX2xjdGYucmVhZFNjcmlwdFRhYmxlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgb2Zmc2V0MCA9IG9mZnNldDtcblx0dmFyIG9iaiA9IHt9O1xuXHRcblx0dmFyIGRlZkxhbmdTeXNPZmYgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRvYmouZGVmYXVsdCA9IFR5cHIuX2xjdGYucmVhZExhbmdTeXNUYWJsZShkYXRhLCBvZmZzZXQwICsgZGVmTGFuZ1N5c09mZik7XG5cdFxuXHR2YXIgbGFuZ1N5c0NvdW50ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XG5cdGZvcih2YXIgaT0wOyBpPGxhbmdTeXNDb3VudDsgaSsrKVxuXHR7XG5cdFx0dmFyIHRhZyA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2Zmc2V0LCA0KTsgIG9mZnNldCs9NDtcblx0XHR2YXIgbGFuZ1N5c09mZiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0b2JqW3RhZy50cmltKCldID0gVHlwci5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlKGRhdGEsIG9mZnNldDAgKyBsYW5nU3lzT2ZmKTtcblx0fVxuXHRyZXR1cm4gb2JqO1xufTtcblxuVHlwci5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgb2JqID0ge307XG5cdFxuXHR2YXIgbG9va3VwT3JkZXIgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHQvL2lmKGxvb2t1cE9yZGVyIT0wKSAgdGhyb3cgXCJsb29rdXBPcmRlciBub3QgMFwiO1xuXHRvYmoucmVxRmVhdHVyZSA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdC8vaWYob2JqLnJlcUZlYXR1cmUgIT0gMHhmZmZmKSB0aHJvdyBcInJlcUZlYXR1cmVJbmRleCAhPSAweGZmZmZcIjtcblx0XG5cdC8vY29uc29sZS5sb2cobG9va3VwT3JkZXIsIG9iai5yZXFGZWF0dXJlKTtcblx0XG5cdHZhciBmZWF0dXJlQ291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRvYmouZmVhdHVyZXMgPSBiaW4ucmVhZFVzaG9ydHMoZGF0YSwgb2Zmc2V0LCBmZWF0dXJlQ291bnQpO1xuXHRyZXR1cm4gb2JqO1xufTtcblxuXHRUeXByLkNGRiA9IHt9O1xuXHRUeXByLkNGRi5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoKVxuXHR7XG5cdFx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0XHRcblx0XHRkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcblx0XHRvZmZzZXQgPSAwO1xuXHRcdFxuXHRcdC8vIEhlYWRlclxuXHRcdHZhciBtYWpvciA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xuXHRcdHZhciBtaW5vciA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xuXHRcdHZhciBoZHJTaXplID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG5cdFx0dmFyIG9mZnNpemUgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcblx0XHQvL2NvbnNvbGUubG9nKG1ham9yLCBtaW5vciwgaGRyU2l6ZSwgb2Zmc2l6ZSk7XG5cdFx0XG5cdFx0Ly8gTmFtZSBJTkRFWFxuXHRcdHZhciBuaW5kcyA9IFtdO1xuXHRcdG9mZnNldCA9IFR5cHIuQ0ZGLnJlYWRJbmRleChkYXRhLCBvZmZzZXQsIG5pbmRzKTtcblx0XHR2YXIgbmFtZXMgPSBbXTtcblx0XHRcblx0XHRmb3IodmFyIGk9MDsgaTxuaW5kcy5sZW5ndGgtMTsgaSsrKSB7IG5hbWVzLnB1c2goYmluLnJlYWRBU0NJSShkYXRhLCBvZmZzZXQrbmluZHNbaV0sIG5pbmRzW2krMV0tbmluZHNbaV0pKTsgfVxuXHRcdG9mZnNldCArPSBuaW5kc1tuaW5kcy5sZW5ndGgtMV07XG5cdFx0XG5cdFx0XG5cdFx0Ly8gVG9wIERJQ1QgSU5ERVhcblx0XHR2YXIgdGRpbmRzID0gW107XG5cdFx0b2Zmc2V0ID0gVHlwci5DRkYucmVhZEluZGV4KGRhdGEsIG9mZnNldCwgdGRpbmRzKTsgIC8vY29uc29sZS5sb2codGRpbmRzKTtcblx0XHQvLyBUb3AgRElDVCBEYXRhXG5cdFx0dmFyIHRvcERpY3RzID0gW107XG5cdFx0Zm9yKHZhciBpPTA7IGk8dGRpbmRzLmxlbmd0aC0xOyBpKyspIHsgdG9wRGljdHMucHVzaCggVHlwci5DRkYucmVhZERpY3QoZGF0YSwgb2Zmc2V0K3RkaW5kc1tpXSwgb2Zmc2V0K3RkaW5kc1tpKzFdKSApOyB9XG5cdFx0b2Zmc2V0ICs9IHRkaW5kc1t0ZGluZHMubGVuZ3RoLTFdO1xuXHRcdHZhciB0b3BkaWN0ID0gdG9wRGljdHNbMF07XG5cdFx0Ly9jb25zb2xlLmxvZyh0b3BkaWN0KTtcblx0XHRcblx0XHQvLyBTdHJpbmcgSU5ERVhcblx0XHR2YXIgc2luZHMgPSBbXTtcblx0XHRvZmZzZXQgPSBUeXByLkNGRi5yZWFkSW5kZXgoZGF0YSwgb2Zmc2V0LCBzaW5kcyk7XG5cdFx0Ly8gU3RyaW5nIERhdGFcblx0XHR2YXIgc3RyaW5ncyA9IFtdO1xuXHRcdGZvcih2YXIgaT0wOyBpPHNpbmRzLmxlbmd0aC0xOyBpKyspIHsgc3RyaW5ncy5wdXNoKGJpbi5yZWFkQVNDSUkoZGF0YSwgb2Zmc2V0K3NpbmRzW2ldLCBzaW5kc1tpKzFdLXNpbmRzW2ldKSk7IH1cblx0XHRvZmZzZXQgKz0gc2luZHNbc2luZHMubGVuZ3RoLTFdO1xuXHRcdFxuXHRcdC8vIEdsb2JhbCBTdWJyIElOREVYICAoc3Vicm91dGluZXMpXHRcdFxuXHRcdFR5cHIuQ0ZGLnJlYWRTdWJycyhkYXRhLCBvZmZzZXQsIHRvcGRpY3QpO1xuXHRcdFxuXHRcdC8vIGNoYXJzdHJpbmdzXG5cdFx0aWYodG9wZGljdC5DaGFyU3RyaW5ncylcblx0XHR7XG5cdFx0XHRvZmZzZXQgPSB0b3BkaWN0LkNoYXJTdHJpbmdzO1xuXHRcdFx0dmFyIHNpbmRzID0gW107XG5cdFx0XHRvZmZzZXQgPSBUeXByLkNGRi5yZWFkSW5kZXgoZGF0YSwgb2Zmc2V0LCBzaW5kcyk7XG5cdFx0XHRcblx0XHRcdHZhciBjc3RyID0gW107XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxzaW5kcy5sZW5ndGgtMTsgaSsrKSB7IGNzdHIucHVzaChiaW4ucmVhZEJ5dGVzKGRhdGEsIG9mZnNldCtzaW5kc1tpXSwgc2luZHNbaSsxXS1zaW5kc1tpXSkpOyB9XG5cdFx0XHQvL29mZnNldCArPSBzaW5kc1tzaW5kcy5sZW5ndGgtMV07XG5cdFx0XHR0b3BkaWN0LkNoYXJTdHJpbmdzID0gY3N0cjtcblx0XHRcdC8vY29uc29sZS5sb2codG9wZGljdC5DaGFyU3RyaW5ncyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIENJRCBmb250XG5cdFx0aWYodG9wZGljdC5ST1MpIHtcblx0XHRcdG9mZnNldCA9IHRvcGRpY3QuRkRBcnJheTtcblx0XHRcdHZhciBmZGluZCA9IFtdO1xuXHRcdFx0b2Zmc2V0ID0gVHlwci5DRkYucmVhZEluZGV4KGRhdGEsIG9mZnNldCwgZmRpbmQpO1xuXHRcdFx0XG5cdFx0XHR0b3BkaWN0LkZEQXJyYXkgPSBbXTtcblx0XHRcdGZvcih2YXIgaT0wOyBpPGZkaW5kLmxlbmd0aC0xOyBpKyspIHtcblx0XHRcdFx0dmFyIGRpY3QgPSBUeXByLkNGRi5yZWFkRGljdChkYXRhLCBvZmZzZXQrZmRpbmRbaV0sIG9mZnNldCtmZGluZFtpKzFdKTtcblx0XHRcdFx0VHlwci5DRkYuX3JlYWRGRGljdChkYXRhLCBkaWN0LCBzdHJpbmdzKTtcblx0XHRcdFx0dG9wZGljdC5GREFycmF5LnB1c2goIGRpY3QgKTtcblx0XHRcdH1cblx0XHRcdG9mZnNldCArPSBmZGluZFtmZGluZC5sZW5ndGgtMV07XG5cdFx0XHRcblx0XHRcdG9mZnNldCA9IHRvcGRpY3QuRkRTZWxlY3Q7XG5cdFx0XHR0b3BkaWN0LkZEU2VsZWN0ID0gW107XG5cdFx0XHR2YXIgZm10ID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG5cdFx0XHRpZihmbXQ9PTMpIHtcblx0XHRcdFx0dmFyIHJucyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0XHRcdGZvcih2YXIgaT0wOyBpPHJucysxOyBpKyspIHtcblx0XHRcdFx0XHR0b3BkaWN0LkZEU2VsZWN0LnB1c2goYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KSwgZGF0YVtvZmZzZXQrMl0pOyAgb2Zmc2V0Kz0zO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgdGhyb3cgZm10OyB9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEVuY29kaW5nXG5cdFx0aWYodG9wZGljdC5FbmNvZGluZykgeyB0b3BkaWN0LkVuY29kaW5nID0gVHlwci5DRkYucmVhZEVuY29kaW5nKGRhdGEsIHRvcGRpY3QuRW5jb2RpbmcsIHRvcGRpY3QuQ2hhclN0cmluZ3MubGVuZ3RoKTsgfVxuXHRcdFxuXHRcdC8vIGNoYXJzZXRcblx0XHRpZih0b3BkaWN0LmNoYXJzZXQgKSB7IHRvcGRpY3QuY2hhcnNldCAgPSBUeXByLkNGRi5yZWFkQ2hhcnNldCAoZGF0YSwgdG9wZGljdC5jaGFyc2V0ICwgdG9wZGljdC5DaGFyU3RyaW5ncy5sZW5ndGgpOyB9XG5cdFx0XG5cdFx0VHlwci5DRkYuX3JlYWRGRGljdChkYXRhLCB0b3BkaWN0LCBzdHJpbmdzKTtcblx0XHRyZXR1cm4gdG9wZGljdDtcblx0fTtcblx0VHlwci5DRkYuX3JlYWRGRGljdCA9IGZ1bmN0aW9uKGRhdGEsIGRpY3QsIHNzKSB7XG5cdFx0dmFyIG9mZnNldDtcblx0XHRpZihkaWN0LlByaXZhdGUpIHtcblx0XHRcdG9mZnNldCA9IGRpY3QuUHJpdmF0ZVsxXTtcblx0XHRcdGRpY3QuUHJpdmF0ZSA9IFR5cHIuQ0ZGLnJlYWREaWN0KGRhdGEsIG9mZnNldCwgb2Zmc2V0K2RpY3QuUHJpdmF0ZVswXSk7XG5cdFx0XHRpZihkaWN0LlByaXZhdGUuU3VicnMpICB7IFR5cHIuQ0ZGLnJlYWRTdWJycyhkYXRhLCBvZmZzZXQrZGljdC5Qcml2YXRlLlN1YnJzLCBkaWN0LlByaXZhdGUpOyB9XG5cdFx0fVxuXHRcdGZvcih2YXIgcCBpbiBkaWN0KSB7IGlmKFtcIkZhbWlseU5hbWVcIixcIkZvbnROYW1lXCIsXCJGdWxsTmFtZVwiLFwiTm90aWNlXCIsXCJ2ZXJzaW9uXCIsXCJDb3B5cmlnaHRcIl0uaW5kZXhPZihwKSE9LTEpICB7IGRpY3RbcF09c3NbZGljdFtwXSAtNDI2ICsgMzVdOyB9IH1cblx0fTtcblx0XG5cdFR5cHIuQ0ZGLnJlYWRTdWJycyA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgb2JqKVxuXHR7XG5cdFx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0XHR2YXIgZ3N1YmluZHMgPSBbXTtcblx0XHRvZmZzZXQgPSBUeXByLkNGRi5yZWFkSW5kZXgoZGF0YSwgb2Zmc2V0LCBnc3ViaW5kcyk7XG5cdFx0XG5cdFx0dmFyIGJpYXMsIG5TdWJycyA9IGdzdWJpbmRzLmxlbmd0aDtcblx0XHRpZiAoblN1YnJzIDwgIDEyNDApIHsgYmlhcyA9IDEwNzsgfVxuXHRcdGVsc2UgaWYgKG5TdWJycyA8IDMzOTAwKSB7IGJpYXMgPSAxMTMxOyB9XG5cdFx0ZWxzZSB7IGJpYXMgPSAzMjc2ODsgfVxuXHRcdG9iai5CaWFzID0gYmlhcztcblx0XHRcblx0XHRvYmouU3VicnMgPSBbXTtcblx0XHRmb3IodmFyIGk9MDsgaTxnc3ViaW5kcy5sZW5ndGgtMTsgaSsrKSB7IG9iai5TdWJycy5wdXNoKGJpbi5yZWFkQnl0ZXMoZGF0YSwgb2Zmc2V0K2dzdWJpbmRzW2ldLCBnc3ViaW5kc1tpKzFdLWdzdWJpbmRzW2ldKSk7IH1cblx0XHQvL29mZnNldCArPSBnc3ViaW5kc1tnc3ViaW5kcy5sZW5ndGgtMV07XG5cdH07XG5cdFxuXHRUeXByLkNGRi50YWJsZVNFID0gW1xuICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMSwgICAyLCAgIDMsICAgNCwgICA1LCAgIDYsICAgNywgICA4LFxuICAgICAgOSwgIDEwLCAgMTEsICAxMiwgIDEzLCAgMTQsICAxNSwgIDE2LFxuICAgICAxNywgIDE4LCAgMTksICAyMCwgIDIxLCAgMjIsICAyMywgIDI0LFxuICAgICAyNSwgIDI2LCAgMjcsICAyOCwgIDI5LCAgMzAsICAzMSwgIDMyLFxuICAgICAzMywgIDM0LCAgMzUsICAzNiwgIDM3LCAgMzgsICAzOSwgIDQwLFxuICAgICA0MSwgIDQyLCAgNDMsICA0NCwgIDQ1LCAgNDYsICA0NywgIDQ4LFxuICAgICA0OSwgIDUwLCAgNTEsICA1MiwgIDUzLCAgNTQsICA1NSwgIDU2LFxuICAgICA1NywgIDU4LCAgNTksICA2MCwgIDYxLCAgNjIsICA2MywgIDY0LFxuICAgICA2NSwgIDY2LCAgNjcsICA2OCwgIDY5LCAgNzAsICA3MSwgIDcyLFxuICAgICA3MywgIDc0LCAgNzUsICA3NiwgIDc3LCAgNzgsICA3OSwgIDgwLFxuICAgICA4MSwgIDgyLCAgODMsICA4NCwgIDg1LCAgODYsICA4NywgIDg4LFxuICAgICA4OSwgIDkwLCAgOTEsICA5MiwgIDkzLCAgOTQsICA5NSwgICAwLFxuICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMCwgIDk2LCAgOTcsICA5OCwgIDk5LCAxMDAsIDEwMSwgMTAyLFxuICAgIDEwMywgMTA0LCAxMDUsIDEwNiwgMTA3LCAxMDgsIDEwOSwgMTEwLFxuICAgICAgMCwgMTExLCAxMTIsIDExMywgMTE0LCAgIDAsIDExNSwgMTE2LFxuICAgIDExNywgMTE4LCAxMTksIDEyMCwgMTIxLCAxMjIsICAgMCwgMTIzLFxuICAgICAgMCwgMTI0LCAxMjUsIDEyNiwgMTI3LCAxMjgsIDEyOSwgMTMwLFxuICAgIDEzMSwgICAwLCAxMzIsIDEzMywgICAwLCAxMzQsIDEzNSwgMTM2LFxuICAgIDEzNywgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMCwgMTM4LCAgIDAsIDEzOSwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgIDE0MCwgMTQxLCAxNDIsIDE0MywgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgMCwgMTQ0LCAgIDAsICAgMCwgICAwLCAxNDUsICAgMCwgICAwLFxuICAgIDE0NiwgMTQ3LCAxNDgsIDE0OSwgICAwLCAgIDAsICAgMCwgICAwXG4gIF07XG4gIFxuXHRUeXByLkNGRi5nbHlwaEJ5VW5pY29kZSA9IGZ1bmN0aW9uKGNmZiwgY29kZSlcblx0e1xuXHRcdGZvcih2YXIgaT0wOyBpPGNmZi5jaGFyc2V0Lmxlbmd0aDsgaSsrKSB7IGlmKGNmZi5jaGFyc2V0W2ldPT1jb2RlKSB7IHJldHVybiBpOyB9IH1cblx0XHRyZXR1cm4gLTE7XG5cdH07XG5cdFxuXHRUeXByLkNGRi5nbHlwaEJ5U0UgPSBmdW5jdGlvbihjZmYsIGNoYXJjb2RlKVx0Ly8gZ2x5cGggYnkgc3RhbmRhcmQgZW5jb2Rpbmdcblx0e1xuXHRcdGlmICggY2hhcmNvZGUgPCAwIHx8IGNoYXJjb2RlID4gMjU1ICkgeyByZXR1cm4gLTE7IH1cblx0XHRyZXR1cm4gVHlwci5DRkYuZ2x5cGhCeVVuaWNvZGUoY2ZmLCBUeXByLkNGRi50YWJsZVNFW2NoYXJjb2RlXSk7XHRcdFxuXHR9O1xuXHRcblx0VHlwci5DRkYucmVhZEVuY29kaW5nID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBudW0pXG5cdHtcblx0XHR2YXIgYmluID0gVHlwci5fYmluO1xuXHRcdFxuXHRcdHZhciBhcnJheSA9IFsnLm5vdGRlZiddO1xuXHRcdHZhciBmb3JtYXQgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcblx0XHQvL2NvbnNvbGUubG9nKFwiRW5jb2RpbmdcIik7XG5cdFx0Ly9jb25zb2xlLmxvZyhmb3JtYXQpO1xuXHRcdFxuXHRcdGlmKGZvcm1hdD09MClcblx0XHR7XG5cdFx0XHR2YXIgbkNvZGVzID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxuQ29kZXM7IGkrKykgIHsgYXJyYXkucHVzaChkYXRhW29mZnNldCtpXSk7IH1cblx0XHR9XG5cdFx0Lypcblx0XHRlbHNlIGlmKGZvcm1hdD09MSB8fCBmb3JtYXQ9PTIpXG5cdFx0e1xuXHRcdFx0d2hpbGUoY2hhcnNldC5sZW5ndGg8bnVtKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZmlyc3QgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdFx0XHR2YXIgbkxlZnQ9MDtcblx0XHRcdFx0aWYoZm9ybWF0PT0xKSB7ICBuTGVmdCA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrOyAgfVxuXHRcdFx0XHRlbHNlICAgICAgICAgIHsgIG5MZWZ0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjsgIH1cblx0XHRcdFx0Zm9yKHZhciBpPTA7IGk8PW5MZWZ0OyBpKyspICB7ICBjaGFyc2V0LnB1c2goZmlyc3QpOyAgZmlyc3QrKzsgIH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ki9cblx0XHRlbHNlIHsgdGhyb3cgXCJlcnJvcjogdW5rbm93biBlbmNvZGluZyBmb3JtYXQ6IFwiICsgZm9ybWF0OyB9XG5cdFx0XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9O1xuXG5cdFR5cHIuQ0ZGLnJlYWRDaGFyc2V0ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBudW0pXG5cdHtcblx0XHR2YXIgYmluID0gVHlwci5fYmluO1xuXHRcdFxuXHRcdHZhciBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cdFx0dmFyIGZvcm1hdCA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xuXHRcdFxuXHRcdGlmKGZvcm1hdD09MClcblx0XHR7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxudW07IGkrKykgXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBmaXJzdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0XHRcdGNoYXJzZXQucHVzaChmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYoZm9ybWF0PT0xIHx8IGZvcm1hdD09Milcblx0XHR7XG5cdFx0XHR3aGlsZShjaGFyc2V0Lmxlbmd0aDxudW0pXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBmaXJzdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0XHRcdHZhciBuTGVmdD0wO1xuXHRcdFx0XHRpZihmb3JtYXQ9PTEpIHsgIG5MZWZ0ID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7ICB9XG5cdFx0XHRcdGVsc2UgICAgICAgICAgeyAgbkxlZnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yOyAgfVxuXHRcdFx0XHRmb3IodmFyIGk9MDsgaTw9bkxlZnQ7IGkrKykgIHsgIGNoYXJzZXQucHVzaChmaXJzdCk7ICBmaXJzdCsrOyAgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHsgdGhyb3cgXCJlcnJvcjogZm9ybWF0OiBcIiArIGZvcm1hdDsgfVxuXHRcdFxuXHRcdHJldHVybiBjaGFyc2V0O1xuXHR9O1xuXG5cdFR5cHIuQ0ZGLnJlYWRJbmRleCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgaW5kcylcblx0e1xuXHRcdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdFx0XG5cdFx0dmFyIGNvdW50ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KSsxOyAgb2Zmc2V0Kz0yO1xuXHRcdHZhciBvZmZzaXplID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG5cdFx0XG5cdFx0aWYgICAgIChvZmZzaXplPT0xKSB7IGZvcih2YXIgaT0wOyBpPGNvdW50OyBpKyspIHsgaW5kcy5wdXNoKCBkYXRhW29mZnNldCtpXSApOyB9IH1cblx0XHRlbHNlIGlmKG9mZnNpemU9PTIpIHsgZm9yKHZhciBpPTA7IGk8Y291bnQ7IGkrKykgeyBpbmRzLnB1c2goIGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCtpKjIpICk7IH0gfVxuXHRcdGVsc2UgaWYob2Zmc2l6ZT09MykgeyBmb3IodmFyIGk9MDsgaTxjb3VudDsgaSsrKSB7IGluZHMucHVzaCggYmluLnJlYWRVaW50ICAoZGF0YSwgb2Zmc2V0K2kqMyAtIDEpICYgMHgwMGZmZmZmZiApOyB9IH1cblx0XHRlbHNlIGlmKGNvdW50IT0xKSB7IHRocm93IFwidW5zdXBwb3J0ZWQgb2Zmc2V0IHNpemU6IFwiICsgb2Zmc2l6ZSArIFwiLCBjb3VudDogXCIgKyBjb3VudDsgfVxuXHRcdFxuXHRcdG9mZnNldCArPSBjb3VudCpvZmZzaXplO1xuXHRcdHJldHVybiBvZmZzZXQtMTtcblx0fTtcblx0XG5cdFR5cHIuQ0ZGLmdldENoYXJTdHJpbmcgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG8pXG5cdHtcblx0XHR2YXIgYmluID0gVHlwci5fYmluO1xuXHRcdFxuXHRcdHZhciBiMCA9IGRhdGFbb2Zmc2V0XSwgYjEgPSBkYXRhW29mZnNldCsxXSwgYjIgPSBkYXRhW29mZnNldCsyXSwgYjMgPSBkYXRhW29mZnNldCszXSwgYjQ9ZGF0YVtvZmZzZXQrNF07XG5cdFx0dmFyIHZzID0gMTtcblx0XHR2YXIgb3A9bnVsbCwgdmFsPW51bGw7XG5cdFx0Ly8gb3BlcmFuZFxuXHRcdGlmKGIwPD0yMCkgeyBvcCA9IGIwOyAgdnM9MTsgIH1cblx0XHRpZihiMD09MTIpIHsgb3AgPSBiMCoxMDArYjE7ICB2cz0yOyAgfVxuXHRcdC8vaWYoYjA9PTE5IHx8IGIwPT0yMCkgeyBvcCA9IGIwLyorXCIgXCIrYjEqLzsgIHZzPTI7IH1cblx0XHRpZigyMSA8PWIwICYmIGIwPD0gMjcpIHsgb3AgPSBiMDsgIHZzPTE7IH1cblx0XHRpZihiMD09MjgpIHsgdmFsID0gYmluLnJlYWRTaG9ydChkYXRhLG9mZnNldCsxKTsgIHZzPTM7IH1cblx0XHRpZigyOSA8PWIwICYmIGIwPD0gMzEpIHsgb3AgPSBiMDsgIHZzPTE7IH1cblx0XHRpZigzMiA8PWIwICYmIGIwPD0yNDYpIHsgdmFsID0gYjAtMTM5OyAgdnM9MTsgfVxuXHRcdGlmKDI0Nzw9YjAgJiYgYjA8PTI1MCkgeyB2YWwgPSAoYjAtMjQ3KSoyNTYrYjErMTA4OyAgdnM9MjsgfVxuXHRcdGlmKDI1MTw9YjAgJiYgYjA8PTI1NCkgeyB2YWwgPS0oYjAtMjUxKSoyNTYtYjEtMTA4OyAgdnM9MjsgfVxuXHRcdGlmKGIwPT0yNTUpIHsgIHZhbCA9IGJpbi5yZWFkSW50KGRhdGEsIG9mZnNldCsxKS8weGZmZmY7ICB2cz01OyAgIH1cblx0XHRcblx0XHRvLnZhbCA9IHZhbCE9bnVsbCA/IHZhbCA6IFwib1wiK29wO1xuXHRcdG8uc2l6ZSA9IHZzO1xuXHR9O1xuXHRcblx0VHlwci5DRkYucmVhZENoYXJTdHJpbmcgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aClcblx0e1xuXHRcdHZhciBlbmQgPSBvZmZzZXQgKyBsZW5ndGg7XG5cdFx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0XHR2YXIgYXJyID0gW107XG5cdFx0XG5cdFx0d2hpbGUob2Zmc2V0PGVuZClcblx0XHR7XG5cdFx0XHR2YXIgYjAgPSBkYXRhW29mZnNldF0sIGIxID0gZGF0YVtvZmZzZXQrMV0sIGIyID0gZGF0YVtvZmZzZXQrMl0sIGIzID0gZGF0YVtvZmZzZXQrM10sIGI0PWRhdGFbb2Zmc2V0KzRdO1xuXHRcdFx0dmFyIHZzID0gMTtcblx0XHRcdHZhciBvcD1udWxsLCB2YWw9bnVsbDtcblx0XHRcdC8vIG9wZXJhbmRcblx0XHRcdGlmKGIwPD0yMCkgeyBvcCA9IGIwOyAgdnM9MTsgIH1cblx0XHRcdGlmKGIwPT0xMikgeyBvcCA9IGIwKjEwMCtiMTsgIHZzPTI7ICB9XG5cdFx0XHRpZihiMD09MTkgfHwgYjA9PTIwKSB7IG9wID0gYjAvKitcIiBcIitiMSovOyAgdnM9MjsgfVxuXHRcdFx0aWYoMjEgPD1iMCAmJiBiMDw9IDI3KSB7IG9wID0gYjA7ICB2cz0xOyB9XG5cdFx0XHRpZihiMD09MjgpIHsgdmFsID0gYmluLnJlYWRTaG9ydChkYXRhLG9mZnNldCsxKTsgIHZzPTM7IH1cblx0XHRcdGlmKDI5IDw9YjAgJiYgYjA8PSAzMSkgeyBvcCA9IGIwOyAgdnM9MTsgfVxuXHRcdFx0aWYoMzIgPD1iMCAmJiBiMDw9MjQ2KSB7IHZhbCA9IGIwLTEzOTsgIHZzPTE7IH1cblx0XHRcdGlmKDI0Nzw9YjAgJiYgYjA8PTI1MCkgeyB2YWwgPSAoYjAtMjQ3KSoyNTYrYjErMTA4OyAgdnM9MjsgfVxuXHRcdFx0aWYoMjUxPD1iMCAmJiBiMDw9MjU0KSB7IHZhbCA9LShiMC0yNTEpKjI1Ni1iMS0xMDg7ICB2cz0yOyB9XG5cdFx0XHRpZihiMD09MjU1KSB7ICB2YWwgPSBiaW4ucmVhZEludChkYXRhLCBvZmZzZXQrMSkvMHhmZmZmOyAgdnM9NTsgICB9XG5cdFx0XHRcblx0XHRcdGFyci5wdXNoKHZhbCE9bnVsbCA/IHZhbCA6IFwib1wiK29wKTtcblx0XHRcdG9mZnNldCArPSB2cztcdFxuXG5cdFx0XHQvL3ZhciBjdiA9IGFyclthcnIubGVuZ3RoLTFdO1xuXHRcdFx0Ly9pZihjdj09dW5kZWZpbmVkKSB0aHJvdyBcImVycm9yXCI7XG5cdFx0XHQvL2NvbnNvbGUubG9nKClcblx0XHR9XHRcblx0XHRyZXR1cm4gYXJyO1xuXHR9O1xuXG5cdFR5cHIuQ0ZGLnJlYWREaWN0ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBlbmQpXG5cdHtcblx0XHR2YXIgYmluID0gVHlwci5fYmluO1xuXHRcdC8vdmFyIGRpY3QgPSBbXTtcblx0XHR2YXIgZGljdCA9IHt9O1xuXHRcdHZhciBjYXJyID0gW107XG5cdFx0XG5cdFx0d2hpbGUob2Zmc2V0PGVuZClcblx0XHR7XG5cdFx0XHR2YXIgYjAgPSBkYXRhW29mZnNldF0sIGIxID0gZGF0YVtvZmZzZXQrMV0sIGIyID0gZGF0YVtvZmZzZXQrMl0sIGIzID0gZGF0YVtvZmZzZXQrM10sIGI0PWRhdGFbb2Zmc2V0KzRdO1xuXHRcdFx0dmFyIHZzID0gMTtcblx0XHRcdHZhciBrZXk9bnVsbCwgdmFsPW51bGw7XG5cdFx0XHQvLyBvcGVyYW5kXG5cdFx0XHRpZihiMD09MjgpIHsgdmFsID0gYmluLnJlYWRTaG9ydChkYXRhLG9mZnNldCsxKTsgIHZzPTM7IH1cblx0XHRcdGlmKGIwPT0yOSkgeyB2YWwgPSBiaW4ucmVhZEludCAgKGRhdGEsb2Zmc2V0KzEpOyAgdnM9NTsgfVxuXHRcdFx0aWYoMzIgPD1iMCAmJiBiMDw9MjQ2KSB7IHZhbCA9IGIwLTEzOTsgIHZzPTE7IH1cblx0XHRcdGlmKDI0Nzw9YjAgJiYgYjA8PTI1MCkgeyB2YWwgPSAoYjAtMjQ3KSoyNTYrYjErMTA4OyAgdnM9MjsgfVxuXHRcdFx0aWYoMjUxPD1iMCAmJiBiMDw9MjU0KSB7IHZhbCA9LShiMC0yNTEpKjI1Ni1iMS0xMDg7ICB2cz0yOyB9XG5cdFx0XHRpZihiMD09MjU1KSB7ICB2YWwgPSBiaW4ucmVhZEludChkYXRhLCBvZmZzZXQrMSkvMHhmZmZmOyAgdnM9NTsgIHRocm93IFwidW5rbm93biBudW1iZXJcIjsgIH1cblx0XHRcdFxuXHRcdFx0aWYoYjA9PTMwKSBcblx0XHRcdHsgIFxuXHRcdFx0XHR2YXIgbmlicyA9IFtdO1xuXHRcdFx0XHR2cyA9IDE7XG5cdFx0XHRcdHdoaWxlKHRydWUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgYiA9IGRhdGFbb2Zmc2V0K3ZzXTsgIHZzKys7XG5cdFx0XHRcdFx0dmFyIG5pYjAgPSBiPj40LCBuaWIxID0gYiYweGY7XG5cdFx0XHRcdFx0aWYobmliMCAhPSAweGYpIHsgbmlicy5wdXNoKG5pYjApOyB9ICBpZihuaWIxIT0weGYpIHsgbmlicy5wdXNoKG5pYjEpOyB9XG5cdFx0XHRcdFx0aWYobmliMT09MHhmKSB7IGJyZWFrOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHMgPSBcIlwiO1xuXHRcdFx0XHR2YXIgY2hhcnMgPSBbMCwxLDIsMyw0LDUsNiw3LDgsOSxcIi5cIixcImVcIixcImUtXCIsXCJyZXNlcnZlZFwiLFwiLVwiLFwiZW5kT2ZOdW1iZXJcIl07XG5cdFx0XHRcdGZvcih2YXIgaT0wOyBpPG5pYnMubGVuZ3RoOyBpKyspIHsgcyArPSBjaGFyc1tuaWJzW2ldXTsgfVxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKG5pYnMpO1xuXHRcdFx0XHR2YWwgPSBwYXJzZUZsb2F0KHMpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZihiMDw9MjEpXHQvLyBvcGVyYXRvclxuXHRcdFx0e1xuXHRcdFx0XHR2YXIga2V5cyA9IFtcInZlcnNpb25cIiwgXCJOb3RpY2VcIiwgXCJGdWxsTmFtZVwiLCBcIkZhbWlseU5hbWVcIiwgXCJXZWlnaHRcIiwgXCJGb250QkJveFwiLCBcIkJsdWVWYWx1ZXNcIiwgXCJPdGhlckJsdWVzXCIsIFwiRmFtaWx5Qmx1ZXNcIixcIkZhbWlseU90aGVyQmx1ZXNcIixcblx0XHRcdFx0XHRcIlN0ZEhXXCIsIFwiU3RkVldcIiwgXCJlc2NhcGVcIiwgXCJVbmlxdWVJRFwiLCBcIlhVSURcIiwgXCJjaGFyc2V0XCIsIFwiRW5jb2RpbmdcIiwgXCJDaGFyU3RyaW5nc1wiLCBcIlByaXZhdGVcIiwgXCJTdWJyc1wiLCBcblx0XHRcdFx0XHRcImRlZmF1bHRXaWR0aFhcIiwgXCJub21pbmFsV2lkdGhYXCJdO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRrZXkgPSBrZXlzW2IwXTsgIHZzPTE7XG5cdFx0XHRcdGlmKGIwPT0xMikgeyBcblx0XHRcdFx0XHR2YXIga2V5cyA9IFsgXCJDb3B5cmlnaHRcIiwgXCJpc0ZpeGVkUGl0Y2hcIiwgXCJJdGFsaWNBbmdsZVwiLCBcIlVuZGVybGluZVBvc2l0aW9uXCIsIFwiVW5kZXJsaW5lVGhpY2tuZXNzXCIsIFwiUGFpbnRUeXBlXCIsIFwiQ2hhcnN0cmluZ1R5cGVcIiwgXCJGb250TWF0cml4XCIsIFwiU3Ryb2tlV2lkdGhcIiwgXCJCbHVlU2NhbGVcIixcblx0XHRcdFx0XHRcIkJsdWVTaGlmdFwiLCBcIkJsdWVGdXp6XCIsIFwiU3RlbVNuYXBIXCIsIFwiU3RlbVNuYXBWXCIsIFwiRm9yY2VCb2xkXCIsIDAsMCwgXCJMYW5ndWFnZUdyb3VwXCIsIFwiRXhwYW5zaW9uRmFjdG9yXCIsIFwiaW5pdGlhbFJhbmRvbVNlZWRcIixcblx0XHRcdFx0XHRcIlN5bnRoZXRpY0Jhc2VcIiwgXCJQb3N0U2NyaXB0XCIsIFwiQmFzZUZvbnROYW1lXCIsIFwiQmFzZUZvbnRCbGVuZFwiLCAwLDAsMCwwLDAsMCwgXG5cdFx0XHRcdFx0XCJST1NcIiwgXCJDSURGb250VmVyc2lvblwiLCBcIkNJREZvbnRSZXZpc2lvblwiLCBcIkNJREZvbnRUeXBlXCIsIFwiQ0lEQ291bnRcIiwgXCJVSURCYXNlXCIsIFwiRkRBcnJheVwiLCBcIkZEU2VsZWN0XCIsIFwiRm9udE5hbWVcIl07XG5cdFx0XHRcdFx0a2V5ID0ga2V5c1tiMV07ICB2cz0yOyBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZihrZXkhPW51bGwpIHsgIGRpY3Rba2V5XSA9IGNhcnIubGVuZ3RoPT0xID8gY2FyclswXSA6IGNhcnI7ICBjYXJyPVtdOyB9XG5cdFx0XHRlbHNlICB7IGNhcnIucHVzaCh2YWwpOyB9ICBcblx0XHRcdFxuXHRcdFx0b2Zmc2V0ICs9IHZzO1x0XHRcblx0XHR9XHRcblx0XHRyZXR1cm4gZGljdDtcblx0fTtcblxuXG5UeXByLmNtYXAgPSB7fTtcblR5cHIuY21hcC5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoKVxue1xuXHRkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcblx0b2Zmc2V0ID0gMDtcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgdmVyc2lvbiAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHR2YXIgbnVtVGFibGVzID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcblx0Ly9jb25zb2xlLmxvZyh2ZXJzaW9uLCBudW1UYWJsZXMpO1xuXHRcblx0dmFyIG9mZnMgPSBbXTtcblx0b2JqLnRhYmxlcyA9IFtdO1xuXHRcblx0XG5cdGZvcih2YXIgaT0wOyBpPG51bVRhYmxlczsgaSsrKVxuXHR7XG5cdFx0dmFyIHBsYXRmb3JtSUQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFx0dmFyIGVuY29kaW5nSUQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFx0dmFyIG5vZmZzZXQgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgICAgICAgb2Zmc2V0ICs9IDQ7XG5cdFx0XG5cdFx0dmFyIGlkID0gXCJwXCIrcGxhdGZvcm1JRCtcImVcIitlbmNvZGluZ0lEO1xuXHRcdFxuXHRcdC8vY29uc29sZS5sb2coXCJjbWFwIHN1YnRhYmxlXCIsIHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIG5vZmZzZXQpO1xuXHRcdFxuXHRcdFxuXHRcdHZhciB0aW5kID0gb2Zmcy5pbmRleE9mKG5vZmZzZXQpO1xuXHRcdFxuXHRcdGlmKHRpbmQ9PS0xKVxuXHRcdHtcblx0XHRcdHRpbmQgPSBvYmoudGFibGVzLmxlbmd0aDtcblx0XHRcdHZhciBzdWJ0O1xuXHRcdFx0b2Zmcy5wdXNoKG5vZmZzZXQpO1xuXHRcdFx0dmFyIGZvcm1hdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG5vZmZzZXQpO1xuXHRcdFx0aWYgICAgIChmb3JtYXQ9PSAwKSB7IHN1YnQgPSBUeXByLmNtYXAucGFyc2UwKGRhdGEsIG5vZmZzZXQpOyB9XG5cdFx0XHRlbHNlIGlmKGZvcm1hdD09IDQpIHsgc3VidCA9IFR5cHIuY21hcC5wYXJzZTQoZGF0YSwgbm9mZnNldCk7IH1cblx0XHRcdGVsc2UgaWYoZm9ybWF0PT0gNikgeyBzdWJ0ID0gVHlwci5jbWFwLnBhcnNlNihkYXRhLCBub2Zmc2V0KTsgfVxuXHRcdFx0ZWxzZSBpZihmb3JtYXQ9PTEyKSB7IHN1YnQgPSBUeXByLmNtYXAucGFyc2UxMihkYXRhLG5vZmZzZXQpOyB9XG5cdFx0XHRlbHNlIHsgY29uc29sZS5sb2coXCJ1bmtub3duIGZvcm1hdDogXCIrZm9ybWF0LCBwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBub2Zmc2V0KTsgfVxuXHRcdFx0b2JqLnRhYmxlcy5wdXNoKHN1YnQpO1xuXHRcdH1cblx0XHRcblx0XHRpZihvYmpbaWRdIT1udWxsKSB7IHRocm93IFwibXVsdGlwbGUgdGFibGVzIGZvciBvbmUgcGxhdGZvcm0rZW5jb2RpbmdcIjsgfVxuXHRcdG9ialtpZF0gPSB0aW5kO1xuXHR9XG5cdHJldHVybiBvYmo7XG59O1xuXG5UeXByLmNtYXAucGFyc2UwID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgb2JqID0ge307XG5cdG9iai5mb3JtYXQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdHZhciBsZW4gICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdHZhciBsYW5nICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdG9iai5tYXAgPSBbXTtcblx0Zm9yKHZhciBpPTA7IGk8bGVuLTY7IGkrKykgeyBvYmoubWFwLnB1c2goZGF0YVtvZmZzZXQraV0pOyB9XG5cdHJldHVybiBvYmo7XG59O1xuXG5UeXByLmNtYXAucGFyc2U0ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgb2Zmc2V0MCA9IG9mZnNldDtcblx0dmFyIG9iaiA9IHt9O1xuXHRcblx0b2JqLmZvcm1hdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdHZhciBsZW5ndGggPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHR2YXIgbGFuZ3VhZ2UgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHR2YXIgc2VnQ291bnRYMiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdHZhciBzZWdDb3VudCA9IHNlZ0NvdW50WDIvMjtcblx0b2JqLnNlYXJjaFJhbmdlID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0b2JqLmVudHJ5U2VsZWN0b3IgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRvYmoucmFuZ2VTaGlmdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdG9iai5lbmRDb3VudCAgID0gYmluLnJlYWRVc2hvcnRzKGRhdGEsIG9mZnNldCwgc2VnQ291bnQpOyAgb2Zmc2V0ICs9IHNlZ0NvdW50KjI7XG5cdG9mZnNldCs9Mjtcblx0b2JqLnN0YXJ0Q291bnQgPSBiaW4ucmVhZFVzaG9ydHMoZGF0YSwgb2Zmc2V0LCBzZWdDb3VudCk7ICBvZmZzZXQgKz0gc2VnQ291bnQqMjtcblx0b2JqLmlkRGVsdGEgPSBbXTtcblx0Zm9yKHZhciBpPTA7IGk8c2VnQ291bnQ7IGkrKykge29iai5pZERlbHRhLnB1c2goYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9Mjt9XG5cdG9iai5pZFJhbmdlT2Zmc2V0ID0gYmluLnJlYWRVc2hvcnRzKGRhdGEsIG9mZnNldCwgc2VnQ291bnQpOyAgb2Zmc2V0ICs9IHNlZ0NvdW50KjI7XG5cdG9iai5nbHlwaElkQXJyYXkgPSBbXTtcblx0d2hpbGUob2Zmc2V0PCBvZmZzZXQwK2xlbmd0aCkge29iai5nbHlwaElkQXJyYXkucHVzaChiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9Mjt9XG5cdHJldHVybiBvYmo7XG59O1xuXG5UeXByLmNtYXAucGFyc2U2ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgb2JqID0ge307XG5cdFxuXHRvYmouZm9ybWF0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0dmFyIGxlbmd0aCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdHZhciBsYW5ndWFnZSA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdG9iai5maXJzdENvZGUgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHR2YXIgZW50cnlDb3VudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdG9iai5nbHlwaElkQXJyYXkgPSBbXTtcblx0Zm9yKHZhciBpPTA7IGk8ZW50cnlDb3VudDsgaSsrKSB7b2JqLmdseXBoSWRBcnJheS5wdXNoKGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCkpOyAgb2Zmc2V0Kz0yO31cblx0XG5cdHJldHVybiBvYmo7XG59O1xuXG5UeXByLmNtYXAucGFyc2UxMiA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbntcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0dmFyIG9iaiA9IHt9O1xuXHRcblx0b2JqLmZvcm1hdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdG9mZnNldCArPSAyO1xuXHR2YXIgbGVuZ3RoID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTQ7XG5cdHZhciBsYW5nICAgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9NDtcblx0dmFyIG5Hcm91cHM9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz00O1xuXHRvYmouZ3JvdXBzID0gW107XG5cdFxuXHRmb3IodmFyIGk9MDsgaTxuR3JvdXBzOyBpKyspICBcblx0e1xuXHRcdHZhciBvZmYgPSBvZmZzZXQgKyBpICogMTI7XG5cdFx0dmFyIHN0YXJ0Q2hhckNvZGUgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2ZmKzApO1xuXHRcdHZhciBlbmRDaGFyQ29kZSAgID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZis0KTtcblx0XHR2YXIgc3RhcnRHbHlwaElEICA9IGJpbi5yZWFkVWludChkYXRhLCBvZmYrOCk7XG5cdFx0b2JqLmdyb3Vwcy5wdXNoKFsgIHN0YXJ0Q2hhckNvZGUsIGVuZENoYXJDb2RlLCBzdGFydEdseXBoSUQgIF0pO1xuXHR9XG5cdHJldHVybiBvYmo7XG59O1xuXG5UeXByLmdseWYgPSB7fTtcblR5cHIuZ2x5Zi5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBmb250KVxue1xuXHR2YXIgb2JqID0gW107XG5cdGZvcih2YXIgZz0wOyBnPGZvbnQubWF4cC5udW1HbHlwaHM7IGcrKykgeyBvYmoucHVzaChudWxsKTsgfVxuXHRyZXR1cm4gb2JqO1xufTtcblxuVHlwci5nbHlmLl9wYXJzZUdseWYgPSBmdW5jdGlvbihmb250LCBnKVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgZGF0YSA9IGZvbnQuX2RhdGE7XG5cdFxuXHR2YXIgb2Zmc2V0ID0gVHlwci5fdGFiT2Zmc2V0KGRhdGEsIFwiZ2x5ZlwiLCBmb250Ll9vZmZzZXQpICsgZm9udC5sb2NhW2ddO1xuXHRcdFxuXHRpZihmb250LmxvY2FbZ109PWZvbnQubG9jYVtnKzFdKSB7IHJldHVybiBudWxsOyB9XG5cdFx0XG5cdHZhciBnbCA9IHt9O1xuXHRcdFxuXHRnbC5ub2MgID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1x0XHQvLyBudW1iZXIgb2YgY29udG91cnNcblx0Z2wueE1pbiA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0Z2wueU1pbiA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0Z2wueE1heCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0Z2wueU1heCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XG5cdGlmKGdsLnhNaW4+PWdsLnhNYXggfHwgZ2wueU1pbj49Z2wueU1heCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdFxuXHRpZihnbC5ub2M+MClcblx0e1xuXHRcdGdsLmVuZFB0cyA9IFtdO1xuXHRcdGZvcih2YXIgaT0wOyBpPGdsLm5vYzsgaSsrKSB7IGdsLmVuZFB0cy5wdXNoKGJpbi5yZWFkVXNob3J0KGRhdGEsb2Zmc2V0KSk7IG9mZnNldCs9MjsgfVxuXHRcdFxuXHRcdHZhciBpbnN0cnVjdGlvbkxlbmd0aCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsb2Zmc2V0KTsgb2Zmc2V0Kz0yO1xuXHRcdGlmKChkYXRhLmxlbmd0aC1vZmZzZXQpPGluc3RydWN0aW9uTGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdFx0Z2wuaW5zdHJ1Y3Rpb25zID0gYmluLnJlYWRCeXRlcyhkYXRhLCBvZmZzZXQsIGluc3RydWN0aW9uTGVuZ3RoKTsgICBvZmZzZXQrPWluc3RydWN0aW9uTGVuZ3RoO1xuXHRcdFxuXHRcdHZhciBjcmRudW0gPSBnbC5lbmRQdHNbZ2wubm9jLTFdKzE7XG5cdFx0Z2wuZmxhZ3MgPSBbXTtcblx0XHRmb3IodmFyIGk9MDsgaTxjcmRudW07IGkrKyApIFxuXHRcdHsgXG5cdFx0XHR2YXIgZmxhZyA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrOyBcblx0XHRcdGdsLmZsYWdzLnB1c2goZmxhZyk7IFxuXHRcdFx0aWYoKGZsYWcmOCkhPTApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciByZXAgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcblx0XHRcdFx0Zm9yKHZhciBqPTA7IGo8cmVwOyBqKyspIHsgZ2wuZmxhZ3MucHVzaChmbGFnKTsgaSsrOyB9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGdsLnhzID0gW107XG5cdFx0Zm9yKHZhciBpPTA7IGk8Y3JkbnVtOyBpKyspIHtcblx0XHRcdHZhciBpOD0oKGdsLmZsYWdzW2ldJjIpIT0wKSwgc2FtZT0oKGdsLmZsYWdzW2ldJjE2KSE9MCk7ICBcblx0XHRcdGlmKGk4KSB7IGdsLnhzLnB1c2goc2FtZSA/IGRhdGFbb2Zmc2V0XSA6IC1kYXRhW29mZnNldF0pOyAgb2Zmc2V0Kys7IH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0aWYoc2FtZSkgeyBnbC54cy5wdXNoKDApOyB9XG5cdFx0XHRcdGVsc2UgeyBnbC54cy5wdXNoKGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KSk7ICBvZmZzZXQrPTI7IH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Z2wueXMgPSBbXTtcblx0XHRmb3IodmFyIGk9MDsgaTxjcmRudW07IGkrKykge1xuXHRcdFx0dmFyIGk4PSgoZ2wuZmxhZ3NbaV0mNCkhPTApLCBzYW1lPSgoZ2wuZmxhZ3NbaV0mMzIpIT0wKTsgIFxuXHRcdFx0aWYoaTgpIHsgZ2wueXMucHVzaChzYW1lID8gZGF0YVtvZmZzZXRdIDogLWRhdGFbb2Zmc2V0XSk7ICBvZmZzZXQrKzsgfVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRpZihzYW1lKSB7IGdsLnlzLnB1c2goMCk7IH1cblx0XHRcdFx0ZWxzZSB7IGdsLnlzLnB1c2goYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9MjsgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgeCA9IDAsIHkgPSAwO1xuXHRcdGZvcih2YXIgaT0wOyBpPGNyZG51bTsgaSsrKSB7IHggKz0gZ2wueHNbaV07IHkgKz0gZ2wueXNbaV07ICBnbC54c1tpXT14OyAgZ2wueXNbaV09eTsgfVxuXHRcdC8vY29uc29sZS5sb2coZW5kUHRzT2ZDb250b3VycywgaW5zdHJ1Y3Rpb25MZW5ndGgsIGluc3RydWN0aW9ucywgZmxhZ3MsIHhDb29yZGluYXRlcywgeUNvb3JkaW5hdGVzKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHR2YXIgQVJHXzFfQU5EXzJfQVJFX1dPUkRTXHQ9IDE8PDA7XG5cdFx0dmFyIEFSR1NfQVJFX1hZX1ZBTFVFU1x0XHQ9IDE8PDE7XG5cdFx0dmFyIFdFX0hBVkVfQV9TQ0FMRVx0XHRcdD0gMTw8Mztcblx0XHR2YXIgTU9SRV9DT01QT05FTlRTXHRcdFx0PSAxPDw1O1xuXHRcdHZhciBXRV9IQVZFX0FOX1hfQU5EX1lfU0NBTEU9IDE8PDY7XG5cdFx0dmFyIFdFX0hBVkVfQV9UV09fQllfVFdPXHQ9IDE8PDc7XG5cdFx0dmFyIFdFX0hBVkVfSU5TVFJVQ1RJT05TXHQ9IDE8PDg7XG5cdFx0XG5cdFx0Z2wucGFydHMgPSBbXTtcblx0XHR2YXIgZmxhZ3M7XG5cdFx0ZG8ge1xuXHRcdFx0ZmxhZ3MgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFx0XHR2YXIgcGFydCA9IHsgbTp7YToxLGI6MCxjOjAsZDoxLHR4OjAsdHk6MH0sIHAxOi0xLCBwMjotMSB9OyAgZ2wucGFydHMucHVzaChwYXJ0KTtcblx0XHRcdHBhcnQuZ2x5cGhJbmRleCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0XHRcdGlmICggZmxhZ3MgJiBBUkdfMV9BTkRfMl9BUkVfV09SRFMpIHtcblx0XHRcdFx0dmFyIGFyZzEgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0XHRcdFx0dmFyIGFyZzIgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhcmcxID0gYmluLnJlYWRJbnQ4KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKys7XG5cdFx0XHRcdHZhciBhcmcyID0gYmluLnJlYWRJbnQ4KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKys7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmKGZsYWdzICYgQVJHU19BUkVfWFlfVkFMVUVTKSB7IHBhcnQubS50eCA9IGFyZzE7ICBwYXJ0Lm0udHkgPSBhcmcyOyB9XG5cdFx0XHRlbHNlICB7ICBwYXJ0LnAxPWFyZzE7ICBwYXJ0LnAyPWFyZzI7ICB9XG5cdFx0XHQvL3BhcnQubS50eCA9IGFyZzE7ICBwYXJ0Lm0udHkgPSBhcmcyO1xuXHRcdFx0Ly9lbHNlIHsgdGhyb3cgXCJwYXJhbXMgYXJlIG5vdCBYWSB2YWx1ZXNcIjsgfVxuXHRcdFx0XG5cdFx0XHRpZiAoIGZsYWdzICYgV0VfSEFWRV9BX1NDQUxFICkge1xuXHRcdFx0XHRwYXJ0Lm0uYSA9IHBhcnQubS5kID0gYmluLnJlYWRGMmRvdDE0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjsgICAgXG5cdFx0XHR9IGVsc2UgaWYgKCBmbGFncyAmIFdFX0hBVkVfQU5fWF9BTkRfWV9TQ0FMRSApIHtcblx0XHRcdFx0cGFydC5tLmEgPSBiaW4ucmVhZEYyZG90MTQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyOyBcblx0XHRcdFx0cGFydC5tLmQgPSBiaW4ucmVhZEYyZG90MTQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyOyBcblx0XHRcdH0gZWxzZSBpZiAoIGZsYWdzICYgV0VfSEFWRV9BX1RXT19CWV9UV08gKSB7XG5cdFx0XHRcdHBhcnQubS5hID0gYmluLnJlYWRGMmRvdDE0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjsgXG5cdFx0XHRcdHBhcnQubS5iID0gYmluLnJlYWRGMmRvdDE0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjsgXG5cdFx0XHRcdHBhcnQubS5jID0gYmluLnJlYWRGMmRvdDE0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjsgXG5cdFx0XHRcdHBhcnQubS5kID0gYmluLnJlYWRGMmRvdDE0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjsgXG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoIGZsYWdzICYgTU9SRV9DT01QT05FTlRTICkgXG5cdFx0aWYgKGZsYWdzICYgV0VfSEFWRV9JTlNUUlVDVElPTlMpe1xuXHRcdFx0dmFyIG51bUluc3RyID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdFx0Z2wuaW5zdHIgPSBbXTtcblx0XHRcdGZvcih2YXIgaT0wOyBpPG51bUluc3RyOyBpKyspIHsgZ2wuaW5zdHIucHVzaChkYXRhW29mZnNldF0pOyAgb2Zmc2V0Kys7IH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGdsO1xufTtcblxuXG5UeXByLkdQT1MgPSB7fTtcblR5cHIuR1BPUy5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBmb250KSB7ICByZXR1cm4gVHlwci5fbGN0Zi5wYXJzZShkYXRhLCBvZmZzZXQsIGxlbmd0aCwgZm9udCwgVHlwci5HUE9TLnN1YnQpOyAgfTtcblxuXG5UeXByLkdQT1Muc3VidCA9IGZ1bmN0aW9uKGRhdGEsIGx0eXBlLCBvZmZzZXQpXHQvLyBsb29rdXAgdHlwZVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluLCBvZmZzZXQwID0gb2Zmc2V0LCB0YWIgPSB7fTtcblx0XG5cdHRhYi5mbXQgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XG5cdC8vY29uc29sZS5sb2cobHR5cGUsIHRhYi5mbXQpO1xuXHRcblx0aWYobHR5cGU9PTEgfHwgbHR5cGU9PTIgfHwgbHR5cGU9PTMgfHwgbHR5cGU9PTcgfHwgKGx0eXBlPT04ICYmIHRhYi5mbXQ8PTIpKSB7XG5cdFx0dmFyIGNvdk9mZiAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdHRhYi5jb3ZlcmFnZSA9IFR5cHIuX2xjdGYucmVhZENvdmVyYWdlKGRhdGEsIGNvdk9mZitvZmZzZXQwKTtcblx0fVxuXHRpZihsdHlwZT09MSAmJiB0YWIuZm10PT0xKSB7XG5cdFx0dmFyIHZhbEZtdDEgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdHZhciBvbmVzMSA9IFR5cHIuX2xjdGYubnVtT2ZPbmVzKHZhbEZtdDEpO1xuXHRcdGlmKHZhbEZtdDEhPTApICB7IHRhYi5wb3MgPSBUeXByLkdQT1MucmVhZFZhbHVlUmVjb3JkKGRhdGEsIG9mZnNldCwgdmFsRm10MSk7IH1cblx0fVxuXHRlbHNlIGlmKGx0eXBlPT0yKSB7XG5cdFx0dmFyIHZhbEZtdDEgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdHZhciB2YWxGbXQyID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XHR2YXIgb25lczEgPSBUeXByLl9sY3RmLm51bU9mT25lcyh2YWxGbXQxKTtcblx0XHR2YXIgb25lczIgPSBUeXByLl9sY3RmLm51bU9mT25lcyh2YWxGbXQyKTtcblx0XHRpZih0YWIuZm10PT0xKVxuXHRcdHtcblx0XHRcdHRhYi5wYWlyc2V0cyA9IFtdO1xuXHRcdFx0dmFyIHBzYyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7ICAvLyBQYWlyU2V0Q291bnRcblx0XHRcdFxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8cHNjOyBpKyspXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBwc29mZiA9IG9mZnNldDAgKyBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHB2YyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIHBzb2ZmKTsgIHBzb2ZmKz0yO1xuXHRcdFx0XHR2YXIgYXJyID0gW107XG5cdFx0XHRcdGZvcih2YXIgaj0wOyBqPHB2YzsgaisrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGdpZDIgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBwc29mZik7ICBwc29mZis9Mjtcblx0XHRcdFx0XHR2YXIgdmFsdWUxLCB2YWx1ZTI7XG5cdFx0XHRcdFx0aWYodmFsRm10MSE9MCkgeyAgdmFsdWUxID0gVHlwci5HUE9TLnJlYWRWYWx1ZVJlY29yZChkYXRhLCBwc29mZiwgdmFsRm10MSk7ICBwc29mZis9b25lczEqMjsgIH1cblx0XHRcdFx0XHRpZih2YWxGbXQyIT0wKSB7ICB2YWx1ZTIgPSBUeXByLkdQT1MucmVhZFZhbHVlUmVjb3JkKGRhdGEsIHBzb2ZmLCB2YWxGbXQyKTsgIHBzb2ZmKz1vbmVzMioyOyAgfVxuXHRcdFx0XHRcdC8vaWYodmFsdWUxIT1udWxsKSB0aHJvdyBcImVcIjtcblx0XHRcdFx0XHRhcnIucHVzaCh7Z2lkMjpnaWQyLCB2YWwxOnZhbHVlMSwgdmFsMjp2YWx1ZTJ9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YWIucGFpcnNldHMucHVzaChhcnIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZih0YWIuZm10PT0yKVxuXHRcdHtcblx0XHRcdHZhciBjbGFzc0RlZjEgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdFx0dmFyIGNsYXNzRGVmMiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0XHR2YXIgY2xhc3MxQ291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdFx0dmFyIGNsYXNzMkNvdW50ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XHRcdFxuXHRcdFx0dGFiLmNsYXNzRGVmMSA9IFR5cHIuX2xjdGYucmVhZENsYXNzRGVmKGRhdGEsIG9mZnNldDAgKyBjbGFzc0RlZjEpO1xuXHRcdFx0dGFiLmNsYXNzRGVmMiA9IFR5cHIuX2xjdGYucmVhZENsYXNzRGVmKGRhdGEsIG9mZnNldDAgKyBjbGFzc0RlZjIpO1xuXHRcdFx0XG5cdFx0XHR0YWIubWF0cml4ID0gW107XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxjbGFzczFDb3VudDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgcm93ID0gW107XG5cdFx0XHRcdGZvcih2YXIgaj0wOyBqPGNsYXNzMkNvdW50OyBqKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgdmFsdWUxID0gbnVsbCwgdmFsdWUyID0gbnVsbDtcblx0XHRcdFx0XHRpZih0YWIudmFsRm10MSE9MCkgeyB2YWx1ZTEgPSBUeXByLkdQT1MucmVhZFZhbHVlUmVjb3JkKGRhdGEsIG9mZnNldCwgdGFiLnZhbEZtdDEpOyAgb2Zmc2V0Kz1vbmVzMSoyOyB9XG5cdFx0XHRcdFx0aWYodGFiLnZhbEZtdDIhPTApIHsgdmFsdWUyID0gVHlwci5HUE9TLnJlYWRWYWx1ZVJlY29yZChkYXRhLCBvZmZzZXQsIHRhYi52YWxGbXQyKTsgIG9mZnNldCs9b25lczIqMjsgfVxuXHRcdFx0XHRcdHJvdy5wdXNoKHt2YWwxOnZhbHVlMSwgdmFsMjp2YWx1ZTJ9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YWIubWF0cml4LnB1c2gocm93KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhYjtcbn07XG5cblxuVHlwci5HUE9TLnJlYWRWYWx1ZVJlY29yZCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgdmFsRm10KVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgYXJyID0gW107XG5cdGFyci5wdXNoKCAodmFsRm10JjEpID8gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpIDogMCApOyAgb2Zmc2V0ICs9ICh2YWxGbXQmMSkgPyAyIDogMDsgIC8vIFhfUExBQ0VNRU5UXG5cdGFyci5wdXNoKCAodmFsRm10JjIpID8gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpIDogMCApOyAgb2Zmc2V0ICs9ICh2YWxGbXQmMikgPyAyIDogMDsgIC8vIFlfUExBQ0VNRU5UXG5cdGFyci5wdXNoKCAodmFsRm10JjQpID8gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpIDogMCApOyAgb2Zmc2V0ICs9ICh2YWxGbXQmNCkgPyAyIDogMDsgIC8vIFhfQURWQU5DRVxuXHRhcnIucHVzaCggKHZhbEZtdCY4KSA/IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KSA6IDAgKTsgIG9mZnNldCArPSAodmFsRm10JjgpID8gMiA6IDA7ICAvLyBZX0FEVkFOQ0Vcblx0cmV0dXJuIGFycjtcbn07XG5cblR5cHIuR1NVQiA9IHt9O1xuVHlwci5HU1VCLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIGZvbnQpIHsgIHJldHVybiBUeXByLl9sY3RmLnBhcnNlKGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBmb250LCBUeXByLkdTVUIuc3VidCk7ICB9O1xuXG5cblR5cHIuR1NVQi5zdWJ0ID0gZnVuY3Rpb24oZGF0YSwgbHR5cGUsIG9mZnNldClcdC8vIGxvb2t1cCB0eXBlXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW4sIG9mZnNldDAgPSBvZmZzZXQsIHRhYiA9IHt9O1xuXHRcblx0dGFiLmZtdCAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcblx0aWYobHR5cGUhPTEgJiYgbHR5cGUhPTQgJiYgbHR5cGUhPTUgJiYgbHR5cGUhPTYpIHsgcmV0dXJuIG51bGw7IH1cblx0XG5cdGlmKGx0eXBlPT0xIHx8IGx0eXBlPT00IHx8IChsdHlwZT09NSAmJiB0YWIuZm10PD0yKSB8fCAobHR5cGU9PTYgJiYgdGFiLmZtdDw9MikpIHtcblx0XHR2YXIgY292T2ZmICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0dGFiLmNvdmVyYWdlID0gVHlwci5fbGN0Zi5yZWFkQ292ZXJhZ2UoZGF0YSwgb2Zmc2V0MCtjb3ZPZmYpO1x0Ly8gbm90IGFsd2F5cyBpcyBjb3ZlcmFnZSBoZXJlXG5cdH1cblx0XG5cdGlmKGx0eXBlPT0xKSB7XHRcblx0XHRpZih0YWIuZm10PT0xKSB7XG5cdFx0XHR0YWIuZGVsdGEgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0fVxuXHRcdGVsc2UgaWYodGFiLmZtdD09Mikge1xuXHRcdFx0dmFyIGNudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0XHR0YWIubmV3ZyA9IGJpbi5yZWFkVXNob3J0cyhkYXRhLCBvZmZzZXQsIGNudCk7ICBvZmZzZXQrPXRhYi5uZXdnLmxlbmd0aCoyO1xuXHRcdH1cblx0fVxuXHQvLyAgTGlnYXR1cmUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlXG5cdGVsc2UgaWYobHR5cGU9PTQpIHtcblx0XHR0YWIudmFscyA9IFtdO1xuXHRcdHZhciBjbnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdGZvcih2YXIgaT0wOyBpPGNudDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9mZiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0XHR0YWIudmFscy5wdXNoKFR5cHIuR1NVQi5yZWFkTGlnYXR1cmVTZXQoZGF0YSwgb2Zmc2V0MCtsb2ZmKSk7XG5cdFx0fVxuXHRcdC8vY29uc29sZS5sb2codGFiLmNvdmVyYWdlKTtcblx0XHQvL2NvbnNvbGUubG9nKHRhYi52YWxzKTtcblx0fSBcblx0Ly8gIENvbnRleHR1YWwgU3Vic3RpdHV0aW9uIFN1YnRhYmxlXG5cdGVsc2UgaWYobHR5cGU9PTUpIHtcblx0XHRpZih0YWIuZm10PT0yKSB7XG5cdFx0XHR2YXIgY0RlZk9mZnNldCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0XHR0YWIuY0RlZiA9IFR5cHIuX2xjdGYucmVhZENsYXNzRGVmKGRhdGEsIG9mZnNldDAgKyBjRGVmT2Zmc2V0KTtcblx0XHRcdHRhYi5zY3NldCA9IFtdO1xuXHRcdFx0dmFyIHN1YkNsYXNzU2V0Q291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8c3ViQ2xhc3NTZXRDb3VudDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgc2NzT2ZmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XHRcdFx0dGFiLnNjc2V0LnB1c2goICBzY3NPZmY9PTAgPyBudWxsIDogVHlwci5HU1VCLnJlYWRTdWJDbGFzc1NldChkYXRhLCBvZmZzZXQwICsgc2NzT2ZmKSAgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly9lbHNlIGNvbnNvbGUubG9nKFwidW5rbm93biB0YWJsZSBmb3JtYXRcIiwgdGFiLmZtdCk7XG5cdH1cblx0Ly8qXG5cdGVsc2UgaWYobHR5cGU9PTYpIHtcblx0XHQvKlxuXHRcdGlmKHRhYi5mbXQ9PTIpIHtcblx0XHRcdHZhciBidERlZiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0XHR2YXIgaW5EZWYgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdFx0dmFyIGxhRGVmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XHRcdFxuXHRcdFx0dGFiLmJ0RGVmID0gVHlwci5fbGN0Zi5yZWFkQ2xhc3NEZWYoZGF0YSwgb2Zmc2V0MCArIGJ0RGVmKTtcblx0XHRcdHRhYi5pbkRlZiA9IFR5cHIuX2xjdGYucmVhZENsYXNzRGVmKGRhdGEsIG9mZnNldDAgKyBpbkRlZik7XG5cdFx0XHR0YWIubGFEZWYgPSBUeXByLl9sY3RmLnJlYWRDbGFzc0RlZihkYXRhLCBvZmZzZXQwICsgbGFEZWYpO1xuXHRcdFx0XG5cdFx0XHR0YWIuc2NzZXQgPSBbXTtcblx0XHRcdHZhciBjbnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8Y250OyBpKyspIHtcblx0XHRcdFx0dmFyIGxvZmYgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdFx0XHR0YWIuc2NzZXQucHVzaChUeXByLkdTVUIucmVhZENoYWluU3ViQ2xhc3NTZXQoZGF0YSwgb2Zmc2V0MCtsb2ZmKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdCovXG5cdFx0aWYodGFiLmZtdD09Mykge1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8MzsgaSsrKSB7XG5cdFx0XHRcdHZhciBjbnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdFx0XHR2YXIgY3ZncyA9IFtdO1xuXHRcdFx0XHRmb3IodmFyIGo9MDsgajxjbnQ7IGorKykgeyBjdmdzLnB1c2goICBUeXByLl9sY3RmLnJlYWRDb3ZlcmFnZShkYXRhLCBvZmZzZXQwICsgYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0K2oqMikpICAgKTsgfVxuXHRcdFx0XHRvZmZzZXQrPWNudCoyO1xuXHRcdFx0XHRpZihpPT0wKSB7IHRhYi5iYWNrQ3ZnID0gY3ZnczsgfVxuXHRcdFx0XHRpZihpPT0xKSB7IHRhYi5pbnB0Q3ZnID0gY3ZnczsgfVxuXHRcdFx0XHRpZihpPT0yKSB7IHRhYi5haGVkQ3ZnID0gY3ZnczsgfVxuXHRcdFx0fVxuXHRcdFx0dmFyIGNudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0XHR0YWIubG9va3VwUmVjID0gVHlwci5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHMoZGF0YSwgb2Zmc2V0LCBjbnQpO1xuXHRcdH1cblx0XHQvL2NvbnNvbGUubG9nKHRhYik7XG5cdH0gLy8qL1xuXHQvL2lmKHRhYi5jb3ZlcmFnZS5pbmRleE9mKDMpIT0tMSkgY29uc29sZS5sb2cobHR5cGUsIGZtdCwgdGFiKTtcblx0XG5cdHJldHVybiB0YWI7XG59O1xuXG5UeXByLkdTVUIucmVhZFN1YkNsYXNzU2V0ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxue1xuXHR2YXIgclVzID0gVHlwci5fYmluLnJlYWRVc2hvcnQsIG9mZnNldDAgPSBvZmZzZXQsIGxzZXQgPSBbXTtcblx0dmFyIGNudCA9IHJVcyhkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRmb3IodmFyIGk9MDsgaTxjbnQ7IGkrKykge1xuXHRcdHZhciBsb2ZmID0gclVzKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0bHNldC5wdXNoKFR5cHIuR1NVQi5yZWFkU3ViQ2xhc3NSdWxlKGRhdGEsIG9mZnNldDArbG9mZikpO1xuXHR9XG5cdHJldHVybiBsc2V0O1xufTtcblR5cHIuR1NVQi5yZWFkU3ViQ2xhc3NSdWxlPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQpXG57XG5cdHZhciByVXMgPSBUeXByLl9iaW4ucmVhZFVzaG9ydCwgcnVsZSA9IHt9O1xuXHR2YXIgZ2NvdW50ID0gclVzKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdHZhciBzY291bnQgPSByVXMoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0cnVsZS5pbnB1dCA9IFtdO1xuXHRmb3IodmFyIGk9MDsgaTxnY291bnQtMTsgaSsrKSB7XG5cdFx0cnVsZS5pbnB1dC5wdXNoKHJVcyhkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9Mjtcblx0fVxuXHRydWxlLnN1YnN0TG9va3VwUmVjb3JkcyA9IFR5cHIuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzKGRhdGEsIG9mZnNldCwgc2NvdW50KTtcblx0cmV0dXJuIHJ1bGU7XG59O1xuVHlwci5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHMgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGNudClcbntcblx0dmFyIHJVcyA9IFR5cHIuX2Jpbi5yZWFkVXNob3J0O1xuXHR2YXIgb3V0ID0gW107XG5cdGZvcih2YXIgaT0wOyBpPGNudDsgaSsrKSB7ICBvdXQucHVzaChyVXMoZGF0YSwgb2Zmc2V0KSwgclVzKGRhdGEsIG9mZnNldCsyKSk7ICBvZmZzZXQrPTQ7ICB9XG5cdHJldHVybiBvdXQ7XG59O1xuXG5UeXByLkdTVUIucmVhZENoYWluU3ViQ2xhc3NTZXQgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQpXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW4sIG9mZnNldDAgPSBvZmZzZXQsIGxzZXQgPSBbXTtcblx0dmFyIGNudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdGZvcih2YXIgaT0wOyBpPGNudDsgaSsrKSB7XG5cdFx0dmFyIGxvZmYgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdGxzZXQucHVzaChUeXByLkdTVUIucmVhZENoYWluU3ViQ2xhc3NSdWxlKGRhdGEsIG9mZnNldDArbG9mZikpO1xuXHR9XG5cdHJldHVybiBsc2V0O1xufTtcblR5cHIuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1J1bGU9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbntcblx0dmFyIGJpbiA9IFR5cHIuX2JpbiwgcnVsZSA9IHt9O1xuXHR2YXIgcHBzID0gW1wiYmFja3RyYWNrXCIsIFwiaW5wdXRcIiwgXCJsb29rYWhlYWRcIl07XG5cdGZvcih2YXIgcGk9MDsgcGk8cHBzLmxlbmd0aDsgcGkrKykge1xuXHRcdHZhciBjbnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yOyAgaWYocGk9PTEpIHsgY250LS07IH1cblx0XHRydWxlW3Bwc1twaV1dPWJpbi5yZWFkVXNob3J0cyhkYXRhLCBvZmZzZXQsIGNudCk7ICBvZmZzZXQrPSBydWxlW3Bwc1twaV1dLmxlbmd0aCoyO1xuXHR9XG5cdHZhciBjbnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRydWxlLnN1YnN0ID0gYmluLnJlYWRVc2hvcnRzKGRhdGEsIG9mZnNldCwgY250KjIpOyAgb2Zmc2V0ICs9IHJ1bGUuc3Vic3QubGVuZ3RoKjI7XG5cdHJldHVybiBydWxlO1xufTtcblxuVHlwci5HU1VCLnJlYWRMaWdhdHVyZVNldCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbntcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbiwgb2Zmc2V0MCA9IG9mZnNldCwgbHNldCA9IFtdO1xuXHR2YXIgbGNudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdGZvcih2YXIgaj0wOyBqPGxjbnQ7IGorKykge1xuXHRcdHZhciBsb2ZmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XHRsc2V0LnB1c2goVHlwci5HU1VCLnJlYWRMaWdhdHVyZShkYXRhLCBvZmZzZXQwK2xvZmYpKTtcblx0fVxuXHRyZXR1cm4gbHNldDtcbn07XG5UeXByLkdTVUIucmVhZExpZ2F0dXJlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluLCBsaWcgPSB7Y2hhaW46W119O1xuXHRsaWcubmdseXBoID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0dmFyIGNjbnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRmb3IodmFyIGs9MDsgazxjY250LTE7IGsrKykgeyAgbGlnLmNoYWluLnB1c2goYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KSk7ICBvZmZzZXQrPTI7ICB9XG5cdHJldHVybiBsaWc7XG59O1xuXG5cblxuVHlwci5oZWFkID0ge307XG5UeXByLmhlYWQucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aClcbntcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgdGFibGVWZXJzaW9uID0gYmluLnJlYWRGaXhlZChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG5cdG9iai5mb250UmV2aXNpb24gPSBiaW4ucmVhZEZpeGVkKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0dmFyIGNoZWNrU3VtQWRqdXN0bWVudCA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG5cdHZhciBtYWdpY051bWJlciA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG5cdG9iai5mbGFncyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0b2JqLnVuaXRzUGVyRW0gPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdG9iai5jcmVhdGVkICA9IGJpbi5yZWFkVWludDY0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gODtcblx0b2JqLm1vZGlmaWVkID0gYmluLnJlYWRVaW50NjQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA4O1xuXHRvYmoueE1pbiA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRvYmoueU1pbiA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRvYmoueE1heCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRvYmoueU1heCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRvYmoubWFjU3R5bGUgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdG9iai5sb3dlc3RSZWNQUEVNID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRvYmouZm9udERpcmVjdGlvbkhpbnQgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0b2JqLmluZGV4VG9Mb2NGb3JtYXQgID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdG9iai5nbHlwaERhdGFGb3JtYXQgICA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRyZXR1cm4gb2JqO1xufTtcblxuXG5UeXByLmhoZWEgPSB7fTtcblR5cHIuaGhlYS5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoKVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgb2JqID0ge307XG5cdHZhciB0YWJsZVZlcnNpb24gPSBiaW4ucmVhZEZpeGVkKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0b2JqLmFzY2VuZGVyICA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRvYmouZGVzY2VuZGVyID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdG9iai5saW5lR2FwID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFxuXHRvYmouYWR2YW5jZVdpZHRoTWF4ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRvYmoubWluTGVmdFNpZGVCZWFyaW5nICA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRvYmoubWluUmlnaHRTaWRlQmVhcmluZyA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRvYmoueE1heEV4dGVudCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcblx0b2JqLmNhcmV0U2xvcGVSaXNlID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdG9iai5jYXJldFNsb3BlUnVuICA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRvYmouY2FyZXRPZmZzZXQgICAgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0XG5cdG9mZnNldCArPSA0KjI7XG5cdFxuXHRvYmoubWV0cmljRGF0YUZvcm1hdCA9IGJpbi5yZWFkU2hvcnQgKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0b2JqLm51bWJlck9mSE1ldHJpY3MgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdHJldHVybiBvYmo7XG59O1xuXG5cblR5cHIuaG10eCA9IHt9O1xuVHlwci5obXR4LnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIGZvbnQpXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdHZhciBvYmogPSB7fTtcblx0XG5cdG9iai5hV2lkdGggPSBbXTtcblx0b2JqLmxzQmVhcmluZyA9IFtdO1xuXHRcblx0XG5cdHZhciBhdyA9IDAsIGxzYiA9IDA7XG5cdFxuXHRmb3IodmFyIGk9MDsgaTxmb250Lm1heHAubnVtR2x5cGhzOyBpKyspXG5cdHtcblx0XHRpZihpPGZvbnQuaGhlYS5udW1iZXJPZkhNZXRyaWNzKSB7ICBhdz1iaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7ICBsc2I9YmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yOyAgfVxuXHRcdG9iai5hV2lkdGgucHVzaChhdyk7XG5cdFx0b2JqLmxzQmVhcmluZy5wdXNoKGxzYik7XG5cdH1cblx0XG5cdHJldHVybiBvYmo7XG59O1xuXG5cblR5cHIua2VybiA9IHt9O1xuVHlwci5rZXJuLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIGZvbnQpXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdFxuXHR2YXIgdmVyc2lvbiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdGlmKHZlcnNpb249PTEpIHsgcmV0dXJuIFR5cHIua2Vybi5wYXJzZVYxKGRhdGEsIG9mZnNldC0yLCBsZW5ndGgsIGZvbnQpOyB9XG5cdHZhciBuVGFibGVzID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XG5cdHZhciBtYXAgPSB7Z2x5cGgxOiBbXSwgcnZhbDpbXX07XG5cdGZvcih2YXIgaT0wOyBpPG5UYWJsZXM7IGkrKylcblx0e1xuXHRcdG9mZnNldCs9MjtcdC8vIHNraXAgdmVyc2lvblxuXHRcdHZhciBsZW5ndGggID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XHR2YXIgY292ZXJhZ2UgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdHZhciBmb3JtYXQgPSBjb3ZlcmFnZT4+Pjg7XG5cdFx0LyogSSBoYXZlIHNlZW4gZm9ybWF0IDEyOCBvbmNlLCB0aGF0J3Mgd2h5IEkgZG8gKi8gZm9ybWF0ICY9IDB4Zjtcblx0XHRpZihmb3JtYXQ9PTApIHsgb2Zmc2V0ID0gVHlwci5rZXJuLnJlYWRGb3JtYXQwKGRhdGEsIG9mZnNldCwgbWFwKTsgfVxuXHRcdGVsc2UgeyB0aHJvdyBcInVua25vd24ga2VybiB0YWJsZSBmb3JtYXQ6IFwiK2Zvcm1hdDsgfVxuXHR9XG5cdHJldHVybiBtYXA7XG59O1xuXG5UeXByLmtlcm4ucGFyc2VWMSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBmb250KVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHRcblx0dmFyIHZlcnNpb24gPSBiaW4ucmVhZEZpeGVkKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTQ7XG5cdHZhciBuVGFibGVzID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTQ7XG5cdFxuXHR2YXIgbWFwID0ge2dseXBoMTogW10sIHJ2YWw6W119O1xuXHRmb3IodmFyIGk9MDsgaTxuVGFibGVzOyBpKyspXG5cdHtcblx0XHR2YXIgbGVuZ3RoID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICAgb2Zmc2V0Kz00O1xuXHRcdHZhciBjb3ZlcmFnZSA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0dmFyIHR1cGxlSW5kZXggPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdHZhciBmb3JtYXQgPSBjb3ZlcmFnZT4+Pjg7XG5cdFx0LyogSSBoYXZlIHNlZW4gZm9ybWF0IDEyOCBvbmNlLCB0aGF0J3Mgd2h5IEkgZG8gKi8gZm9ybWF0ICY9IDB4Zjtcblx0XHRpZihmb3JtYXQ9PTApIHsgb2Zmc2V0ID0gVHlwci5rZXJuLnJlYWRGb3JtYXQwKGRhdGEsIG9mZnNldCwgbWFwKTsgfVxuXHRcdGVsc2UgeyB0aHJvdyBcInVua25vd24ga2VybiB0YWJsZSBmb3JtYXQ6IFwiK2Zvcm1hdDsgfVxuXHR9XG5cdHJldHVybiBtYXA7XG59O1xuXG5UeXByLmtlcm4ucmVhZEZvcm1hdDAgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG1hcClcbntcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0dmFyIHBsZWZ0ID0gLTE7XG5cdHZhciBuUGFpcnMgICAgICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0dmFyIHNlYXJjaFJhbmdlICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHR2YXIgZW50cnlTZWxlY3RvciA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdHZhciByYW5nZVNoaWZ0ICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0Zm9yKHZhciBqPTA7IGo8blBhaXJzOyBqKyspXG5cdHtcblx0XHR2YXIgbGVmdCAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuXHRcdHZhciByaWdodCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cdFx0dmFyIHZhbHVlID0gYmluLnJlYWRTaG9ydCAoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0XHRpZihsZWZ0IT1wbGVmdCkgeyBtYXAuZ2x5cGgxLnB1c2gobGVmdCk7ICBtYXAucnZhbC5wdXNoKHsgZ2x5cGgyOltdLCB2YWxzOltdIH0pOyB9XG5cdFx0dmFyIHJ2YWwgPSBtYXAucnZhbFttYXAucnZhbC5sZW5ndGgtMV07XG5cdFx0cnZhbC5nbHlwaDIucHVzaChyaWdodCk7ICAgcnZhbC52YWxzLnB1c2godmFsdWUpO1xuXHRcdHBsZWZ0ID0gbGVmdDtcblx0fVxuXHRyZXR1cm4gb2Zmc2V0O1xufTtcblxuXG5cblR5cHIubG9jYSA9IHt9O1xuVHlwci5sb2NhLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIGZvbnQpXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdHZhciBvYmogPSBbXTtcblx0XG5cdHZhciB2ZXIgPSBmb250LmhlYWQuaW5kZXhUb0xvY0Zvcm1hdDtcblx0Ly9jb25zb2xlLmxvZyhcImxvY2FcIiwgdmVyLCBsZW5ndGgsIDQqZm9udC5tYXhwLm51bUdseXBocyk7XG5cdHZhciBsZW4gPSBmb250Lm1heHAubnVtR2x5cGhzKzE7XG5cdFxuXHRpZih2ZXI9PTApIHsgZm9yKHZhciBpPTA7IGk8bGVuOyBpKyspIHsgb2JqLnB1c2goYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KyhpPDwxKSk8PDEpOyB9IH1cblx0aWYodmVyPT0xKSB7IGZvcih2YXIgaT0wOyBpPGxlbjsgaSsrKSB7IG9iai5wdXNoKGJpbi5yZWFkVWludCAgKGRhdGEsIG9mZnNldCsoaTw8MikpICAgKTsgfSB9XG5cdFxuXHRyZXR1cm4gb2JqO1xufTtcblxuXG5UeXByLm1heHAgPSB7fTtcblR5cHIubWF4cC5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoKVxue1xuXHQvL2NvbnNvbGUubG9nKGRhdGEubGVuZ3RoLCBvZmZzZXQsIGxlbmd0aCk7XG5cdFxuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgb2JqID0ge307XG5cdFxuXHQvLyBib3RoIHZlcnNpb25zIDAuNSBhbmQgMS4wXG5cdHZhciB2ZXIgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG5cdG9iai5udW1HbHlwaHMgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFxuXHQvLyBvbmx5IDEuMFxuXHRpZih2ZXIgPT0gMHgwMDAxMDAwMClcblx0e1xuXHRcdG9iai5tYXhQb2ludHMgICAgICAgICAgICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFx0b2JqLm1heENvbnRvdXJzICAgICAgICAgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0XHRvYmoubWF4Q29tcG9zaXRlUG9pbnRzICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdG9iai5tYXhDb21wb3NpdGVDb250b3VycyAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFx0b2JqLm1heFpvbmVzICAgICAgICAgICAgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0XHRvYmoubWF4VHdpbGlnaHRQb2ludHMgICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdG9iai5tYXhTdG9yYWdlICAgICAgICAgICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFx0b2JqLm1heEZ1bmN0aW9uRGVmcyAgICAgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0XHRvYmoubWF4SW5zdHJ1Y3Rpb25EZWZzICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdG9iai5tYXhTdGFja0VsZW1lbnRzICAgICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFx0b2JqLm1heFNpemVPZkluc3RydWN0aW9ucyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0XHRvYmoubWF4Q29tcG9uZW50RWxlbWVudHMgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdG9iai5tYXhDb21wb25lbnREZXB0aCAgICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdH1cblx0XG5cdHJldHVybiBvYmo7XG59O1xuXG5cblR5cHIubmFtZSA9IHt9O1xuVHlwci5uYW1lLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBsZW5ndGgpXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdHZhciBvYmogPSB7fTtcblx0dmFyIGZvcm1hdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0dmFyIGNvdW50ICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0dmFyIHN0cmluZ09mZnNldCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0XG5cdC8vY29uc29sZS5sb2coZm9ybWF0LGNvdW50KTtcblx0XG5cdHZhciBuYW1lcyA9IFtcblx0XHRcImNvcHlyaWdodFwiLFxuXHRcdFwiZm9udEZhbWlseVwiLFxuXHRcdFwiZm9udFN1YmZhbWlseVwiLFxuXHRcdFwiSURcIixcblx0XHRcImZ1bGxOYW1lXCIsXG5cdFx0XCJ2ZXJzaW9uXCIsXG5cdFx0XCJwb3N0U2NyaXB0TmFtZVwiLFxuXHRcdFwidHJhZGVtYXJrXCIsXG5cdFx0XCJtYW51ZmFjdHVyZXJcIixcblx0XHRcImRlc2lnbmVyXCIsXG5cdFx0XCJkZXNjcmlwdGlvblwiLFxuXHRcdFwidXJsVmVuZG9yXCIsXG5cdFx0XCJ1cmxEZXNpZ25lclwiLFxuXHRcdFwibGljZW5jZVwiLFxuXHRcdFwibGljZW5jZVVSTFwiLFxuXHRcdFwiLS0tXCIsXG5cdFx0XCJ0eXBvRmFtaWx5TmFtZVwiLFxuXHRcdFwidHlwb1N1YmZhbWlseU5hbWVcIixcblx0XHRcImNvbXBhdGlibGVGdWxsXCIsXG5cdFx0XCJzYW1wbGVUZXh0XCIsXG5cdFx0XCJwb3N0U2NyaXB0Q0lEXCIsXG5cdFx0XCJ3d3NGYW1pbHlOYW1lXCIsXG5cdFx0XCJ3d3NTdWJmYW1pbHlOYW1lXCIsXG5cdFx0XCJsaWdodFBhbGV0dGVcIixcblx0XHRcImRhcmtQYWxldHRlXCJcblx0XTtcblx0XG5cdHZhciBvZmZzZXQwID0gb2Zmc2V0O1xuXHRcblx0Zm9yKHZhciBpPTA7IGk8Y291bnQ7IGkrKylcblx0e1xuXHRcdHZhciBwbGF0Zm9ybUlEID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdHZhciBlbmNvZGluZ0lEID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdHZhciBsYW5ndWFnZUlEID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdHZhciBuYW1lSUQgICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdHZhciBzbGVuICAgICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdHZhciBub2Zmc2V0ICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdC8vY29uc29sZS5sb2cocGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbGFuZ3VhZ2VJRC50b1N0cmluZygxNiksIG5hbWVJRCwgbGVuZ3RoLCBub2Zmc2V0KTtcblx0XHRcblx0XHR2YXIgY25hbWUgPSBuYW1lc1tuYW1lSURdO1xuXHRcdHZhciBzb2ZmID0gb2Zmc2V0MCArIGNvdW50KjEyICsgbm9mZnNldDtcblx0XHR2YXIgc3RyO1xuXHRcdGlmKHBsYXRmb3JtSUQgPT0gMCkgeyBzdHIgPSBiaW4ucmVhZFVuaWNvZGUoZGF0YSwgc29mZiwgc2xlbi8yKTsgfVxuXHRcdGVsc2UgaWYocGxhdGZvcm1JRCA9PSAzICYmIGVuY29kaW5nSUQgPT0gMCkgeyBzdHIgPSBiaW4ucmVhZFVuaWNvZGUoZGF0YSwgc29mZiwgc2xlbi8yKTsgfVxuXHRcdGVsc2UgaWYoZW5jb2RpbmdJRCA9PSAwKSB7IHN0ciA9IGJpbi5yZWFkQVNDSUkgIChkYXRhLCBzb2ZmLCBzbGVuKTsgfVxuXHRcdGVsc2UgaWYoZW5jb2RpbmdJRCA9PSAxKSB7IHN0ciA9IGJpbi5yZWFkVW5pY29kZShkYXRhLCBzb2ZmLCBzbGVuLzIpOyB9XG5cdFx0ZWxzZSBpZihlbmNvZGluZ0lEID09IDMpIHsgc3RyID0gYmluLnJlYWRVbmljb2RlKGRhdGEsIHNvZmYsIHNsZW4vMik7IH1cblx0XHRcblx0XHRlbHNlIGlmKHBsYXRmb3JtSUQgPT0gMSkgeyBzdHIgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIHNvZmYsIHNsZW4pOyAgY29uc29sZS5sb2coXCJyZWFkaW5nIHVua25vd24gTUFDIGVuY29kaW5nIFwiK2VuY29kaW5nSUQrXCIgYXMgQVNDSUlcIik7IH1cblx0XHRlbHNlIHsgdGhyb3cgXCJ1bmtub3duIGVuY29kaW5nIFwiK2VuY29kaW5nSUQgKyBcIiwgcGxhdGZvcm1JRDogXCIrcGxhdGZvcm1JRDsgfVxuXHRcdFxuXHRcdHZhciB0aWQgPSBcInBcIitwbGF0Zm9ybUlEK1wiLFwiKyhsYW5ndWFnZUlEKS50b1N0cmluZygxNik7Ly9UeXByLl9wbGF0Zm9ybXNbcGxhdGZvcm1JRF07XG5cdFx0aWYob2JqW3RpZF09PW51bGwpIHsgb2JqW3RpZF0gPSB7fTsgfVxuXHRcdG9ialt0aWRdW2NuYW1lXSA9IHN0cjtcblx0XHRvYmpbdGlkXS5fbGFuZyA9IGxhbmd1YWdlSUQ7XG5cdFx0Ly9jb25zb2xlLmxvZyh0aWQsIG9ialt0aWRdKTtcblx0fVxuXHQvKlxuXHRpZihmb3JtYXQgPT0gMSlcblx0e1xuXHRcdHZhciBsYW5nVGFnQ291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFx0Zm9yKHZhciBpPTA7IGk8bGFuZ1RhZ0NvdW50OyBpKyspXG5cdFx0e1xuXHRcdFx0dmFyIGxlbmd0aCAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFx0XHR2YXIgbm9mZnNldCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcblx0XHR9XG5cdH1cblx0Ki9cblx0XG5cdC8vY29uc29sZS5sb2cob2JqKTtcblx0XG5cdGZvcih2YXIgcCBpbiBvYmopIHsgaWYob2JqW3BdLnBvc3RTY3JpcHROYW1lIT1udWxsICYmIG9ialtwXS5fbGFuZz09MHgwNDA5KSB7IHJldHVybiBvYmpbcF07IH0gfVx0XHQvLyBVbml0ZWQgU3RhdGVzXG5cdGZvcih2YXIgcCBpbiBvYmopIHsgaWYob2JqW3BdLnBvc3RTY3JpcHROYW1lIT1udWxsICYmIG9ialtwXS5fbGFuZz09MHgwMDAwKSB7IHJldHVybiBvYmpbcF07IH0gfVx0XHQvLyBVbml2ZXJzYWxcblx0Zm9yKHZhciBwIGluIG9iaikgeyBpZihvYmpbcF0ucG9zdFNjcmlwdE5hbWUhPW51bGwgJiYgb2JqW3BdLl9sYW5nPT0weDBjMGMpIHsgcmV0dXJuIG9ialtwXTsgfSB9XHRcdC8vIENhbmFkYVxuXHRmb3IodmFyIHAgaW4gb2JqKSB7IGlmKG9ialtwXS5wb3N0U2NyaXB0TmFtZSE9bnVsbCkgeyByZXR1cm4gb2JqW3BdOyB9IH1cblx0XG5cdHZhciB0bmFtZTtcblx0Zm9yKHZhciBwIGluIG9iaikgeyB0bmFtZT1wOyBicmVhazsgfVxuXHRjb25zb2xlLmxvZyhcInJldHVybmluZyBuYW1lIHRhYmxlIHdpdGggbGFuZ3VhZ2VJRCBcIisgb2JqW3RuYW1lXS5fbGFuZyk7XG5cdHJldHVybiBvYmpbdG5hbWVdO1xufTtcblxuXG5UeXByW1wiT1MvMlwiXSA9IHt9O1xuVHlwcltcIk9TLzJcIl0ucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aClcbntcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0dmFyIHZlciA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRcblx0dmFyIG9iaiA9IHt9O1xuXHRpZiAgICAgKHZlcj09MCkgeyBUeXByW1wiT1MvMlwiXS52ZXJzaW9uMChkYXRhLCBvZmZzZXQsIG9iaik7IH1cblx0ZWxzZSBpZih2ZXI9PTEpIHsgVHlwcltcIk9TLzJcIl0udmVyc2lvbjEoZGF0YSwgb2Zmc2V0LCBvYmopOyB9XG5cdGVsc2UgaWYodmVyPT0yIHx8IHZlcj09MyB8fCB2ZXI9PTQpIHsgVHlwcltcIk9TLzJcIl0udmVyc2lvbjIoZGF0YSwgb2Zmc2V0LCBvYmopOyB9XG5cdGVsc2UgaWYodmVyPT01KSB7IFR5cHJbXCJPUy8yXCJdLnZlcnNpb241KGRhdGEsIG9mZnNldCwgb2JqKTsgfVxuXHRlbHNlIHsgdGhyb3cgXCJ1bmtub3duIE9TLzIgdGFibGUgdmVyc2lvbjogXCIrdmVyOyB9XG5cdFxuXHRyZXR1cm4gb2JqO1xufTtcblxuVHlwcltcIk9TLzJcIl0udmVyc2lvbjAgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG9iailcbntcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0b2JqLnhBdmdDaGFyV2lkdGggPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRvYmoudXNXZWlnaHRDbGFzcyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRvYmoudXNXaWR0aENsYXNzICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRvYmouZnNUeXBlID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG5cdG9iai55U3Vic2NyaXB0WFNpemUgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRvYmoueVN1YnNjcmlwdFlTaXplID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcblx0b2JqLnlTdWJzY3JpcHRYT2Zmc2V0ID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcblx0b2JqLnlTdWJzY3JpcHRZT2Zmc2V0ID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjsgXG5cdG9iai55U3VwZXJzY3JpcHRYU2l6ZSA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7IFxuXHRvYmoueVN1cGVyc2NyaXB0WVNpemUgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyOyBcblx0b2JqLnlTdXBlcnNjcmlwdFhPZmZzZXQgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRvYmoueVN1cGVyc2NyaXB0WU9mZnNldCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG5cdG9iai55U3RyaWtlb3V0U2l6ZSA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG5cdG9iai55U3RyaWtlb3V0UG9zaXRpb24gPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRvYmouc0ZhbWlseUNsYXNzID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcblx0b2JqLnBhbm9zZSA9IGJpbi5yZWFkQnl0ZXMoZGF0YSwgb2Zmc2V0LCAxMCk7ICBvZmZzZXQgKz0gMTA7XG5cdG9iai51bFVuaWNvZGVSYW5nZTFcdD0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0b2JqLnVsVW5pY29kZVJhbmdlMlx0PSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuXHRvYmoudWxVbmljb2RlUmFuZ2UzXHQ9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG5cdG9iai51bFVuaWNvZGVSYW5nZTRcdD0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0b2JqLmFjaFZlbmRJRCA9IFtiaW4ucmVhZEludDgoZGF0YSwgb2Zmc2V0KSwgYmluLnJlYWRJbnQ4KGRhdGEsIG9mZnNldCsxKSxiaW4ucmVhZEludDgoZGF0YSwgb2Zmc2V0KzIpLGJpbi5yZWFkSW50OChkYXRhLCBvZmZzZXQrMyldOyAgb2Zmc2V0ICs9IDQ7XG5cdG9iai5mc1NlbGVjdGlvblx0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG5cdG9iai51c0ZpcnN0Q2hhckluZGV4ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG5cdG9iai51c0xhc3RDaGFySW5kZXggPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcblx0b2JqLnNUeXBvQXNjZW5kZXIgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRvYmouc1R5cG9EZXNjZW5kZXIgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRvYmouc1R5cG9MaW5lR2FwID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcblx0b2JqLnVzV2luQXNjZW50ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG5cdG9iai51c1dpbkRlc2NlbnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcblx0cmV0dXJuIG9mZnNldDtcbn07XG5cblR5cHJbXCJPUy8yXCJdLnZlcnNpb24xID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBvYmopXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdG9mZnNldCA9IFR5cHJbXCJPUy8yXCJdLnZlcnNpb24wKGRhdGEsIG9mZnNldCwgb2JqKTtcblx0XG5cdG9iai51bENvZGVQYWdlUmFuZ2UxID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSA0O1xuXHRvYmoudWxDb2RlUGFnZVJhbmdlMiA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gNDtcblx0cmV0dXJuIG9mZnNldDtcbn07XG5cblR5cHJbXCJPUy8yXCJdLnZlcnNpb24yID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBvYmopXG57XG5cdHZhciBiaW4gPSBUeXByLl9iaW47XG5cdG9mZnNldCA9IFR5cHJbXCJPUy8yXCJdLnZlcnNpb24xKGRhdGEsIG9mZnNldCwgb2JqKTtcblx0XG5cdG9iai5zeEhlaWdodCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG5cdG9iai5zQ2FwSGVpZ2h0ID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcblx0b2JqLnVzRGVmYXVsdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRvYmoudXNCcmVhayA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRvYmoudXNNYXhDb250ZXh0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG5cdHJldHVybiBvZmZzZXQ7XG59O1xuXG5UeXByW1wiT1MvMlwiXS52ZXJzaW9uNSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgb2JqKVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHRvZmZzZXQgPSBUeXByW1wiT1MvMlwiXS52ZXJzaW9uMihkYXRhLCBvZmZzZXQsIG9iaik7XG5cblx0b2JqLnVzTG93ZXJPcHRpY2FsUG9pbnRTaXplID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG5cdG9iai51c1VwcGVyT3B0aWNhbFBvaW50U2l6ZSA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuXHRyZXR1cm4gb2Zmc2V0O1xufTtcblxuVHlwci5wb3N0ID0ge307XG5UeXByLnBvc3QucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aClcbntcblx0dmFyIGJpbiA9IFR5cHIuX2Jpbjtcblx0dmFyIG9iaiA9IHt9O1xuXHRcblx0b2JqLnZlcnNpb24gICAgICAgICAgID0gYmluLnJlYWRGaXhlZChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz00O1xuXHRvYmouaXRhbGljQW5nbGUgICAgICAgPSBiaW4ucmVhZEZpeGVkKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTQ7XG5cdG9iai51bmRlcmxpbmVQb3NpdGlvbiA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9Mjtcblx0b2JqLnVuZGVybGluZVRoaWNrbmVzcyA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcblxuXHRyZXR1cm4gb2JqO1xufTtcblR5cHIuU1ZHID0ge307XG5UeXByLlNWRy5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoKVxue1xuXHR2YXIgYmluID0gVHlwci5fYmluO1xuXHR2YXIgb2JqID0geyBlbnRyaWVzOiBbXX07XG5cblx0dmFyIG9mZnNldDAgPSBvZmZzZXQ7XG5cblx0dmFyIHRhYmxlVmVyc2lvbiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7XHRvZmZzZXQgKz0gMjtcblx0dmFyIHN2Z0RvY0luZGV4T2Zmc2V0ID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7XHRvZmZzZXQgKz0gNDtcblx0dmFyIHJlc2VydmVkID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSA0O1xuXG5cdG9mZnNldCA9IHN2Z0RvY0luZGV4T2Zmc2V0ICsgb2Zmc2V0MDtcblxuXHR2YXIgbnVtRW50cmllcyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7XHRvZmZzZXQgKz0gMjtcblxuXHRmb3IodmFyIGk9MDsgaTxudW1FbnRyaWVzOyBpKyspXG5cdHtcblx0XHR2YXIgc3RhcnRHbHlwaElEID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuXHRcdHZhciBlbmRHbHlwaElEICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG5cdFx0dmFyIHN2Z0RvY09mZnNldCA9IGJpbi5yZWFkVWludCAgKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0XHR2YXIgc3ZnRG9jTGVuZ3RoID0gYmluLnJlYWRVaW50ICAoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuXG5cdFx0dmFyIHNidWYgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgb2Zmc2V0MCArIHN2Z0RvY09mZnNldCArIHN2Z0RvY0luZGV4T2Zmc2V0LCBzdmdEb2NMZW5ndGgpO1xuXHRcdHZhciBzdmcgPSBiaW4ucmVhZFVURjgoc2J1ZiwgMCwgc2J1Zi5sZW5ndGgpO1xuXHRcdFxuXHRcdGZvcih2YXIgZj1zdGFydEdseXBoSUQ7IGY8PWVuZEdseXBoSUQ7IGYrKykge1xuXHRcdFx0b2JqLmVudHJpZXNbZl0gPSBzdmc7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvYmo7XG59O1xuXG5UeXByLlNWRy50b1BhdGggPSBmdW5jdGlvbihzdHIpXG57XG5cdHZhciBwdGggPSB7Y21kczpbXSwgY3JkczpbXX07XG5cdGlmKHN0cj09bnVsbCkgeyByZXR1cm4gcHRoOyB9XG5cdFxuXHR2YXIgcHJzciA9IG5ldyBET01QYXJzZXIoKTtcblx0dmFyIGRvYyA9IHByc3JbXCJwYXJzZUZyb21TdHJpbmdcIl0oc3RyLFwiaW1hZ2Uvc3ZnK3htbFwiKTtcblx0XG5cdHZhciBzdmcgPSBkb2MuZmlyc3RDaGlsZDsgIHdoaWxlKHN2Zy50YWdOYW1lIT1cInN2Z1wiKSB7IHN2ZyA9IHN2Zy5uZXh0U2libGluZzsgfVxuXHR2YXIgdmIgPSBzdmcuZ2V0QXR0cmlidXRlKFwidmlld0JveFwiKTtcblx0aWYodmIpIHsgdmIgPSB2Yi50cmltKCkuc3BsaXQoXCIgXCIpLm1hcChwYXJzZUZsb2F0KTsgfSAgZWxzZSAgIHsgdmIgPSBbMCwwLDEwMDAsMTAwMF07IH1cblx0VHlwci5TVkcuX3RvUGF0aChzdmcuY2hpbGRyZW4sIHB0aCk7XG5cdGZvcih2YXIgaT0wOyBpPHB0aC5jcmRzLmxlbmd0aDsgaSs9Mikge1xuXHRcdHZhciB4ID0gcHRoLmNyZHNbaV0sIHkgPSBwdGguY3Jkc1tpKzFdO1xuXHRcdHggLT0gdmJbMF07XG5cdFx0eSAtPSB2YlsxXTtcblx0XHR5ID0gLXk7XG5cdFx0cHRoLmNyZHNbaV0gPSB4O1xuXHRcdHB0aC5jcmRzW2krMV0gPSB5O1xuXHR9XG5cdHJldHVybiBwdGg7XG59O1xuXG5UeXByLlNWRy5fdG9QYXRoID0gZnVuY3Rpb24obmRzLCBwdGgsIGZpbGwpIHtcblx0Zm9yKHZhciBuaT0wOyBuaTxuZHMubGVuZ3RoOyBuaSsrKSB7XG5cdFx0dmFyIG5kID0gbmRzW25pXSwgdG4gPSBuZC50YWdOYW1lO1xuXHRcdHZhciBjZmwgPSBuZC5nZXRBdHRyaWJ1dGUoXCJmaWxsXCIpOyAgaWYoY2ZsPT1udWxsKSB7IGNmbCA9IGZpbGw7IH1cblx0XHRpZih0bj09XCJnXCIpIHsgVHlwci5TVkcuX3RvUGF0aChuZC5jaGlsZHJlbiwgcHRoLCBjZmwpOyB9XG5cdFx0ZWxzZSBpZih0bj09XCJwYXRoXCIpIHtcblx0XHRcdHB0aC5jbWRzLnB1c2goY2ZsP2NmbDpcIiMwMDAwMDBcIik7XG5cdFx0XHR2YXIgZCA9IG5kLmdldEF0dHJpYnV0ZShcImRcIik7ICAvL2NvbnNvbGUubG9nKGQpO1xuXHRcdFx0dmFyIHRva3MgPSBUeXByLlNWRy5fdG9rZW5zKGQpOyAgLy9jb25zb2xlLmxvZyh0b2tzKTtcblx0XHRcdFR5cHIuU1ZHLl90b2tzVG9QYXRoKHRva3MsIHB0aCk7ICBwdGguY21kcy5wdXNoKFwiWFwiKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0bj09XCJkZWZzXCIpIDtcblx0XHRlbHNlIHsgY29uc29sZS5sb2codG4sIG5kKTsgfVxuXHR9XG59O1xuXG5UeXByLlNWRy5fdG9rZW5zID0gZnVuY3Rpb24oZCkge1xuXHR2YXIgdHMgPSBbXSwgb2ZmID0gMCwgcm49ZmFsc2UsIGNuPVwiXCI7ICAvLyByZWFkaW5nIG51bWJlciwgY3VycmVudCBudW1iZXJcblx0d2hpbGUob2ZmPGQubGVuZ3RoKXtcblx0XHR2YXIgY2M9ZC5jaGFyQ29kZUF0KG9mZiksIGNoID0gZC5jaGFyQXQob2ZmKTsgIG9mZisrO1xuXHRcdHZhciBpc051bSA9ICg0ODw9Y2MgJiYgY2M8PTU3KSB8fCBjaD09XCIuXCIgfHwgY2g9PVwiLVwiO1xuXHRcdFxuXHRcdGlmKHJuKSB7XG5cdFx0XHRpZihjaD09XCItXCIpIHsgIHRzLnB1c2gocGFyc2VGbG9hdChjbikpOyAgY249Y2g7ICB9XG5cdFx0XHRlbHNlIGlmKGlzTnVtKSB7IGNuKz1jaDsgfVxuXHRcdFx0ZWxzZSB7ICB0cy5wdXNoKHBhcnNlRmxvYXQoY24pKTsgIGlmKGNoIT1cIixcIiAmJiBjaCE9XCIgXCIpIHsgdHMucHVzaChjaCk7IH0gIHJuPWZhbHNlOyAgfVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmKGlzTnVtKSB7ICBjbj1jaDsgIHJuPXRydWU7ICB9XG5cdFx0XHRlbHNlIGlmKGNoIT1cIixcIiAmJiBjaCE9XCIgXCIpIHsgdHMucHVzaChjaCk7IH1cblx0XHR9XG5cdH1cblx0aWYocm4pIHsgdHMucHVzaChwYXJzZUZsb2F0KGNuKSk7IH1cblx0cmV0dXJuIHRzO1xufTtcblxuVHlwci5TVkcuX3Rva3NUb1BhdGggPSBmdW5jdGlvbih0cywgcHRoKSB7XHRcblx0dmFyIGkgPSAwLCB4ID0gMCwgeSA9IDAsIG94ID0gMCwgb3kgPSAwO1xuXHR2YXIgcGMgPSB7XCJNXCI6MixcIkxcIjoyLFwiSFwiOjEsXCJWXCI6MSwgICBcIlNcIjo0LCAgIFwiQ1wiOjZ9O1xuXHR2YXIgY21kcyA9IHB0aC5jbWRzLCBjcmRzID0gcHRoLmNyZHM7XG5cdFxuXHR3aGlsZShpPHRzLmxlbmd0aCkge1xuXHRcdHZhciBjbWQgPSB0c1tpXTsgIGkrKztcblx0XHRcblx0XHRpZihjbWQ9PVwielwiKSB7ICBjbWRzLnB1c2goXCJaXCIpOyAgeD1veDsgIHk9b3k7ICB9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgY211ID0gY21kLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR2YXIgcHMgPSBwY1tjbXVdLCByZXBzID0gVHlwci5TVkcuX3JlcHModHMsIGksIHBzKTtcblx0XHRcblx0XHRcdGZvcih2YXIgaj0wOyBqPHJlcHM7IGorKykge1xuXHRcdFx0XHR2YXIgeGkgPSAwLCB5aSA9IDA7ICAgaWYoY21kIT1jbXUpIHsgIHhpPXg7ICB5aT15OyAgfVxuXHRcdFx0XHRcblx0XHRcdFx0aWYoY211PT1cIk1cIikgeyAgeCA9IHhpK3RzW2krK107ICB5ID0geWkrdHNbaSsrXTsgIGNtZHMucHVzaChcIk1cIik7ICBjcmRzLnB1c2goeCx5KTsgIG94PXg7ICBveT15OyB9XG5cdFx0XHRcdGVsc2UgaWYoY211PT1cIkxcIikgeyAgeCA9IHhpK3RzW2krK107ICB5ID0geWkrdHNbaSsrXTsgIGNtZHMucHVzaChcIkxcIik7ICBjcmRzLnB1c2goeCx5KTsgIH1cblx0XHRcdFx0ZWxzZSBpZihjbXU9PVwiSFwiKSB7ICB4ID0geGkrdHNbaSsrXTsgICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKFwiTFwiKTsgIGNyZHMucHVzaCh4LHkpOyAgfVxuXHRcdFx0XHRlbHNlIGlmKGNtdT09XCJWXCIpIHsgIHkgPSB5aSt0c1tpKytdOyAgICAgICAgICAgICAgICAgICBjbWRzLnB1c2goXCJMXCIpOyAgY3Jkcy5wdXNoKHgseSk7ICB9XG5cdFx0XHRcdGVsc2UgaWYoY211PT1cIkNcIikge1xuXHRcdFx0XHRcdHZhciB4MT14aSt0c1tpKytdLCB5MT15aSt0c1tpKytdLCB4Mj14aSt0c1tpKytdLCB5Mj15aSt0c1tpKytdLCB4Mz14aSt0c1tpKytdLCB5Mz15aSt0c1tpKytdO1xuXHRcdFx0XHRcdGNtZHMucHVzaChcIkNcIik7ICBjcmRzLnB1c2goeDEseTEseDIseTIseDMseTMpOyAgeD14MzsgIHk9eTM7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZihjbXU9PVwiU1wiKSB7XG5cdFx0XHRcdFx0dmFyIGNvID0gTWF0aC5tYXgoY3Jkcy5sZW5ndGgtNCwgMCk7XG5cdFx0XHRcdFx0dmFyIHgxID0geCt4LWNyZHNbY29dLCB5MSA9IHkreS1jcmRzW2NvKzFdO1xuXHRcdFx0XHRcdHZhciB4Mj14aSt0c1tpKytdLCB5Mj15aSt0c1tpKytdLCB4Mz14aSt0c1tpKytdLCB5Mz15aSt0c1tpKytdOyAgXG5cdFx0XHRcdFx0Y21kcy5wdXNoKFwiQ1wiKTsgIGNyZHMucHVzaCh4MSx5MSx4Mix5Mix4Myx5Myk7ICB4PXgzOyAgeT15Mztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgY29uc29sZS5sb2coXCJVbmtub3duIFNWRyBjb21tYW5kIFwiK2NtZCk7IH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5UeXByLlNWRy5fcmVwcyA9IGZ1bmN0aW9uKHRzLCBvZmYsIHBzKSB7XG5cdHZhciBpID0gb2ZmO1xuXHR3aGlsZShpPHRzLmxlbmd0aCkgeyAgaWYoKHR5cGVvZiB0c1tpXSkgPT0gXCJzdHJpbmdcIikgeyBicmVhazsgfSAgaSs9cHM7ICB9XG5cdHJldHVybiAoaS1vZmYpL3BzO1xufTtcbi8vIEVuZCBUeXByLmpzXG5cbi8vIEJlZ2luIFR5cHIuVS5qc1xuXG5pZihUeXByICA9PW51bGwpIHsgVHlwciAgID0ge307IH1cbmlmKFR5cHIuVT09bnVsbCkgeyBUeXByLlUgPSB7fTsgfVxuXG5cblR5cHIuVS5jb2RlVG9HbHlwaCA9IGZ1bmN0aW9uKGZvbnQsIGNvZGUpXG57XG5cdHZhciBjbWFwID0gZm9udC5jbWFwO1xuXHRcblx0dmFyIHRpbmQgPSAtMTtcblx0aWYoY21hcC5wMGU0IT1udWxsKSB7IHRpbmQgPSBjbWFwLnAwZTQ7IH1cblx0ZWxzZSBpZihjbWFwLnAzZTEhPW51bGwpIHsgdGluZCA9IGNtYXAucDNlMTsgfVxuXHRlbHNlIGlmKGNtYXAucDFlMCE9bnVsbCkgeyB0aW5kID0gY21hcC5wMWUwOyB9XG5cdGVsc2UgaWYoY21hcC5wMGUzIT1udWxsKSB7IHRpbmQgPSBjbWFwLnAwZTM7IH1cblx0XG5cdGlmKHRpbmQ9PS0xKSB7IHRocm93IFwibm8gZmFtaWxpYXIgcGxhdGZvcm0gYW5kIGVuY29kaW5nIVwiOyB9XG5cdFxuXHR2YXIgdGFiID0gY21hcC50YWJsZXNbdGluZF07XG5cdFxuXHRpZih0YWIuZm9ybWF0PT0wKVxuXHR7XG5cdFx0aWYoY29kZT49dGFiLm1hcC5sZW5ndGgpIHsgcmV0dXJuIDA7IH1cblx0XHRyZXR1cm4gdGFiLm1hcFtjb2RlXTtcblx0fVxuXHRlbHNlIGlmKHRhYi5mb3JtYXQ9PTQpXG5cdHtcblx0XHR2YXIgc2luZCA9IC0xO1xuXHRcdGZvcih2YXIgaT0wOyBpPHRhYi5lbmRDb3VudC5sZW5ndGg7IGkrKykgICB7IGlmKGNvZGU8PXRhYi5lbmRDb3VudFtpXSl7ICBzaW5kPWk7ICBicmVhazsgIH0gfSBcblx0XHRpZihzaW5kPT0tMSkgeyByZXR1cm4gMDsgfVxuXHRcdGlmKHRhYi5zdGFydENvdW50W3NpbmRdPmNvZGUpIHsgcmV0dXJuIDA7IH1cblx0XHRcblx0XHR2YXIgZ2xpID0gMDtcblx0XHRpZih0YWIuaWRSYW5nZU9mZnNldFtzaW5kXSE9MCkgeyBnbGkgPSB0YWIuZ2x5cGhJZEFycmF5Wyhjb2RlLXRhYi5zdGFydENvdW50W3NpbmRdKSArICh0YWIuaWRSYW5nZU9mZnNldFtzaW5kXT4+MSkgLSAodGFiLmlkUmFuZ2VPZmZzZXQubGVuZ3RoLXNpbmQpXTsgfVxuXHRcdGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGdsaSA9IGNvZGUgKyB0YWIuaWREZWx0YVtzaW5kXTsgfVxuXHRcdHJldHVybiBnbGkgJiAweEZGRkY7XG5cdH1cblx0ZWxzZSBpZih0YWIuZm9ybWF0PT0xMilcblx0e1xuXHRcdGlmKGNvZGU+dGFiLmdyb3Vwc1t0YWIuZ3JvdXBzLmxlbmd0aC0xXVsxXSkgeyByZXR1cm4gMDsgfVxuXHRcdGZvcih2YXIgaT0wOyBpPHRhYi5ncm91cHMubGVuZ3RoOyBpKyspXG5cdFx0e1xuXHRcdFx0dmFyIGdycCA9IHRhYi5ncm91cHNbaV07XG5cdFx0XHRpZihncnBbMF08PWNvZGUgJiYgY29kZTw9Z3JwWzFdKSB7IHJldHVybiBncnBbMl0gKyAoY29kZS1ncnBbMF0pOyB9XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9XG5cdGVsc2UgeyB0aHJvdyBcInVua25vd24gY21hcCB0YWJsZSBmb3JtYXQgXCIrdGFiLmZvcm1hdDsgfVxufTtcblxuXG5UeXByLlUuZ2x5cGhUb1BhdGggPSBmdW5jdGlvbihmb250LCBnaWQpXG57XG5cdHZhciBwYXRoID0geyBjbWRzOltdLCBjcmRzOltdIH07XG5cdGlmKGZvbnQuU1ZHICYmIGZvbnQuU1ZHLmVudHJpZXNbZ2lkXSkge1xuXHRcdHZhciBwID0gZm9udC5TVkcuZW50cmllc1tnaWRdOyAgaWYocD09bnVsbCkgeyByZXR1cm4gcGF0aDsgfVxuXHRcdGlmKHR5cGVvZiBwID09IFwic3RyaW5nXCIpIHsgIHAgPSBUeXByLlNWRy50b1BhdGgocCk7ICBmb250LlNWRy5lbnRyaWVzW2dpZF09cDsgIH1cblx0XHRyZXR1cm4gcDtcblx0fVxuXHRlbHNlIGlmKGZvbnQuQ0ZGKSB7XG5cdFx0dmFyIHN0YXRlID0ge3g6MCx5OjAsc3RhY2s6W10sblN0ZW1zOjAsaGF2ZVdpZHRoOmZhbHNlLHdpZHRoOiBmb250LkNGRi5Qcml2YXRlID8gZm9udC5DRkYuUHJpdmF0ZS5kZWZhdWx0V2lkdGhYIDogMCxvcGVuOmZhbHNlfTtcblx0XHR2YXIgY2ZmPWZvbnQuQ0ZGLCBwZGN0ID0gZm9udC5DRkYuUHJpdmF0ZTtcblx0XHRpZihjZmYuUk9TKSB7XG5cdFx0XHR2YXIgZ2kgPSAwO1xuXHRcdFx0d2hpbGUoY2ZmLkZEU2VsZWN0W2dpKzJdPD1naWQpIHsgZ2krPTI7IH1cblx0XHRcdHBkY3QgPSBjZmYuRkRBcnJheVtjZmYuRkRTZWxlY3RbZ2krMV1dLlByaXZhdGU7XG5cdFx0fVxuXHRcdFR5cHIuVS5fZHJhd0NGRihmb250LkNGRi5DaGFyU3RyaW5nc1tnaWRdLCBzdGF0ZSwgY2ZmLCBwZGN0LCBwYXRoKTtcblx0fVxuXHRlbHNlIGlmKGZvbnQuZ2x5ZikgeyAgVHlwci5VLl9kcmF3R2x5ZihnaWQsIGZvbnQsIHBhdGgpOyAgfVxuXHRyZXR1cm4gcGF0aDtcbn07XG5cblR5cHIuVS5fZHJhd0dseWYgPSBmdW5jdGlvbihnaWQsIGZvbnQsIHBhdGgpXG57XG5cdHZhciBnbCA9IGZvbnQuZ2x5ZltnaWRdO1xuXHRpZihnbD09bnVsbCkgeyBnbCA9IGZvbnQuZ2x5ZltnaWRdID0gVHlwci5nbHlmLl9wYXJzZUdseWYoZm9udCwgZ2lkKTsgfVxuXHRpZihnbCE9bnVsbCl7XG5cdFx0aWYoZ2wubm9jPi0xKSB7IFR5cHIuVS5fc2ltcGxlR2x5cGgoZ2wsIHBhdGgpOyB9XG5cdFx0ZWxzZSAgICAgICAgICB7IFR5cHIuVS5fY29tcG9HbHlwaCAoZ2wsIGZvbnQsIHBhdGgpOyB9XG5cdH1cbn07XG5UeXByLlUuX3NpbXBsZUdseXBoID0gZnVuY3Rpb24oZ2wsIHApXG57XG5cdGZvcih2YXIgYz0wOyBjPGdsLm5vYzsgYysrKVxuXHR7XG5cdFx0dmFyIGkwID0gKGM9PTApID8gMCA6IChnbC5lbmRQdHNbYy0xXSArIDEpO1xuXHRcdHZhciBpbCA9IGdsLmVuZFB0c1tjXTtcblx0XHRcblx0XHRmb3IodmFyIGk9aTA7IGk8PWlsOyBpKyspXG5cdFx0e1xuXHRcdFx0dmFyIHByID0gKGk9PWkwKT9pbDooaS0xKTtcblx0XHRcdHZhciBueCA9IChpPT1pbCk/aTA6KGkrMSk7XG5cdFx0XHR2YXIgb25DdXJ2ZSA9IGdsLmZsYWdzW2ldJjE7XG5cdFx0XHR2YXIgcHJPbkN1cnZlID0gZ2wuZmxhZ3NbcHJdJjE7XG5cdFx0XHR2YXIgbnhPbkN1cnZlID0gZ2wuZmxhZ3NbbnhdJjE7XG5cdFx0XHRcblx0XHRcdHZhciB4ID0gZ2wueHNbaV0sIHkgPSBnbC55c1tpXTtcblx0XHRcdFxuXHRcdFx0aWYoaT09aTApIHsgXG5cdFx0XHRcdGlmKG9uQ3VydmUpICBcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmKHByT25DdXJ2ZSkgeyBUeXByLlUuUC5tb3ZlVG8ocCwgZ2wueHNbcHJdLCBnbC55c1twcl0pOyB9IFxuXHRcdFx0XHRcdGVsc2UgICAgICAgICAgeyAgVHlwci5VLlAubW92ZVRvKHAseCx5KTsgIGNvbnRpbnVlOyAgLyogIHdpbGwgZG8gY3VydmVUbyBhdCBpbCAgKi8gIH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlICAgICAgICBcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmKHByT25DdXJ2ZSkgeyBUeXByLlUuUC5tb3ZlVG8ocCwgIGdsLnhzW3ByXSwgICAgICAgZ2wueXNbcHJdICAgICAgICApOyB9XG5cdFx0XHRcdFx0ZWxzZSAgICAgICAgICB7IFR5cHIuVS5QLm1vdmVUbyhwLCAoZ2wueHNbcHJdK3gpLzIsIChnbC55c1twcl0reSkvMiAgICk7IH0gXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKG9uQ3VydmUpXG5cdFx0XHR7XG5cdFx0XHRcdGlmKHByT25DdXJ2ZSkgeyBUeXByLlUuUC5saW5lVG8ocCx4LHkpOyB9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGlmKG54T25DdXJ2ZSkgeyBUeXByLlUuUC5xY3VydmVUbyhwLCB4LCB5LCBnbC54c1tueF0sIGdsLnlzW254XSk7IH0gXG5cdFx0XHRcdGVsc2UgICAgICAgICAgeyBUeXByLlUuUC5xY3VydmVUbyhwLCB4LCB5LCAoeCtnbC54c1tueF0pLzIsICh5K2dsLnlzW254XSkvMik7IH0gXG5cdFx0XHR9XG5cdFx0fVxuXHRcdFR5cHIuVS5QLmNsb3NlUGF0aChwKTtcblx0fVxufTtcblR5cHIuVS5fY29tcG9HbHlwaCA9IGZ1bmN0aW9uKGdsLCBmb250LCBwKVxue1xuXHRmb3IodmFyIGo9MDsgajxnbC5wYXJ0cy5sZW5ndGg7IGorKylcblx0e1xuXHRcdHZhciBwYXRoID0geyBjbWRzOltdLCBjcmRzOltdIH07XG5cdFx0dmFyIHBydCA9IGdsLnBhcnRzW2pdO1xuXHRcdFR5cHIuVS5fZHJhd0dseWYocHJ0LmdseXBoSW5kZXgsIGZvbnQsIHBhdGgpO1xuXHRcdFxuXHRcdHZhciBtID0gcHJ0Lm07XG5cdFx0Zm9yKHZhciBpPTA7IGk8cGF0aC5jcmRzLmxlbmd0aDsgaSs9Milcblx0XHR7XG5cdFx0XHR2YXIgeCA9IHBhdGguY3Jkc1tpICBdLCB5ID0gcGF0aC5jcmRzW2krMV07XG5cdFx0XHRwLmNyZHMucHVzaCh4Km0uYSArIHkqbS5iICsgbS50eCk7XG5cdFx0XHRwLmNyZHMucHVzaCh4Km0uYyArIHkqbS5kICsgbS50eSk7XG5cdFx0fVxuXHRcdGZvcih2YXIgaT0wOyBpPHBhdGguY21kcy5sZW5ndGg7IGkrKykgeyBwLmNtZHMucHVzaChwYXRoLmNtZHNbaV0pOyB9XG5cdH1cbn07XG5cblxuVHlwci5VLl9nZXRHbHlwaENsYXNzID0gZnVuY3Rpb24oZywgY2QpXG57XG5cdHZhciBpbnRyID0gVHlwci5fbGN0Zi5nZXRJbnRlcnZhbChjZCwgZyk7XG5cdHJldHVybiBpbnRyPT0tMSA/IDAgOiBjZFtpbnRyKzJdO1xuXHQvL2Zvcih2YXIgaT0wOyBpPGNkLnN0YXJ0Lmxlbmd0aDsgaSsrKSBcblx0Ly9cdGlmKGNkLnN0YXJ0W2ldPD1nICYmIGNkLmVuZFtpXT49ZykgcmV0dXJuIGNkLmNsYXNzW2ldO1xuXHQvL3JldHVybiAwO1xufTtcblxuVHlwci5VLmdldFBhaXJBZGp1c3RtZW50ID0gZnVuY3Rpb24oZm9udCwgZzEsIGcyKVxue1xuXHQvL3JldHVybiAwO1xuXHRpZihmb250LkdQT1MpIHtcblx0XHR2YXIgZ3BvcyA9IGZvbnRbXCJHUE9TXCJdO1xuXHRcdHZhciBsbGlzdCA9IGdwb3MubG9va3VwTGlzdCwgZmxpc3QgPSBncG9zLmZlYXR1cmVMaXN0O1xuXHRcdHZhciB0dXNlZCA9IFtdO1xuXHRcdGZvcih2YXIgaT0wOyBpPGZsaXN0Lmxlbmd0aDsgaSsrKSBcblx0XHR7XG5cdFx0XHR2YXIgZmwgPSBmbGlzdFtpXTsgIC8vY29uc29sZS5sb2coZmwpO1xuXHRcdFx0aWYoZmwudGFnIT1cImtlcm5cIikgeyBjb250aW51ZTsgfVxuXHRcdFx0Zm9yKHZhciB0aT0wOyB0aTxmbC50YWIubGVuZ3RoOyB0aSsrKSB7XG5cdFx0XHRcdGlmKHR1c2VkW2ZsLnRhYlt0aV1dKSB7IGNvbnRpbnVlOyB9ICB0dXNlZFtmbC50YWJbdGldXSA9IHRydWU7XG5cdFx0XHRcdHZhciB0YWIgPSBsbGlzdFtmbC50YWJbdGldXTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyh0YWIpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yKHZhciBqPTA7IGo8dGFiLnRhYnMubGVuZ3RoOyBqKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZih0YWIudGFic1tpXT09bnVsbCkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRcdHZhciBsdGFiID0gdGFiLnRhYnNbal0sIGluZDtcblx0XHRcdFx0XHRpZihsdGFiLmNvdmVyYWdlKSB7ICBpbmQgPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgobHRhYi5jb3ZlcmFnZSwgZzEpOyAgaWYoaW5kPT0tMSkgeyBjb250aW51ZTsgfSAgfVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmKHRhYi5sdHlwZT09MSkgO1xuXHRcdFx0XHRcdGVsc2UgaWYodGFiLmx0eXBlPT0yKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBhZGo7XG5cdFx0XHRcdFx0XHRpZihsdGFiLmZtdD09MSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIHJpZ2h0ID0gbHRhYi5wYWlyc2V0c1tpbmRdO1xuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGk9MDsgaTxyaWdodC5sZW5ndGg7IGkrKykgeyBpZihyaWdodFtpXS5naWQyPT1nMikgeyBhZGogPSByaWdodFtpXTsgfSB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmKGx0YWIuZm10PT0yKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR2YXIgYzEgPSBUeXByLlUuX2dldEdseXBoQ2xhc3MoZzEsIGx0YWIuY2xhc3NEZWYxKTtcblx0XHRcdFx0XHRcdFx0dmFyIGMyID0gVHlwci5VLl9nZXRHbHlwaENsYXNzKGcyLCBsdGFiLmNsYXNzRGVmMik7XG5cdFx0XHRcdFx0XHRcdGFkaiA9IGx0YWIubWF0cml4W2MxXVtjMl07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL2lmKGFkaikgY29uc29sZS5sb2cobHRhYiwgYWRqKTtcblx0XHRcdFx0XHRcdGlmKGFkaiAmJiBhZGoudmFsMikgeyByZXR1cm4gYWRqLnZhbDJbMl07IH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYoZm9udC5rZXJuKVxuXHR7XG5cdFx0dmFyIGluZDEgPSBmb250Lmtlcm4uZ2x5cGgxLmluZGV4T2YoZzEpO1xuXHRcdGlmKGluZDEhPS0xKVxuXHRcdHtcblx0XHRcdHZhciBpbmQyID0gZm9udC5rZXJuLnJ2YWxbaW5kMV0uZ2x5cGgyLmluZGV4T2YoZzIpO1xuXHRcdFx0aWYoaW5kMiE9LTEpIHsgcmV0dXJuIGZvbnQua2Vybi5ydmFsW2luZDFdLnZhbHNbaW5kMl07IH1cblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiAwO1xufTtcblxuVHlwci5VLnN0cmluZ1RvR2x5cGhzID0gZnVuY3Rpb24oZm9udCwgc3RyKVxue1xuXHR2YXIgZ2xzID0gW107XG5cdGZvcih2YXIgaT0wOyBpPHN0ci5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjYyA9IHN0ci5jb2RlUG9pbnRBdChpKTsgIGlmKGNjPjB4ZmZmZikgeyBpKys7IH1cblx0XHRnbHMucHVzaChUeXByLlUuY29kZVRvR2x5cGgoZm9udCwgY2MpKTtcblx0fVxuXHRmb3IodmFyIGk9MDsgaTxzdHIubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY2MgPSBzdHIuY29kZVBvaW50QXQoaSk7ICAvL1xuXHRcdGlmKGNjPT0yMzY3KSB7ICB2YXIgdD1nbHNbaS0xXTsgIGdsc1tpLTFdPWdsc1tpXTsgIGdsc1tpXT10OyAgfVxuXHRcdC8vaWYoY2M9PTIzODEpIHsgIHZhciB0PWdsc1tpKzFdOyAgZ2xzW2krMV09Z2xzW2ldOyAgZ2xzW2ldPXQ7ICB9XG5cdFx0aWYoY2M+MHhmZmZmKSB7IGkrKzsgfVxuXHR9XG5cdC8vY29uc29sZS5sb2coZ2xzLnNsaWNlKDApKTtcblx0XG5cdC8vY29uc29sZS5sb2coZ2xzKTsgIHJldHVybiBnbHM7XG5cdFxuXHR2YXIgZ3N1YiA9IGZvbnRbXCJHU1VCXCJdOyAgaWYoZ3N1Yj09bnVsbCkgeyByZXR1cm4gZ2xzOyB9XG5cdHZhciBsbGlzdCA9IGdzdWIubG9va3VwTGlzdCwgZmxpc3QgPSBnc3ViLmZlYXR1cmVMaXN0O1xuXHRcblx0dmFyIGNsaWdzID0gW1wicmxpZ1wiLCBcImxpZ2FcIiwgXCJtc2V0XCIsICBcImlzb2xcIixcImluaXRcIixcImZpbmFcIixcIm1lZGlcIiwgICBcImhhbGZcIiwgXCJwcmVzXCIsIFxuXHRcdFx0XHRcImJsd3NcIiAvKiBUaWJldGFuIGZvbnRzIGxpa2UgSGltYWxheWEudHRmICovIF07XG5cdFxuXHQvL2NvbnNvbGUubG9nKGdscy5zbGljZSgwKSk7XG5cdHZhciB0dXNlZCA9IFtdO1xuXHRmb3IodmFyIGZpPTA7IGZpPGZsaXN0Lmxlbmd0aDsgZmkrKylcblx0e1xuXHRcdHZhciBmbCA9IGZsaXN0W2ZpXTsgIGlmKGNsaWdzLmluZGV4T2YoZmwudGFnKT09LTEpIHsgY29udGludWU7IH1cblx0XHQvL2lmKGZsLnRhZz09XCJibHdmXCIpIGNvbnRpbnVlO1xuXHRcdC8vY29uc29sZS5sb2coZmwpO1xuXHRcdC8vY29uc29sZS5sb2coZmwudGFnKTtcblx0XHRmb3IodmFyIHRpPTA7IHRpPGZsLnRhYi5sZW5ndGg7IHRpKyspIHtcblx0XHRcdGlmKHR1c2VkW2ZsLnRhYlt0aV1dKSB7IGNvbnRpbnVlOyB9ICB0dXNlZFtmbC50YWJbdGldXSA9IHRydWU7XG5cdFx0XHR2YXIgdGFiID0gbGxpc3RbZmwudGFiW3RpXV07XG5cdFx0XHQvL2NvbnNvbGUubG9nKGZsLnRhYlt0aV0sIHRhYi5sdHlwZSk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKGZsLnRhZywgdGFiKTtcblx0XHRcdGZvcih2YXIgY2k9MDsgY2k8Z2xzLmxlbmd0aDsgY2krKykge1xuXHRcdFx0XHR2YXIgZmVhdCA9IFR5cHIuVS5fZ2V0V1BmZWF0dXJlKHN0ciwgY2kpO1xuXHRcdFx0XHRpZihcImlzb2wsaW5pdCxmaW5hLG1lZGlcIi5pbmRleE9mKGZsLnRhZykhPS0xICYmIGZsLnRhZyE9ZmVhdCkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRcblx0XHRcdFx0VHlwci5VLl9hcHBseVN1YnMoZ2xzLCBjaSwgdGFiLCBsbGlzdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXR1cm4gZ2xzO1xufTtcblR5cHIuVS5fZ2V0V1BmZWF0dXJlID0gZnVuY3Rpb24oc3RyLCBjaSkgeyAgLy8gZ2V0IFdvcmQgUG9zaXRpb24gZmVhdHVyZVxuXHR2YXIgd3NlcCA9IFwiXFxuXFx0XFxcIiAsLjo7IT8oKSAg2IxcIjtcblx0dmFyIFIgPSBcItii2KPYpNil2KfYqdiv2LDYsdiy2YjZsdmy2bPZtdm22bfaiNqJ2orai9qM2o3ajtqP2pDakdqS2pPalNqV2pbal9qY2pnbgNuD24TbhduG24fbiNuJ24rbi9uN24/bktuT25Xbrtuv3JDcldyW3JfcmNyZ3J7cqNyq3Kzcr92N3Zndmt2b3avdrN2x3bPdtN243bngoYDgoYbgoYfgoYngoZTgoafgoangoargoqrgoqvgoqzgoq7gorHgorLgorngq4Xgq4fgq4ngq4rgq47gq4/gq5Dgq5Hgq5Lgq53gq6Hgq6Tgq6/groHgroPgroTgroXgrongrozgro7gro/grpHgrqngrqrgrqvgrqxcIjtcblx0dmFyIEwgPSBcIuqhsuCrjeCrl1wiO1xuXHRcblx0dmFyIHNsZnQgPSBjaT09MCAgICAgICAgICAgIHx8IHdzZXAuaW5kZXhPZihzdHJbY2ktMV0pIT0tMTtcblx0dmFyIHNyZ3QgPSBjaT09c3RyLmxlbmd0aC0xIHx8IHdzZXAuaW5kZXhPZihzdHJbY2krMV0pIT0tMTtcblx0XHRcblx0aWYoIXNsZnQgJiYgUi5pbmRleE9mKHN0cltjaS0xXSkhPS0xKSB7IHNsZnQ9dHJ1ZTsgfVxuXHRpZighc3JndCAmJiBSLmluZGV4T2Yoc3RyW2NpICBdKSE9LTEpIHsgc3JndD10cnVlOyB9XG5cdFx0XG5cdGlmKCFzcmd0ICYmIEwuaW5kZXhPZihzdHJbY2krMV0pIT0tMSkgeyBzcmd0PXRydWU7IH1cblx0aWYoIXNsZnQgJiYgTC5pbmRleE9mKHN0cltjaSAgXSkhPS0xKSB7IHNsZnQ9dHJ1ZTsgfVxuXHRcdFxuXHR2YXIgZmVhdCA9IG51bGw7XG5cdGlmKHNsZnQpIHsgZmVhdCA9IHNyZ3QgPyBcImlzb2xcIiA6IFwiaW5pdFwiOyB9XG5cdGVsc2UgICAgIHsgZmVhdCA9IHNyZ3QgPyBcImZpbmFcIiA6IFwibWVkaVwiOyB9XG5cdFxuXHRyZXR1cm4gZmVhdDtcbn07XG5UeXByLlUuX2FwcGx5U3VicyA9IGZ1bmN0aW9uKGdscywgY2ksIHRhYiwgbGxpc3QpIHtcblx0dmFyIHJsaW0gPSBnbHMubGVuZ3RoLWNpLTE7XG5cdC8vaWYoY2k9PTApIGNvbnNvbGUubG9nKFwiKysrKyBcIiwgdGFiLmx0eXBlKTtcblx0Zm9yKHZhciBqPTA7IGo8dGFiLnRhYnMubGVuZ3RoOyBqKyspXG5cdHtcblx0XHRpZih0YWIudGFic1tqXT09bnVsbCkgeyBjb250aW51ZTsgfVxuXHRcdHZhciBsdGFiID0gdGFiLnRhYnNbal0sIGluZDtcblx0XHRpZihsdGFiLmNvdmVyYWdlKSB7ICBpbmQgPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgobHRhYi5jb3ZlcmFnZSwgZ2xzW2NpXSk7ICBpZihpbmQ9PS0xKSB7IGNvbnRpbnVlOyB9ICB9XG5cdFx0Ly9pZihjaT09MCkgY29uc29sZS5sb2coaW5kLCBsdGFiKTtcblx0XHQvLypcblx0XHRpZih0YWIubHR5cGU9PTEpIHtcblx0XHRcdHZhciBnbCA9IGdsc1tjaV07XG5cdFx0XHRpZihsdGFiLmZtdD09MSkgeyBnbHNbY2ldID0gZ2xzW2NpXStsdGFiLmRlbHRhOyB9XG5cdFx0XHRlbHNlICAgICAgICAgICAgeyBnbHNbY2ldID0gbHRhYi5uZXdnW2luZF07IH1cblx0XHRcdC8vY29uc29sZS5sb2coXCJhcHBseWluZyAuLi4gMVwiLCBjaSwgZ2wsIGdsc1tjaV0pO1xuXHRcdH0vLypcblx0XHRlbHNlIGlmKHRhYi5sdHlwZT09NCkge1xuXHRcdFx0dmFyIHZhbHMgPSBsdGFiLnZhbHNbaW5kXTtcblx0XHRcdFxuXHRcdFx0Zm9yKHZhciBrPTA7IGs8dmFscy5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHR2YXIgbGlnID0gdmFsc1trXSwgcmwgPSBsaWcuY2hhaW4ubGVuZ3RoOyAgaWYocmw+cmxpbSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHR2YXIgZ29vZCA9IHRydWUsIGVtMSA9IDA7XG5cdFx0XHRcdGZvcih2YXIgbD0wOyBsPHJsOyBsKyspIHsgIHdoaWxlKGdsc1tjaStlbTErKDErbCldPT0tMSl7IGVtMSsrOyB9ICBpZihsaWcuY2hhaW5bbF0hPWdsc1tjaStlbTErKDErbCldKSB7IGdvb2Q9ZmFsc2U7IH0gIH1cblx0XHRcdFx0aWYoIWdvb2QpIHsgY29udGludWU7IH1cblx0XHRcdFx0Z2xzW2NpXT1saWcubmdseXBoO1xuXHRcdFx0XHRmb3IodmFyIGw9MDsgbDxybCtlbTE7IGwrKykgeyBnbHNbY2krbCsxXT0tMTsgfSAgIGJyZWFrOyAgLy8gZmlyc3QgY2hhcmFjdGVyIGNoYW5nZWQsIG90aGVyIGxpZ2F0dXJlcyBkbyBub3QgYXBwbHkgYW55bW9yZVxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwibGlnXCIsIGNpLCBsaWcuY2hhaW4sIGxpZy5uZ2x5cGgpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiYXBwbHlpbmcgLi4uXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlICBpZih0YWIubHR5cGU9PTUgJiYgbHRhYi5mbXQ9PTIpIHtcblx0XHRcdHZhciBjaW5kID0gVHlwci5fbGN0Zi5nZXRJbnRlcnZhbChsdGFiLmNEZWYsIGdsc1tjaV0pO1xuXHRcdFx0dmFyIGNscyA9IGx0YWIuY0RlZltjaW5kKzJdLCBzY3MgPSBsdGFiLnNjc2V0W2Nsc107IFxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8c2NzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzYyA9IHNjc1tpXSwgaW5wID0gc2MuaW5wdXQ7XG5cdFx0XHRcdGlmKGlucC5sZW5ndGg+cmxpbSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHR2YXIgZ29vZCA9IHRydWU7XG5cdFx0XHRcdGZvcih2YXIgbD0wOyBsPGlucC5sZW5ndGg7IGwrKykge1xuXHRcdFx0XHRcdHZhciBjaW5kMiA9IFR5cHIuX2xjdGYuZ2V0SW50ZXJ2YWwobHRhYi5jRGVmLCBnbHNbY2krMStsXSk7XG5cdFx0XHRcdFx0aWYoY2luZD09LTEgJiYgbHRhYi5jRGVmW2NpbmQyKzJdIT1pbnBbbF0pIHsgIGdvb2Q9ZmFsc2U7ICBicmVhazsgIH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZighZ29vZCkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKGNpLCBnbCk7XG5cdFx0XHRcdHZhciBscnMgPSBzYy5zdWJzdExvb2t1cFJlY29yZHM7XG5cdFx0XHRcdGZvcih2YXIgaz0wOyBrPGxycy5sZW5ndGg7IGsrPTIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgZ2kgPSBscnNba10sIHRhYmkgPSBscnNbaysxXTtcblx0XHRcdFx0XHQvL1R5cHIuVS5fYXBwbHlUeXBlMShnbHMsIGNpK2dpLCBsbGlzdFt0YWJpXSk7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyh0YWJpLCBnbHNbY2krZ2ldLCBsbGlzdFt0YWJpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZih0YWIubHR5cGU9PTYgJiYgbHRhYi5mbXQ9PTMpIHtcblx0XHRcdC8vaWYobHRhYi5iYWNrQ3ZnLmxlbmd0aD09MCkgcmV0dXJuO1xuXHRcdFx0aWYoIVR5cHIuVS5fZ2xzQ292ZXJlZChnbHMsIGx0YWIuYmFja0N2ZywgY2ktbHRhYi5iYWNrQ3ZnLmxlbmd0aCkpIHsgY29udGludWU7IH1cblx0XHRcdGlmKCFUeXByLlUuX2dsc0NvdmVyZWQoZ2xzLCBsdGFiLmlucHRDdmcsIGNpKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0aWYoIVR5cHIuVS5fZ2xzQ292ZXJlZChnbHMsIGx0YWIuYWhlZEN2ZywgY2krbHRhYi5pbnB0Q3ZnLmxlbmd0aCkpIHsgY29udGludWU7IH1cblx0XHRcdC8vY29uc29sZS5sb2coY2ksIGx0YWIpO1xuXHRcdFx0dmFyIGxyID0gbHRhYi5sb29rdXBSZWM7ICAvL2NvbnNvbGUubG9nKGNpLCBnbCwgbHIpO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bHIubGVuZ3RoOyBpKz0yKSB7XG5cdFx0XHRcdHZhciBjaW5kID0gbHJbaV0sIHRhYjIgPSBsbGlzdFtscltpKzFdXTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIi1cIiwgbHJbaSsxXSwgdGFiMik7XG5cdFx0XHRcdFR5cHIuVS5fYXBwbHlTdWJzKGdscywgY2krY2luZCwgdGFiMiwgbGxpc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvL2Vsc2UgY29uc29sZS5sb2coXCJVbmtub3duIHRhYmxlXCIsIHRhYi5sdHlwZSwgbHRhYi5mbXQpO1xuXHRcdC8vKi9cblx0fVxufTtcblxuVHlwci5VLl9nbHNDb3ZlcmVkID0gZnVuY3Rpb24oZ2xzLCBjdmdzLCBjaSkge1xuXHRmb3IodmFyIGk9MDsgaTxjdmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGluZCA9IFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleChjdmdzW2ldLCBnbHNbY2kraV0pOyAgaWYoaW5kPT0tMSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblR5cHIuVS5nbHlwaHNUb1BhdGggPSBmdW5jdGlvbihmb250LCBnbHMsIGNscilcbntcdFxuXHQvL2dscyA9IGdscy5yZXZlcnNlKCk7Ly9nbHMuc2xpY2UoMCwxMikuY29uY2F0KGdscy5zbGljZSgxMikucmV2ZXJzZSgpKTtcblx0XG5cdHZhciB0cGF0aCA9IHtjbWRzOltdLCBjcmRzOltdfTtcblx0dmFyIHggPSAwO1xuXHRcblx0Zm9yKHZhciBpPTA7IGk8Z2xzLmxlbmd0aDsgaSsrKVxuXHR7XG5cdFx0dmFyIGdpZCA9IGdsc1tpXTsgIGlmKGdpZD09LTEpIHsgY29udGludWU7IH1cblx0XHR2YXIgZ2lkMiA9IChpPGdscy5sZW5ndGgtMSAmJiBnbHNbaSsxXSE9LTEpICA/IGdsc1tpKzFdIDogMDtcblx0XHR2YXIgcGF0aCA9IFR5cHIuVS5nbHlwaFRvUGF0aChmb250LCBnaWQpO1xuXHRcdGZvcih2YXIgaj0wOyBqPHBhdGguY3Jkcy5sZW5ndGg7IGorPTIpXG5cdFx0e1xuXHRcdFx0dHBhdGguY3Jkcy5wdXNoKHBhdGguY3Jkc1tqXSArIHgpO1xuXHRcdFx0dHBhdGguY3Jkcy5wdXNoKHBhdGguY3Jkc1tqKzFdKTtcblx0XHR9XG5cdFx0aWYoY2xyKSB7IHRwYXRoLmNtZHMucHVzaChjbHIpOyB9XG5cdFx0Zm9yKHZhciBqPTA7IGo8cGF0aC5jbWRzLmxlbmd0aDsgaisrKSB7IHRwYXRoLmNtZHMucHVzaChwYXRoLmNtZHNbal0pOyB9XG5cdFx0aWYoY2xyKSB7IHRwYXRoLmNtZHMucHVzaChcIlhcIik7IH1cblx0XHR4ICs9IGZvbnQuaG10eC5hV2lkdGhbZ2lkXTsvLyAtIGZvbnQuaG10eC5sc0JlYXJpbmdbZ2lkXTtcblx0XHRpZihpPGdscy5sZW5ndGgtMSkgeyB4ICs9IFR5cHIuVS5nZXRQYWlyQWRqdXN0bWVudChmb250LCBnaWQsIGdpZDIpOyB9XG5cdH1cblx0cmV0dXJuIHRwYXRoO1xufTtcblxuVHlwci5VLnBhdGhUb1NWRyA9IGZ1bmN0aW9uKHBhdGgsIHByZWMpXG57XG5cdGlmKHByZWM9PW51bGwpIHsgcHJlYyA9IDU7IH1cblx0dmFyIG91dCA9IFtdLCBjbyA9IDAsIGxtYXAgPSB7XCJNXCI6MixcIkxcIjoyLFwiUVwiOjQsXCJDXCI6Nn07XG5cdGZvcih2YXIgaT0wOyBpPHBhdGguY21kcy5sZW5ndGg7IGkrKylcblx0e1xuXHRcdHZhciBjbWQgPSBwYXRoLmNtZHNbaV0sIGNuID0gY28rKGxtYXBbY21kXT9sbWFwW2NtZF06MCk7ICBcblx0XHRvdXQucHVzaChjbWQpO1xuXHRcdHdoaWxlKGNvPGNuKSB7ICB2YXIgYyA9IHBhdGguY3Jkc1tjbysrXTsgIG91dC5wdXNoKHBhcnNlRmxvYXQoYy50b0ZpeGVkKHByZWMpKSsoY289PWNuP1wiXCI6XCIgXCIpKTsgIH1cblx0fVxuXHRyZXR1cm4gb3V0LmpvaW4oXCJcIik7XG59O1xuXG5UeXByLlUucGF0aFRvQ29udGV4dCA9IGZ1bmN0aW9uKHBhdGgsIGN0eClcbntcblx0dmFyIGMgPSAwLCBjcmRzID0gcGF0aC5jcmRzO1xuXHRcblx0Zm9yKHZhciBqPTA7IGo8cGF0aC5jbWRzLmxlbmd0aDsgaisrKVxuXHR7XG5cdFx0dmFyIGNtZCA9IHBhdGguY21kc1tqXTtcblx0XHRpZiAgICAgKGNtZD09XCJNXCIpIHtcblx0XHRcdGN0eC5tb3ZlVG8oY3Jkc1tjXSwgY3Jkc1tjKzFdKTtcblx0XHRcdGMrPTI7XG5cdFx0fVxuXHRcdGVsc2UgaWYoY21kPT1cIkxcIikge1xuXHRcdFx0Y3R4LmxpbmVUbyhjcmRzW2NdLCBjcmRzW2MrMV0pO1xuXHRcdFx0Yys9Mjtcblx0XHR9XG5cdFx0ZWxzZSBpZihjbWQ9PVwiQ1wiKSB7XG5cdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjcmRzW2NdLCBjcmRzW2MrMV0sIGNyZHNbYysyXSwgY3Jkc1tjKzNdLCBjcmRzW2MrNF0sIGNyZHNbYys1XSk7XG5cdFx0XHRjKz02O1xuXHRcdH1cblx0XHRlbHNlIGlmKGNtZD09XCJRXCIpIHtcblx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNyZHNbY10sIGNyZHNbYysxXSwgY3Jkc1tjKzJdLCBjcmRzW2MrM10pO1xuXHRcdFx0Yys9NDtcblx0XHR9XG5cdFx0ZWxzZSBpZihjbWQuY2hhckF0KDApPT1cIiNcIikge1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNtZDtcblx0XHR9XG5cdFx0ZWxzZSBpZihjbWQ9PVwiWlwiKSB7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYoY21kPT1cIlhcIikge1xuXHRcdFx0Y3R4LmZpbGwoKTtcblx0XHR9XG5cdH1cbn07XG5cblxuVHlwci5VLlAgPSB7fTtcblR5cHIuVS5QLm1vdmVUbyA9IGZ1bmN0aW9uKHAsIHgsIHkpXG57XG5cdHAuY21kcy5wdXNoKFwiTVwiKTsgIHAuY3Jkcy5wdXNoKHgseSk7XG59O1xuVHlwci5VLlAubGluZVRvID0gZnVuY3Rpb24ocCwgeCwgeSlcbntcblx0cC5jbWRzLnB1c2goXCJMXCIpOyAgcC5jcmRzLnB1c2goeCx5KTtcbn07XG5UeXByLlUuUC5jdXJ2ZVRvID0gZnVuY3Rpb24ocCwgYSxiLGMsZCxlLGYpXG57XG5cdHAuY21kcy5wdXNoKFwiQ1wiKTsgIHAuY3Jkcy5wdXNoKGEsYixjLGQsZSxmKTtcbn07XG5UeXByLlUuUC5xY3VydmVUbyA9IGZ1bmN0aW9uKHAsIGEsYixjLGQpXG57XG5cdHAuY21kcy5wdXNoKFwiUVwiKTsgIHAuY3Jkcy5wdXNoKGEsYixjLGQpO1xufTtcblR5cHIuVS5QLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKHApIHsgIHAuY21kcy5wdXNoKFwiWlwiKTsgIH07XG5cblxuXG5cblR5cHIuVS5fZHJhd0NGRiA9IGZ1bmN0aW9uKGNtZHMsIHN0YXRlLCBmb250LCBwZGN0LCBwKVxue1xuXHR2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0dmFyIG5TdGVtcyA9IHN0YXRlLm5TdGVtcywgaGF2ZVdpZHRoPXN0YXRlLmhhdmVXaWR0aCwgd2lkdGg9c3RhdGUud2lkdGgsIG9wZW49c3RhdGUub3Blbjtcblx0dmFyIGk9MDtcblx0dmFyIHg9c3RhdGUueCwgeT1zdGF0ZS55LCBjMXg9MCwgYzF5PTAsIGMyeD0wLCBjMnk9MCwgYzN4PTAsIGMzeT0wLCBjNHg9MCwgYzR5PTAsIGpweD0wLCBqcHk9MDtcblx0XG5cdHZhciBvID0ge3ZhbDowLHNpemU6MH07XG5cdC8vY29uc29sZS5sb2coY21kcyk7XG5cdHdoaWxlKGk8Y21kcy5sZW5ndGgpXG5cdHtcblx0XHRUeXByLkNGRi5nZXRDaGFyU3RyaW5nKGNtZHMsIGksIG8pO1xuXHRcdHZhciB2ID0gby52YWw7XG5cdFx0aSArPSBvLnNpemU7XG5cdFx0XHRcblx0XHRpZih2PT1cIm8xXCIgfHwgdj09XCJvMThcIikgIC8vICBoc3RlbSB8fCBoc3RlbWhtXG5cdFx0e1xuXHRcdFx0dmFyIGhhc1dpZHRoQXJnO1xuXG5cdFx0XHQvLyBUaGUgbnVtYmVyIG9mIHN0ZW0gb3BlcmF0b3JzIG9uIHRoZSBzdGFjayBpcyBhbHdheXMgZXZlbi5cblx0XHRcdC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG5cdFx0XHRoYXNXaWR0aEFyZyA9IHN0YWNrLmxlbmd0aCAlIDIgIT09IDA7XG5cdFx0XHRpZiAoaGFzV2lkdGhBcmcgJiYgIWhhdmVXaWR0aCkge1xuXHRcdFx0XHR3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBwZGN0Lm5vbWluYWxXaWR0aFg7XG5cdFx0XHR9XG5cblx0XHRcdG5TdGVtcyArPSBzdGFjay5sZW5ndGggPj4gMTtcblx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XG5cdFx0XHRoYXZlV2lkdGggPSB0cnVlO1xuXHRcdH1cblx0XHRlbHNlIGlmKHY9PVwibzNcIiB8fCB2PT1cIm8yM1wiKSAgLy8gdnN0ZW0gfHwgdnN0ZW1obVxuXHRcdHtcblx0XHRcdHZhciBoYXNXaWR0aEFyZztcblxuXHRcdFx0Ly8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG5cdFx0XHQvLyBJZiB0aGUgdmFsdWUgaXMgdW5ldmVuLCB0aGF0IG1lYW5zIGEgd2lkdGggaXMgc3BlY2lmaWVkLlxuXHRcdFx0aGFzV2lkdGhBcmcgPSBzdGFjay5sZW5ndGggJSAyICE9PSAwO1xuXHRcdFx0aWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcblx0XHRcdFx0d2lkdGggPSBzdGFjay5zaGlmdCgpICsgcGRjdC5ub21pbmFsV2lkdGhYO1xuXHRcdFx0fVxuXG5cdFx0XHRuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG5cdFx0XHRzdGFjay5sZW5ndGggPSAwO1xuXHRcdFx0aGF2ZVdpZHRoID0gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxzZSBpZih2PT1cIm80XCIpXG5cdFx0e1xuXHRcdFx0aWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgcGRjdC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXHRcdFx0aWYob3BlbikgeyBUeXByLlUuUC5jbG9zZVBhdGgocCk7IH1cblxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdFR5cHIuVS5QLm1vdmVUbyhwLHgseSk7ICAgb3Blbj10cnVlO1xuXHRcdH1cblx0XHRlbHNlIGlmKHY9PVwibzVcIilcblx0XHR7XG5cdFx0XHR3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgVHlwci5VLlAubGluZVRvKHAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cdFx0fVxuXHRcdGVsc2UgaWYodj09XCJvNlwiIHx8IHY9PVwibzdcIikgIC8vIGhsaW5ldG8gfHwgdmxpbmV0b1xuXHRcdHtcblx0XHRcdHZhciBjb3VudCA9IHN0YWNrLmxlbmd0aDtcblx0XHRcdHZhciBpc1ggPSAodiA9PSBcIm82XCIpO1xuXHRcdFx0XG5cdFx0XHRmb3IodmFyIGo9MDsgajxjb3VudDsgaisrKSB7XG5cdFx0XHRcdHZhciBzdmFsID0gc3RhY2suc2hpZnQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmKGlzWCkgeyB4ICs9IHN2YWw7IH0gIGVsc2UgIHsgeSArPSBzdmFsOyB9XG5cdFx0XHRcdGlzWCA9ICFpc1g7XG5cdFx0XHRcdFR5cHIuVS5QLmxpbmVUbyhwLCB4LCB5KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZih2PT1cIm84XCIgfHwgdj09XCJvMjRcIilcdC8vIHJyY3VydmV0byB8fCByY3VydmVsaW5lXG5cdFx0e1xuXHRcdFx0dmFyIGNvdW50ID0gc3RhY2subGVuZ3RoO1xuXHRcdFx0dmFyIGluZGV4ID0gMDtcblx0XHRcdHdoaWxlKGluZGV4KzYgPD0gY291bnQpIHtcblx0XHRcdFx0YzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG5cdFx0XHRcdGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHRjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHRjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHR4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcblx0XHRcdFx0eSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG5cdFx0XHRcdFR5cHIuVS5QLmN1cnZlVG8ocCwgYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcblx0XHRcdFx0aW5kZXgrPTY7XG5cdFx0XHR9XG5cdFx0XHRpZih2PT1cIm8yNFwiKVxuXHRcdFx0e1xuXHRcdFx0XHR4ICs9IHN0YWNrLnNoaWZ0KCk7XG5cdFx0XHRcdHkgKz0gc3RhY2suc2hpZnQoKTtcblx0XHRcdFx0VHlwci5VLlAubGluZVRvKHAsIHgsIHkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmKHY9PVwibzExXCIpICB7IGJyZWFrOyB9XG5cdFx0ZWxzZSBpZih2PT1cIm8xMjM0XCIgfHwgdj09XCJvMTIzNVwiIHx8IHY9PVwibzEyMzZcIiB8fCB2PT1cIm8xMjM3XCIpLy9pZigoditcIlwiKS5zbGljZSgwLDMpPT1cIm8xMlwiKVxuXHRcdHtcblx0XHRcdGlmKHY9PVwibzEyMzRcIilcblx0XHRcdHtcblx0XHRcdFx0YzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgYzF5ID0geTsgICAgICAgICAgICAgICAgICAgICAgLy8gZHkxXG5cdFx0XHRcdGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuXHRcdFx0XHRjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcblx0XHRcdFx0anB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG5cdFx0XHRcdGpweSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5M1xuXHRcdFx0XHRjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcblx0XHRcdFx0YzN5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHk0XG5cdFx0XHRcdGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuXHRcdFx0XHRjNHkgPSB5OyAgICAgICAgICAgICAgICAgICAgICAvLyBkeTVcblx0XHRcdFx0eCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHg2XG5cdFx0XHRcdFR5cHIuVS5QLmN1cnZlVG8ocCwgYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG5cdFx0XHRcdFR5cHIuVS5QLmN1cnZlVG8ocCwgYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRpZih2PT1cIm8xMjM1XCIpXG5cdFx0XHR7XG5cdFx0XHRcdGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuXHRcdFx0XHRjMXkgPSB5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTFcblx0XHRcdFx0YzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG5cdFx0XHRcdGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuXHRcdFx0XHRqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcblx0XHRcdFx0anB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkzXG5cdFx0XHRcdGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuXHRcdFx0XHRjM3kgPSBqcHkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTRcblx0XHRcdFx0YzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG5cdFx0XHRcdGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuXHRcdFx0XHR4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgICAgICAvLyBkeDZcblx0XHRcdFx0eSA9IGM0eSArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHk2XG5cdFx0XHRcdHN0YWNrLnNoaWZ0KCk7ICAgICAgICAgICAgICAgIC8vIGZsZXggZGVwdGhcblx0XHRcdFx0VHlwci5VLlAuY3VydmVUbyhwLCBjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcblx0XHRcdFx0VHlwci5VLlAuY3VydmVUbyhwLCBjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuXHRcdFx0fVxuXHRcdFx0aWYodj09XCJvMTIzNlwiKVxuXHRcdFx0e1xuXHRcdFx0XHRjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcblx0XHRcdFx0YzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG5cdFx0XHRcdGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuXHRcdFx0XHRjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcblx0XHRcdFx0anB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG5cdFx0XHRcdGpweSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5M1xuXHRcdFx0XHRjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcblx0XHRcdFx0YzN5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHk0XG5cdFx0XHRcdGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuXHRcdFx0XHRjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcblx0XHRcdFx0eCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHg2XG5cdFx0XHRcdFR5cHIuVS5QLmN1cnZlVG8ocCwgYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG5cdFx0XHRcdFR5cHIuVS5QLmN1cnZlVG8ocCwgYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcblx0XHRcdH1cblx0XHRcdGlmKHY9PVwibzEyMzdcIilcblx0XHRcdHtcblx0XHRcdFx0YzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG5cdFx0XHRcdGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuXHRcdFx0XHRjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcblx0XHRcdFx0YzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG5cdFx0XHRcdGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuXHRcdFx0XHRqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTNcblx0XHRcdFx0YzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG5cdFx0XHRcdGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NFxuXHRcdFx0XHRjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcblx0XHRcdFx0YzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk1XG5cdFx0XHRcdGlmIChNYXRoLmFicyhjNHggLSB4KSA+IE1hdGguYWJzKGM0eSAtIHkpKSB7XG5cdFx0XHRcdCAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ICAgIHkgPSBjNHkgKyBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFR5cHIuVS5QLmN1cnZlVG8ocCwgYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG5cdFx0XHRcdFR5cHIuVS5QLmN1cnZlVG8ocCwgYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZih2PT1cIm8xNFwiKVxuXHRcdHtcblx0XHRcdGlmIChzdGFjay5sZW5ndGggPiAwICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblx0XHRcdGlmKHN0YWNrLmxlbmd0aD09NCkgLy8gc2VhYyA9IHN0YW5kYXJkIGVuY29kaW5nIGFjY2VudGVkIGNoYXJhY3RlclxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgYWR4ID0gc3RhY2suc2hpZnQoKTtcblx0XHRcdFx0dmFyIGFkeSA9IHN0YWNrLnNoaWZ0KCk7XG5cdFx0XHRcdHZhciBiY2hhciA9IHN0YWNrLnNoaWZ0KCk7XG5cdFx0XHRcdHZhciBhY2hhciA9IHN0YWNrLnNoaWZ0KCk7XG5cdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBiaW5kID0gVHlwci5DRkYuZ2x5cGhCeVNFKGZvbnQsIGJjaGFyKTtcblx0XHRcdFx0dmFyIGFpbmQgPSBUeXByLkNGRi5nbHlwaEJ5U0UoZm9udCwgYWNoYXIpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhiY2hhciwgYmluZCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coYWNoYXIsIGFpbmQpO1xuXHRcdFx0XHQvL3N0YXRlLng9eDsgc3RhdGUueT15OyBzdGF0ZS5uU3RlbXM9blN0ZW1zOyBzdGF0ZS5oYXZlV2lkdGg9aGF2ZVdpZHRoOyBzdGF0ZS53aWR0aD13aWR0aDsgIHN0YXRlLm9wZW49b3Blbjtcblx0XHRcdFx0XG5cdFx0XHRcdFR5cHIuVS5fZHJhd0NGRihmb250LkNoYXJTdHJpbmdzW2JpbmRdLCBzdGF0ZSxmb250LHBkY3QscCk7XG5cdFx0XHRcdHN0YXRlLnggPSBhZHg7IHN0YXRlLnkgPSBhZHk7XG5cdFx0XHRcdFR5cHIuVS5fZHJhd0NGRihmb250LkNoYXJTdHJpbmdzW2FpbmRdLCBzdGF0ZSxmb250LHBkY3QscCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvL3g9c3RhdGUueDsgeT1zdGF0ZS55OyBuU3RlbXM9c3RhdGUublN0ZW1zOyBoYXZlV2lkdGg9c3RhdGUuaGF2ZVdpZHRoOyB3aWR0aD1zdGF0ZS53aWR0aDsgIG9wZW49c3RhdGUub3Blbjtcblx0XHRcdH1cblx0XHRcdGlmKG9wZW4pIHsgIFR5cHIuVS5QLmNsb3NlUGF0aChwKTsgIG9wZW49ZmFsc2U7ICB9XG5cdFx0fVx0XHRcblx0XHRlbHNlIGlmKHY9PVwibzE5XCIgfHwgdj09XCJvMjBcIikgXG5cdFx0eyBcblx0XHRcdHZhciBoYXNXaWR0aEFyZztcblxuXHRcdFx0Ly8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG5cdFx0XHQvLyBJZiB0aGUgdmFsdWUgaXMgdW5ldmVuLCB0aGF0IG1lYW5zIGEgd2lkdGggaXMgc3BlY2lmaWVkLlxuXHRcdFx0aGFzV2lkdGhBcmcgPSBzdGFjay5sZW5ndGggJSAyICE9PSAwO1xuXHRcdFx0aWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcblx0XHRcdFx0d2lkdGggPSBzdGFjay5zaGlmdCgpICsgcGRjdC5ub21pbmFsV2lkdGhYO1xuXHRcdFx0fVxuXG5cdFx0XHRuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG5cdFx0XHRzdGFjay5sZW5ndGggPSAwO1xuXHRcdFx0aGF2ZVdpZHRoID0gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0aSArPSAoblN0ZW1zICsgNykgPj4gMztcblx0XHR9XG5cdFx0XG5cdFx0ZWxzZSBpZih2PT1cIm8yMVwiKSB7XG5cdFx0XHRpZiAoc3RhY2subGVuZ3RoID4gMiAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBwZGN0Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZihvcGVuKSB7IFR5cHIuVS5QLmNsb3NlUGF0aChwKTsgfVxuICAgICAgICAgICAgICAgICAgICBUeXByLlUuUC5tb3ZlVG8ocCx4LHkpOyAgIG9wZW49dHJ1ZTtcblx0XHR9XG5cdFx0ZWxzZSBpZih2PT1cIm8yMlwiKVxuXHRcdHtcblx0XHRcdCBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBwZGN0Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cdFx0XHRcdFx0XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYob3BlbikgeyBUeXByLlUuUC5jbG9zZVBhdGgocCk7IH1cblx0XHRcdFx0XHRUeXByLlUuUC5tb3ZlVG8ocCx4LHkpOyAgIG9wZW49dHJ1ZTsgICAgICAgICAgICAgICAgICAgIFxuXHRcdH1cblx0XHRlbHNlIGlmKHY9PVwibzI1XCIpXG5cdFx0e1xuXHRcdFx0d2hpbGUgKHN0YWNrLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFR5cHIuVS5QLmxpbmVUbyhwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBUeXByLlUuUC5jdXJ2ZVRvKHAsIGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYodj09XCJvMjZcIikgXG5cdFx0e1xuXHRcdFx0aWYgKHN0YWNrLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFR5cHIuVS5QLmN1cnZlVG8ocCwgYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cdFx0fVxuXHRcdGVsc2UgaWYodj09XCJvMjdcIilcblx0XHR7XG5cdFx0XHRpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgVHlwci5VLlAuY3VydmVUbyhwLCBjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cdFx0fVxuXHRcdGVsc2UgaWYodj09XCJvMTBcIiB8fCB2PT1cIm8yOVwiKVx0Ly8gY2FsbHN1YnIgfHwgY2FsbGdzdWJyXG5cdFx0e1xuXHRcdFx0dmFyIG9iaiA9ICh2PT1cIm8xMFwiID8gcGRjdCA6IGZvbnQpO1xuXHRcdFx0aWYoc3RhY2subGVuZ3RoPT0wKSB7IGNvbnNvbGUubG9nKFwiZXJyb3I6IGVtcHR5IHN0YWNrXCIpOyAgfVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhciBpbmQgPSBzdGFjay5wb3AoKTtcblx0XHRcdFx0dmFyIHN1YnIgPSBvYmouU3VicnNbIGluZCArIG9iai5CaWFzIF07XG5cdFx0XHRcdHN0YXRlLng9eDsgc3RhdGUueT15OyBzdGF0ZS5uU3RlbXM9blN0ZW1zOyBzdGF0ZS5oYXZlV2lkdGg9aGF2ZVdpZHRoOyBzdGF0ZS53aWR0aD13aWR0aDsgIHN0YXRlLm9wZW49b3Blbjtcblx0XHRcdFx0VHlwci5VLl9kcmF3Q0ZGKHN1YnIsIHN0YXRlLGZvbnQscGRjdCxwKTtcblx0XHRcdFx0eD1zdGF0ZS54OyB5PXN0YXRlLnk7IG5TdGVtcz1zdGF0ZS5uU3RlbXM7IGhhdmVXaWR0aD1zdGF0ZS5oYXZlV2lkdGg7IHdpZHRoPXN0YXRlLndpZHRoOyAgb3Blbj1zdGF0ZS5vcGVuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmKHY9PVwibzMwXCIgfHwgdj09XCJvMzFcIikgICAvLyB2aGN1cnZldG8gfHwgaHZjdXJ2ZXRvXG5cdFx0e1xuXHRcdFx0dmFyIGNvdW50LCBjb3VudDEgPSBzdGFjay5sZW5ndGg7XG5cdFx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdFx0dmFyIGFsdGVybmF0ZSA9IHYgPT0gXCJvMzFcIjtcblx0XHRcdFxuXHRcdFx0Y291bnQgID0gY291bnQxICYgfjI7XG5cdFx0XHRpbmRleCArPSBjb3VudDEgLSBjb3VudDtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKCBpbmRleCA8IGNvdW50ICkgXG5cdFx0XHR7XG5cdFx0XHRcdGlmKGFsdGVybmF0ZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHRcdGMxeSA9IHk7XG5cdFx0XHRcdFx0YzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcblx0XHRcdFx0XHRjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHRcdHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmKGNvdW50LWluZGV4ID09IDUpIHsgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgaW5kZXgrKzsgIH1cblx0XHRcdFx0XHRlbHNlIHsgeCA9IGMyeDsgfVxuXHRcdFx0XHRcdGFsdGVybmF0ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGMxeCA9IHg7XG5cdFx0XHRcdFx0YzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG5cdFx0XHRcdFx0YzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcblx0XHRcdFx0XHRjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHRcdHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmKGNvdW50LWluZGV4ID09IDUpIHsgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAgaW5kZXgrKzsgIH1cblx0XHRcdFx0XHRlbHNlIHsgeSA9IGMyeTsgfVxuXHRcdFx0XHRcdGFsdGVybmF0ZSA9IHRydWU7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgICAgICBUeXByLlUuUC5jdXJ2ZVRvKHAsIGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG5cdFx0XHRcdGluZGV4ICs9IDQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGVsc2UgaWYoKHYrXCJcIikuY2hhckF0KDApPT1cIm9cIikgeyAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBvcGVyYXRpb246IFwiK3YsIGNtZHMpOyB0aHJvdyB2OyAgfVxuXHRcdGVsc2UgeyBzdGFjay5wdXNoKHYpOyB9XG5cdH1cblx0Ly9jb25zb2xlLmxvZyhjbWRzKTtcblx0c3RhdGUueD14OyBzdGF0ZS55PXk7IHN0YXRlLm5TdGVtcz1uU3RlbXM7IHN0YXRlLmhhdmVXaWR0aD1oYXZlV2lkdGg7IHN0YXRlLndpZHRoPXdpZHRoOyBzdGF0ZS5vcGVuPW9wZW47XG59O1xuXG4vLyBFbmQgVHlwci5VLmpzXG5cbnJldHVybiBUeXByXG5cbn1cblxuLy8gQ3VzdG9tIGJ1bmRsZSBvZiB3b2ZmMm90ZiAoaHR0cHM6Ly9naXRodWIuY29tL2FydHktbmFtZS93b2ZmMm90Zikgd2l0aCB0aW55LWluZmxhdGUgXG4vLyAoaHR0cHM6Ly9naXRodWIuY29tL2ZvbGlvanMvdGlueS1pbmZsYXRlKSBmb3IgdXNlIGluIHRyb2lrYS0zZC10ZXh0LiBcbi8vIE9yaWdpbmFsIGxpY2Vuc2VzIGFwcGx5OiBcbi8vIC0gdGlueS1pbmZsYXRlOiBodHRwczovL2dpdGh1Yi5jb20vZm9saW9qcy90aW55LWluZmxhdGUvYmxvYi9tYXN0ZXIvTElDRU5TRSAoTUlUKVxuLy8gLSB3b2ZmMm90Zi5qczogaHR0cHM6Ly9naXRodWIuY29tL2FydHktbmFtZS93b2ZmMm90Zi9ibG9iL21hc3Rlci93b2ZmMm90Zi5qcyAoQXBhY2hlMilcblxuZnVuY3Rpb24gd29mZjJvdGZGYWN0b3J5KCkge1xuXG4vLyBCZWdpbiB0aW55SW5mbGF0ZVxudmFyIHRpbnlJbmZsYXRlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgbW9kdWxlID0ge307XG4gIHZhciBUSU5GX09LID0gMDtcbnZhciBUSU5GX0RBVEFfRVJST1IgPSAtMztcblxuZnVuY3Rpb24gVHJlZSgpIHtcbiAgdGhpcy50YWJsZSA9IG5ldyBVaW50MTZBcnJheSgxNik7ICAgLyogdGFibGUgb2YgY29kZSBsZW5ndGggY291bnRzICovXG4gIHRoaXMudHJhbnMgPSBuZXcgVWludDE2QXJyYXkoMjg4KTsgIC8qIGNvZGUgLT4gc3ltYm9sIHRyYW5zbGF0aW9uIHRhYmxlICovXG59XG5cbmZ1bmN0aW9uIERhdGEoc291cmNlLCBkZXN0KSB7XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLnNvdXJjZUluZGV4ID0gMDtcbiAgdGhpcy50YWcgPSAwO1xuICB0aGlzLmJpdGNvdW50ID0gMDtcbiAgXG4gIHRoaXMuZGVzdCA9IGRlc3Q7XG4gIHRoaXMuZGVzdExlbiA9IDA7XG4gIFxuICB0aGlzLmx0cmVlID0gbmV3IFRyZWUoKTsgIC8qIGR5bmFtaWMgbGVuZ3RoL3N5bWJvbCB0cmVlICovXG4gIHRoaXMuZHRyZWUgPSBuZXcgVHJlZSgpOyAgLyogZHluYW1pYyBkaXN0YW5jZSB0cmVlICovXG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSB1bmluaXRpYWxpemVkIGdsb2JhbCBkYXRhIChzdGF0aWMgc3RydWN0dXJlcykgLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbnZhciBzbHRyZWUgPSBuZXcgVHJlZSgpO1xudmFyIHNkdHJlZSA9IG5ldyBUcmVlKCk7XG5cbi8qIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzIGZvciBsZW5ndGggY29kZXMgKi9cbnZhciBsZW5ndGhfYml0cyA9IG5ldyBVaW50OEFycmF5KDMwKTtcbnZhciBsZW5ndGhfYmFzZSA9IG5ldyBVaW50MTZBcnJheSgzMCk7XG5cbi8qIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIGRpc3RfYml0cyA9IG5ldyBVaW50OEFycmF5KDMwKTtcbnZhciBkaXN0X2Jhc2UgPSBuZXcgVWludDE2QXJyYXkoMzApO1xuXG4vKiBzcGVjaWFsIG9yZGVyaW5nIG9mIGNvZGUgbGVuZ3RoIGNvZGVzICovXG52YXIgY2xjaWR4ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LFxuICAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMixcbiAgMTQsIDEsIDE1XG5dKTtcblxuLyogdXNlZCBieSB0aW5mX2RlY29kZV90cmVlcywgYXZvaWRzIGFsbG9jYXRpb25zIGV2ZXJ5IGNhbGwgKi9cbnZhciBjb2RlX3RyZWUgPSBuZXcgVHJlZSgpO1xudmFyIGxlbmd0aHMgPSBuZXcgVWludDhBcnJheSgyODggKyAzMik7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIC0tIHV0aWxpdHkgZnVuY3Rpb25zIC0tICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qIGJ1aWxkIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzICovXG5mdW5jdGlvbiB0aW5mX2J1aWxkX2JpdHNfYmFzZShiaXRzLCBiYXNlLCBkZWx0YSwgZmlyc3QpIHtcbiAgdmFyIGksIHN1bTtcblxuICAvKiBidWlsZCBiaXRzIHRhYmxlICovXG4gIGZvciAoaSA9IDA7IGkgPCBkZWx0YTsgKytpKSB7IGJpdHNbaV0gPSAwOyB9XG4gIGZvciAoaSA9IDA7IGkgPCAzMCAtIGRlbHRhOyArK2kpIHsgYml0c1tpICsgZGVsdGFdID0gaSAvIGRlbHRhIHwgMDsgfVxuXG4gIC8qIGJ1aWxkIGJhc2UgdGFibGUgKi9cbiAgZm9yIChzdW0gPSBmaXJzdCwgaSA9IDA7IGkgPCAzMDsgKytpKSB7XG4gICAgYmFzZVtpXSA9IHN1bTtcbiAgICBzdW0gKz0gMSA8PCBiaXRzW2ldO1xuICB9XG59XG5cbi8qIGJ1aWxkIHRoZSBmaXhlZCBodWZmbWFuIHRyZWVzICovXG5mdW5jdGlvbiB0aW5mX2J1aWxkX2ZpeGVkX3RyZWVzKGx0LCBkdCkge1xuICB2YXIgaTtcblxuICAvKiBidWlsZCBmaXhlZCBsZW5ndGggdHJlZSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7IGx0LnRhYmxlW2ldID0gMDsgfVxuXG4gIGx0LnRhYmxlWzddID0gMjQ7XG4gIGx0LnRhYmxlWzhdID0gMTUyO1xuICBsdC50YWJsZVs5XSA9IDExMjtcblxuICBmb3IgKGkgPSAwOyBpIDwgMjQ7ICsraSkgeyBsdC50cmFuc1tpXSA9IDI1NiArIGk7IH1cbiAgZm9yIChpID0gMDsgaSA8IDE0NDsgKytpKSB7IGx0LnRyYW5zWzI0ICsgaV0gPSBpOyB9XG4gIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHsgbHQudHJhbnNbMjQgKyAxNDQgKyBpXSA9IDI4MCArIGk7IH1cbiAgZm9yIChpID0gMDsgaSA8IDExMjsgKytpKSB7IGx0LnRyYW5zWzI0ICsgMTQ0ICsgOCArIGldID0gMTQ0ICsgaTsgfVxuXG4gIC8qIGJ1aWxkIGZpeGVkIGRpc3RhbmNlIHRyZWUgKi9cbiAgZm9yIChpID0gMDsgaSA8IDU7ICsraSkgeyBkdC50YWJsZVtpXSA9IDA7IH1cblxuICBkdC50YWJsZVs1XSA9IDMyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgKytpKSB7IGR0LnRyYW5zW2ldID0gaTsgfVxufVxuXG4vKiBnaXZlbiBhbiBhcnJheSBvZiBjb2RlIGxlbmd0aHMsIGJ1aWxkIGEgdHJlZSAqL1xudmFyIG9mZnMgPSBuZXcgVWludDE2QXJyYXkoMTYpO1xuXG5mdW5jdGlvbiB0aW5mX2J1aWxkX3RyZWUodCwgbGVuZ3Rocywgb2ZmLCBudW0pIHtcbiAgdmFyIGksIHN1bTtcblxuICAvKiBjbGVhciBjb2RlIGxlbmd0aCBjb3VudCB0YWJsZSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkgeyB0LnRhYmxlW2ldID0gMDsgfVxuXG4gIC8qIHNjYW4gc3ltYm9sIGxlbmd0aHMsIGFuZCBzdW0gY29kZSBsZW5ndGggY291bnRzICovXG4gIGZvciAoaSA9IDA7IGkgPCBudW07ICsraSkgeyB0LnRhYmxlW2xlbmd0aHNbb2ZmICsgaV1dKys7IH1cblxuICB0LnRhYmxlWzBdID0gMDtcblxuICAvKiBjb21wdXRlIG9mZnNldCB0YWJsZSBmb3IgZGlzdHJpYnV0aW9uIHNvcnQgKi9cbiAgZm9yIChzdW0gPSAwLCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBvZmZzW2ldID0gc3VtO1xuICAgIHN1bSArPSB0LnRhYmxlW2ldO1xuICB9XG5cbiAgLyogY3JlYXRlIGNvZGUtPnN5bWJvbCB0cmFuc2xhdGlvbiB0YWJsZSAoc3ltYm9scyBzb3J0ZWQgYnkgY29kZSkgKi9cbiAgZm9yIChpID0gMDsgaSA8IG51bTsgKytpKSB7XG4gICAgaWYgKGxlbmd0aHNbb2ZmICsgaV0pIHsgdC50cmFuc1tvZmZzW2xlbmd0aHNbb2ZmICsgaV1dKytdID0gaTsgfVxuICB9XG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gZGVjb2RlIGZ1bmN0aW9ucyAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qIGdldCBvbmUgYml0IGZyb20gc291cmNlIHN0cmVhbSAqL1xuZnVuY3Rpb24gdGluZl9nZXRiaXQoZCkge1xuICAvKiBjaGVjayBpZiB0YWcgaXMgZW1wdHkgKi9cbiAgaWYgKCFkLmJpdGNvdW50LS0pIHtcbiAgICAvKiBsb2FkIG5leHQgdGFnICovXG4gICAgZC50YWcgPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdO1xuICAgIGQuYml0Y291bnQgPSA3O1xuICB9XG5cbiAgLyogc2hpZnQgYml0IG91dCBvZiB0YWcgKi9cbiAgdmFyIGJpdCA9IGQudGFnICYgMTtcbiAgZC50YWcgPj4+PSAxO1xuXG4gIHJldHVybiBiaXQ7XG59XG5cbi8qIHJlYWQgYSBudW0gYml0IHZhbHVlIGZyb20gYSBzdHJlYW0gYW5kIGFkZCBiYXNlICovXG5mdW5jdGlvbiB0aW5mX3JlYWRfYml0cyhkLCBudW0sIGJhc2UpIHtcbiAgaWYgKCFudW0pXG4gICAgeyByZXR1cm4gYmFzZTsgfVxuXG4gIHdoaWxlIChkLmJpdGNvdW50IDwgMjQpIHtcbiAgICBkLnRhZyB8PSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdIDw8IGQuYml0Y291bnQ7XG4gICAgZC5iaXRjb3VudCArPSA4O1xuICB9XG5cbiAgdmFyIHZhbCA9IGQudGFnICYgKDB4ZmZmZiA+Pj4gKDE2IC0gbnVtKSk7XG4gIGQudGFnID4+Pj0gbnVtO1xuICBkLmJpdGNvdW50IC09IG51bTtcbiAgcmV0dXJuIHZhbCArIGJhc2U7XG59XG5cbi8qIGdpdmVuIGEgZGF0YSBzdHJlYW0gYW5kIGEgdHJlZSwgZGVjb2RlIGEgc3ltYm9sICovXG5mdW5jdGlvbiB0aW5mX2RlY29kZV9zeW1ib2woZCwgdCkge1xuICB3aGlsZSAoZC5iaXRjb3VudCA8IDI0KSB7XG4gICAgZC50YWcgfD0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXSA8PCBkLmJpdGNvdW50O1xuICAgIGQuYml0Y291bnQgKz0gODtcbiAgfVxuICBcbiAgdmFyIHN1bSA9IDAsIGN1ciA9IDAsIGxlbiA9IDA7XG4gIHZhciB0YWcgPSBkLnRhZztcblxuICAvKiBnZXQgbW9yZSBiaXRzIHdoaWxlIGNvZGUgdmFsdWUgaXMgYWJvdmUgc3VtICovXG4gIGRvIHtcbiAgICBjdXIgPSAyICogY3VyICsgKHRhZyAmIDEpO1xuICAgIHRhZyA+Pj49IDE7XG4gICAgKytsZW47XG5cbiAgICBzdW0gKz0gdC50YWJsZVtsZW5dO1xuICAgIGN1ciAtPSB0LnRhYmxlW2xlbl07XG4gIH0gd2hpbGUgKGN1ciA+PSAwKTtcbiAgXG4gIGQudGFnID0gdGFnO1xuICBkLmJpdGNvdW50IC09IGxlbjtcblxuICByZXR1cm4gdC50cmFuc1tzdW0gKyBjdXJdO1xufVxuXG4vKiBnaXZlbiBhIGRhdGEgc3RyZWFtLCBkZWNvZGUgZHluYW1pYyB0cmVlcyBmcm9tIGl0ICovXG5mdW5jdGlvbiB0aW5mX2RlY29kZV90cmVlcyhkLCBsdCwgZHQpIHtcbiAgdmFyIGhsaXQsIGhkaXN0LCBoY2xlbjtcbiAgdmFyIGksIG51bSwgbGVuZ3RoO1xuXG4gIC8qIGdldCA1IGJpdHMgSExJVCAoMjU3LTI4NikgKi9cbiAgaGxpdCA9IHRpbmZfcmVhZF9iaXRzKGQsIDUsIDI1Nyk7XG5cbiAgLyogZ2V0IDUgYml0cyBIRElTVCAoMS0zMikgKi9cbiAgaGRpc3QgPSB0aW5mX3JlYWRfYml0cyhkLCA1LCAxKTtcblxuICAvKiBnZXQgNCBiaXRzIEhDTEVOICg0LTE5KSAqL1xuICBoY2xlbiA9IHRpbmZfcmVhZF9iaXRzKGQsIDQsIDQpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxOTsgKytpKSB7IGxlbmd0aHNbaV0gPSAwOyB9XG5cbiAgLyogcmVhZCBjb2RlIGxlbmd0aHMgZm9yIGNvZGUgbGVuZ3RoIGFscGhhYmV0ICovXG4gIGZvciAoaSA9IDA7IGkgPCBoY2xlbjsgKytpKSB7XG4gICAgLyogZ2V0IDMgYml0cyBjb2RlIGxlbmd0aCAoMC03KSAqL1xuICAgIHZhciBjbGVuID0gdGluZl9yZWFkX2JpdHMoZCwgMywgMCk7XG4gICAgbGVuZ3Roc1tjbGNpZHhbaV1dID0gY2xlbjtcbiAgfVxuXG4gIC8qIGJ1aWxkIGNvZGUgbGVuZ3RoIHRyZWUgKi9cbiAgdGluZl9idWlsZF90cmVlKGNvZGVfdHJlZSwgbGVuZ3RocywgMCwgMTkpO1xuXG4gIC8qIGRlY29kZSBjb2RlIGxlbmd0aHMgZm9yIHRoZSBkeW5hbWljIHRyZWVzICovXG4gIGZvciAobnVtID0gMDsgbnVtIDwgaGxpdCArIGhkaXN0Oykge1xuICAgIHZhciBzeW0gPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgY29kZV90cmVlKTtcblxuICAgIHN3aXRjaCAoc3ltKSB7XG4gICAgICBjYXNlIDE2OlxuICAgICAgICAvKiBjb3B5IHByZXZpb3VzIGNvZGUgbGVuZ3RoIDMtNiB0aW1lcyAocmVhZCAyIGJpdHMpICovXG4gICAgICAgIHZhciBwcmV2ID0gbGVuZ3Roc1tudW0gLSAxXTtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCAyLCAzKTsgbGVuZ3RoOyAtLWxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTc6XG4gICAgICAgIC8qIHJlcGVhdCBjb2RlIGxlbmd0aCAwIGZvciAzLTEwIHRpbWVzIChyZWFkIDMgYml0cykgKi9cbiAgICAgICAgZm9yIChsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCAzLCAzKTsgbGVuZ3RoOyAtLWxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTg6XG4gICAgICAgIC8qIHJlcGVhdCBjb2RlIGxlbmd0aCAwIGZvciAxMS0xMzggdGltZXMgKHJlYWQgNyBiaXRzKSAqL1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDcsIDExKTsgbGVuZ3RoOyAtLWxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8qIHZhbHVlcyAwLTE1IHJlcHJlc2VudCB0aGUgYWN0dWFsIGNvZGUgbGVuZ3RocyAqL1xuICAgICAgICBsZW5ndGhzW251bSsrXSA9IHN5bTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyogYnVpbGQgZHluYW1pYyB0cmVlcyAqL1xuICB0aW5mX2J1aWxkX3RyZWUobHQsIGxlbmd0aHMsIDAsIGhsaXQpO1xuICB0aW5mX2J1aWxkX3RyZWUoZHQsIGxlbmd0aHMsIGhsaXQsIGhkaXN0KTtcbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gYmxvY2sgaW5mbGF0ZSBmdW5jdGlvbnMgLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogZ2l2ZW4gYSBzdHJlYW0gYW5kIHR3byB0cmVlcywgaW5mbGF0ZSBhIGJsb2NrIG9mIGRhdGEgKi9cbmZ1bmN0aW9uIHRpbmZfaW5mbGF0ZV9ibG9ja19kYXRhKGQsIGx0LCBkdCkge1xuICB3aGlsZSAoMSkge1xuICAgIHZhciBzeW0gPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgbHQpO1xuXG4gICAgLyogY2hlY2sgZm9yIGVuZCBvZiBibG9jayAqL1xuICAgIGlmIChzeW0gPT09IDI1Nikge1xuICAgICAgcmV0dXJuIFRJTkZfT0s7XG4gICAgfVxuXG4gICAgaWYgKHN5bSA8IDI1Nikge1xuICAgICAgZC5kZXN0W2QuZGVzdExlbisrXSA9IHN5bTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbmd0aCwgZGlzdCwgb2ZmcztcbiAgICAgIHZhciBpO1xuXG4gICAgICBzeW0gLT0gMjU3O1xuXG4gICAgICAvKiBwb3NzaWJseSBnZXQgbW9yZSBiaXRzIGZyb20gbGVuZ3RoIGNvZGUgKi9cbiAgICAgIGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIGxlbmd0aF9iaXRzW3N5bV0sIGxlbmd0aF9iYXNlW3N5bV0pO1xuXG4gICAgICBkaXN0ID0gdGluZl9kZWNvZGVfc3ltYm9sKGQsIGR0KTtcblxuICAgICAgLyogcG9zc2libHkgZ2V0IG1vcmUgYml0cyBmcm9tIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgIG9mZnMgPSBkLmRlc3RMZW4gLSB0aW5mX3JlYWRfYml0cyhkLCBkaXN0X2JpdHNbZGlzdF0sIGRpc3RfYmFzZVtkaXN0XSk7XG5cbiAgICAgIC8qIGNvcHkgbWF0Y2ggKi9cbiAgICAgIGZvciAoaSA9IG9mZnM7IGkgPCBvZmZzICsgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZC5kZXN0W2QuZGVzdExlbisrXSA9IGQuZGVzdFtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogaW5mbGF0ZSBhbiB1bmNvbXByZXNzZWQgYmxvY2sgb2YgZGF0YSAqL1xuZnVuY3Rpb24gdGluZl9pbmZsYXRlX3VuY29tcHJlc3NlZF9ibG9jayhkKSB7XG4gIHZhciBsZW5ndGgsIGludmxlbmd0aDtcbiAgdmFyIGk7XG4gIFxuICAvKiB1bnJlYWQgZnJvbSBiaXRidWZmZXIgKi9cbiAgd2hpbGUgKGQuYml0Y291bnQgPiA4KSB7XG4gICAgZC5zb3VyY2VJbmRleC0tO1xuICAgIGQuYml0Y291bnQgLT0gODtcbiAgfVxuXG4gIC8qIGdldCBsZW5ndGggKi9cbiAgbGVuZ3RoID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCArIDFdO1xuICBsZW5ndGggPSAyNTYgKiBsZW5ndGggKyBkLnNvdXJjZVtkLnNvdXJjZUluZGV4XTtcblxuICAvKiBnZXQgb25lJ3MgY29tcGxlbWVudCBvZiBsZW5ndGggKi9cbiAgaW52bGVuZ3RoID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCArIDNdO1xuICBpbnZsZW5ndGggPSAyNTYgKiBpbnZsZW5ndGggKyBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgMl07XG5cbiAgLyogY2hlY2sgbGVuZ3RoICovXG4gIGlmIChsZW5ndGggIT09ICh+aW52bGVuZ3RoICYgMHgwMDAwZmZmZikpXG4gICAgeyByZXR1cm4gVElORl9EQVRBX0VSUk9SOyB9XG5cbiAgZC5zb3VyY2VJbmRleCArPSA0O1xuXG4gIC8qIGNvcHkgYmxvY2sgKi9cbiAgZm9yIChpID0gbGVuZ3RoOyBpOyAtLWkpXG4gICAgeyBkLmRlc3RbZC5kZXN0TGVuKytdID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXTsgfVxuXG4gIC8qIG1ha2Ugc3VyZSB3ZSBzdGFydCBuZXh0IGJsb2NrIG9uIGEgYnl0ZSBib3VuZGFyeSAqL1xuICBkLmJpdGNvdW50ID0gMDtcblxuICByZXR1cm4gVElORl9PSztcbn1cblxuLyogaW5mbGF0ZSBzdHJlYW0gZnJvbSBzb3VyY2UgdG8gZGVzdCAqL1xuZnVuY3Rpb24gdGluZl91bmNvbXByZXNzKHNvdXJjZSwgZGVzdCkge1xuICB2YXIgZCA9IG5ldyBEYXRhKHNvdXJjZSwgZGVzdCk7XG4gIHZhciBiZmluYWwsIGJ0eXBlLCByZXM7XG5cbiAgZG8ge1xuICAgIC8qIHJlYWQgZmluYWwgYmxvY2sgZmxhZyAqL1xuICAgIGJmaW5hbCA9IHRpbmZfZ2V0Yml0KGQpO1xuXG4gICAgLyogcmVhZCBibG9jayB0eXBlICgyIGJpdHMpICovXG4gICAgYnR5cGUgPSB0aW5mX3JlYWRfYml0cyhkLCAyLCAwKTtcblxuICAgIC8qIGRlY29tcHJlc3MgYmxvY2sgKi9cbiAgICBzd2l0Y2ggKGJ0eXBlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8qIGRlY29tcHJlc3MgdW5jb21wcmVzc2VkIGJsb2NrICovXG4gICAgICAgIHJlcyA9IHRpbmZfaW5mbGF0ZV91bmNvbXByZXNzZWRfYmxvY2soZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAvKiBkZWNvbXByZXNzIGJsb2NrIHdpdGggZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBzbHRyZWUsIHNkdHJlZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvKiBkZWNvbXByZXNzIGJsb2NrIHdpdGggZHluYW1pYyBodWZmbWFuIHRyZWVzICovXG4gICAgICAgIHRpbmZfZGVjb2RlX3RyZWVzKGQsIGQubHRyZWUsIGQuZHRyZWUpO1xuICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBkLmx0cmVlLCBkLmR0cmVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgPSBUSU5GX0RBVEFfRVJST1I7XG4gICAgfVxuXG4gICAgaWYgKHJlcyAhPT0gVElORl9PSylcbiAgICAgIHsgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGVycm9yJyk7IH1cblxuICB9IHdoaWxlICghYmZpbmFsKTtcblxuICBpZiAoZC5kZXN0TGVuIDwgZC5kZXN0Lmxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgZC5kZXN0LnNsaWNlID09PSAnZnVuY3Rpb24nKVxuICAgICAgeyByZXR1cm4gZC5kZXN0LnNsaWNlKDAsIGQuZGVzdExlbik7IH1cbiAgICBlbHNlXG4gICAgICB7IHJldHVybiBkLmRlc3Quc3ViYXJyYXkoMCwgZC5kZXN0TGVuKTsgfVxuICB9XG4gIFxuICByZXR1cm4gZC5kZXN0O1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSBpbml0aWFsaXphdGlvbiAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBidWlsZCBmaXhlZCBodWZmbWFuIHRyZWVzICovXG50aW5mX2J1aWxkX2ZpeGVkX3RyZWVzKHNsdHJlZSwgc2R0cmVlKTtcblxuLyogYnVpbGQgZXh0cmEgYml0cyBhbmQgYmFzZSB0YWJsZXMgKi9cbnRpbmZfYnVpbGRfYml0c19iYXNlKGxlbmd0aF9iaXRzLCBsZW5ndGhfYmFzZSwgNCwgMyk7XG50aW5mX2J1aWxkX2JpdHNfYmFzZShkaXN0X2JpdHMsIGRpc3RfYmFzZSwgMiwgMSk7XG5cbi8qIGZpeCBhIHNwZWNpYWwgY2FzZSAqL1xubGVuZ3RoX2JpdHNbMjhdID0gMDtcbmxlbmd0aF9iYXNlWzI4XSA9IDI1ODtcblxubW9kdWxlLmV4cG9ydHMgPSB0aW5mX3VuY29tcHJlc3M7XG5cbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzXG59KSgpO1xuLy8gRW5kIHRpbnlJbmZsYXRlXG5cbi8vIEJlZ2luIHdvZmYyb3RmLmpzXG4vKlxuIENvcHlyaWdodCAyMDEyLCBTdGVmZmVuIEhhbmlrZWwgKGh0dHBzOi8vZ2l0aHViLmNvbS9oYW5pa2VzbilcbiBNb2RpZmllZCBieSBBcnRlbXkgVHJlZ3ViZW5rbywgMjAxNCAoaHR0cHM6Ly9naXRodWIuY29tL2FydHktbmFtZS93b2ZmMm90ZilcbiBNb2RpZmllZCBieSBKYXNvbiBKb2huc3RvbiwgMjAxOSAocGFrbyAtLT4gdGlueS1pbmZsYXRlKVxuIFxuICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiBBIHRvb2wgdG8gY29udmVydCBhIFdPRkYgYmFjayB0byBhIFRURi9PVEYgZm9udCBmaWxlLCBpbiBwdXJlIEphdmFzY3JpcHRcbiovXG5cbmZ1bmN0aW9uIGNvbnZlcnRfc3RyZWFtcyhidWZmZXJJbiwgdGlueUluZmxhdGUpIHtcbiAgICB2YXIgZGF0YVZpZXdJbiA9IG5ldyBEYXRhVmlldyhidWZmZXJJbik7XG4gICAgdmFyIG9mZnNldEluID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlYWQyKCkge1xuICAgICAgICB2YXIgdWludDE2ID0gZGF0YVZpZXdJbi5nZXRVaW50MTYob2Zmc2V0SW4pO1xuICAgICAgICBvZmZzZXRJbiArPSAyO1xuICAgICAgICByZXR1cm4gdWludDE2O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWQ0KCkge1xuICAgICAgICB2YXIgdWludDMyID0gZGF0YVZpZXdJbi5nZXRVaW50MzIob2Zmc2V0SW4pO1xuICAgICAgICBvZmZzZXRJbiArPSA0O1xuICAgICAgICByZXR1cm4gdWludDMyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyaXRlMih1aW50MTYpIHtcbiAgICAgICAgZGF0YVZpZXdPdXQuc2V0VWludDE2KG9mZnNldE91dCwgdWludDE2KTtcbiAgICAgICAgb2Zmc2V0T3V0ICs9IDI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JpdGU0KHVpbnQzMikge1xuICAgICAgICBkYXRhVmlld091dC5zZXRVaW50MzIob2Zmc2V0T3V0LCB1aW50MzIpO1xuICAgICAgICBvZmZzZXRPdXQgKz0gNDtcbiAgICB9XG5cbiAgICB2YXIgV09GRkhlYWRlciA9IHtcbiAgICAgICAgc2lnbmF0dXJlOiByZWFkNCgpLFxuICAgICAgICBmbGF2b3I6IHJlYWQ0KCksXG4gICAgICAgIGxlbmd0aDogcmVhZDQoKSxcbiAgICAgICAgbnVtVGFibGVzOiByZWFkMigpLFxuICAgICAgICByZXNlcnZlZDogcmVhZDIoKSxcbiAgICAgICAgdG90YWxTZm50U2l6ZTogcmVhZDQoKSxcbiAgICAgICAgbWFqb3JWZXJzaW9uOiByZWFkMigpLFxuICAgICAgICBtaW5vclZlcnNpb246IHJlYWQyKCksXG4gICAgICAgIG1ldGFPZmZzZXQ6IHJlYWQ0KCksXG4gICAgICAgIG1ldGFMZW5ndGg6IHJlYWQ0KCksXG4gICAgICAgIG1ldGFPcmlnTGVuZ3RoOiByZWFkNCgpLFxuICAgICAgICBwcml2T2Zmc2V0OiByZWFkNCgpLFxuICAgICAgICBwcml2TGVuZ3RoOiByZWFkNCgpXG4gICAgfTtcblxuICAgIHZhciBlbnRyeVNlbGVjdG9yID0gMDtcbiAgICB3aGlsZSAoTWF0aC5wb3coMiwgZW50cnlTZWxlY3RvcikgPD0gV09GRkhlYWRlci5udW1UYWJsZXMpIHtcbiAgICAgICAgZW50cnlTZWxlY3RvcisrO1xuICAgIH1cbiAgICBlbnRyeVNlbGVjdG9yLS07XG5cbiAgICB2YXIgc2VhcmNoUmFuZ2UgPSBNYXRoLnBvdygyLCBlbnRyeVNlbGVjdG9yKSAqIDE2O1xuICAgIHZhciByYW5nZVNoaWZ0ID0gV09GRkhlYWRlci5udW1UYWJsZXMgKiAxNiAtIHNlYXJjaFJhbmdlO1xuXG4gICAgdmFyIG9mZnNldCA9IDQgKyAyICsgMiArIDIgKyAyO1xuICAgIHZhciBUYWJsZURpcmVjdG9yeUVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFdPRkZIZWFkZXIubnVtVGFibGVzOyBpKyspIHtcbiAgICAgICAgVGFibGVEaXJlY3RvcnlFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgdGFnOiByZWFkNCgpLFxuICAgICAgICAgICAgb2Zmc2V0OiByZWFkNCgpLFxuICAgICAgICAgICAgY29tcExlbmd0aDogcmVhZDQoKSxcbiAgICAgICAgICAgIG9yaWdMZW5ndGg6IHJlYWQ0KCksXG4gICAgICAgICAgICBvcmlnQ2hlY2tzdW06IHJlYWQ0KClcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCArPSA0ICogNDtcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlPdXQgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgNCArIDIgKyAyICsgMiArIDIgK1xuICAgICAgICBUYWJsZURpcmVjdG9yeUVudHJpZXMubGVuZ3RoICogKDQgKyA0ICsgNCArIDQpICtcbiAgICAgICAgVGFibGVEaXJlY3RvcnlFbnRyaWVzLnJlZHVjZShmdW5jdGlvbihhY2MsIGVudHJ5KSB7IHJldHVybiBhY2MgKyBlbnRyeS5vcmlnTGVuZ3RoICsgNDsgfSwgMClcbiAgICApO1xuICAgIHZhciBidWZmZXJPdXQgPSBhcnJheU91dC5idWZmZXI7XG4gICAgdmFyIGRhdGFWaWV3T3V0ID0gbmV3IERhdGFWaWV3KGJ1ZmZlck91dCk7XG4gICAgdmFyIG9mZnNldE91dCA9IDA7XG5cbiAgICB3cml0ZTQoV09GRkhlYWRlci5mbGF2b3IpO1xuICAgIHdyaXRlMihXT0ZGSGVhZGVyLm51bVRhYmxlcyk7XG4gICAgd3JpdGUyKHNlYXJjaFJhbmdlKTtcbiAgICB3cml0ZTIoZW50cnlTZWxlY3Rvcik7XG4gICAgd3JpdGUyKHJhbmdlU2hpZnQpO1xuXG4gICAgVGFibGVEaXJlY3RvcnlFbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oVGFibGVEaXJlY3RvcnlFbnRyeSkge1xuICAgICAgICB3cml0ZTQoVGFibGVEaXJlY3RvcnlFbnRyeS50YWcpO1xuICAgICAgICB3cml0ZTQoVGFibGVEaXJlY3RvcnlFbnRyeS5vcmlnQ2hlY2tzdW0pO1xuICAgICAgICB3cml0ZTQob2Zmc2V0KTtcbiAgICAgICAgd3JpdGU0KFRhYmxlRGlyZWN0b3J5RW50cnkub3JpZ0xlbmd0aCk7XG5cbiAgICAgICAgVGFibGVEaXJlY3RvcnlFbnRyeS5vdXRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCArPSBUYWJsZURpcmVjdG9yeUVudHJ5Lm9yaWdMZW5ndGg7XG4gICAgICAgIGlmICgob2Zmc2V0ICUgNCkgIT0gMCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICUgNCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBzaXplO1xuXG4gICAgVGFibGVEaXJlY3RvcnlFbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oVGFibGVEaXJlY3RvcnlFbnRyeSkge1xuICAgICAgICB2YXIgY29tcHJlc3NlZERhdGEgPSBidWZmZXJJbi5zbGljZShcbiAgICAgICAgICAgIFRhYmxlRGlyZWN0b3J5RW50cnkub2Zmc2V0LFxuICAgICAgICAgICAgVGFibGVEaXJlY3RvcnlFbnRyeS5vZmZzZXQgKyBUYWJsZURpcmVjdG9yeUVudHJ5LmNvbXBMZW5ndGhcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoVGFibGVEaXJlY3RvcnlFbnRyeS5jb21wTGVuZ3RoICE9IFRhYmxlRGlyZWN0b3J5RW50cnkub3JpZ0xlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHVuY29tcHJlc3NlZERhdGEgPSBuZXcgVWludDhBcnJheShUYWJsZURpcmVjdG9yeUVudHJ5Lm9yaWdMZW5ndGgpO1xuICAgICAgICAgICAgdGlueUluZmxhdGUoXG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGNvbXByZXNzZWREYXRhLCAyKSwgLy9za2lwIGRlZmxhdGUgaGVhZGVyXG4gICAgICAgICAgICAgIHVuY29tcHJlc3NlZERhdGFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmNvbXByZXNzZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoY29tcHJlc3NlZERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlPdXQuc2V0KHVuY29tcHJlc3NlZERhdGEsIFRhYmxlRGlyZWN0b3J5RW50cnkub3V0T2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ID0gVGFibGVEaXJlY3RvcnlFbnRyeS5vdXRPZmZzZXQgKyBUYWJsZURpcmVjdG9yeUVudHJ5Lm9yaWdMZW5ndGg7XG5cbiAgICAgICAgdmFyIHBhZGRpbmcgPSAwO1xuICAgICAgICBpZiAoKG9mZnNldCAlIDQpICE9IDApIHtcbiAgICAgICAgICAgIHBhZGRpbmcgPSA0IC0gKG9mZnNldCAlIDQpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5T3V0LnNldChcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHBhZGRpbmcpLmJ1ZmZlcixcbiAgICAgICAgICAgIFRhYmxlRGlyZWN0b3J5RW50cnkub3V0T2Zmc2V0ICsgVGFibGVEaXJlY3RvcnlFbnRyeS5vcmlnTGVuZ3RoXG4gICAgICAgICk7XG5cbiAgICAgICAgc2l6ZSA9IG9mZnNldCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYnVmZmVyT3V0LnNsaWNlKDAsIHNpemUpO1xufVxuXG4vLyBFbmQgd29mZjJvdGYuanNcblxucmV0dXJuIGZ1bmN0aW9uKGJ1ZmZlcikge1xuICByZXR1cm4gY29udmVydF9zdHJlYW1zKGJ1ZmZlciwgdGlueUluZmxhdGUpXG59XG5cbn1cblxuLyoqXG4gKiBBbiBhZGFwdGVyIHRoYXQgYWxsb3dzIFR5cHIuanMgdG8gYmUgdXNlZCBhcyBpZiBpdCB3ZXJlIChhIHN1YnNldCBvZikgdGhlIE9wZW5UeXBlLmpzIEFQSS5cbiAqIEFsc28gYWRkcyBzdXBwb3J0IGZvciBXT0ZGIGZpbGVzIChub3QgV09GRjIpLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlckZhY3RvcnkoVHlwciwgd29mZjJvdGYpIHtcbiAgdmFyIGNtZEFyZ0xlbmd0aHMgPSB7XG4gICAgTTogMixcbiAgICBMOiAyLFxuICAgIFE6IDQsXG4gICAgQzogNixcbiAgICBaOiAwXG4gIH07XG5cbiAgZnVuY3Rpb24gd3JhcEZvbnRPYmoocmVmKSB7XG4gICAgdmFyIHR5cHJGb250ID0gcmVmWzBdO1xuXG4gICAgdmFyIGdseXBoTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHZhciBmb250T2JqID0ge1xuICAgICAgdW5pdHNQZXJFbTogdHlwckZvbnQuaGVhZC51bml0c1BlckVtLFxuICAgICAgYXNjZW5kZXI6IHR5cHJGb250LmhoZWEuYXNjZW5kZXIsXG4gICAgICBkZXNjZW5kZXI6IHR5cHJGb250LmhoZWEuZGVzY2VuZGVyLFxuICAgICAgZm9yRWFjaEdseXBoOiBmdW5jdGlvbiBmb3JFYWNoR2x5cGgodGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBnbHlwaFggPSAwO1xuICAgICAgICB2YXIgZm9udFNjYWxlID0gMSAvIGZvbnRPYmoudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgICAgIHZhciBnbHlwaEluZGljZXMgPSBUeXByLlUuc3RyaW5nVG9HbHlwaHModHlwckZvbnQsIHRleHQpO1xuICAgICAgICB2YXIgY2hhckluZGV4ID0gMDtcbiAgICAgICAgZ2x5cGhJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKGdseXBoSW5kZXgpIHtcbiAgICAgICAgICAvLyBUeXByIHJldHVybnMgYSBnbHlwaCBpbmRleCBwZXIgc3RyaW5nIGNvZGVwb2ludCwgd2l0aCAtMXMgaW4gcGxhY2Ugb2YgdGhvc2UgdGhhdFxuICAgICAgICAgIC8vIHdlcmUgb21pdHRlZCBkdWUgdG8gbGlnYXR1cmUgc3Vic3RpdHV0aW9uLiBTbyB3ZSBjYW4gdHJhY2sgb3JpZ2luYWwgaW5kZXggaW4gdGhlXG4gICAgICAgICAgLy8gc3RyaW5nIHZpYSBzaW1wbGUgaW5jcmVtZW50LCBhbmQgc2tpcCBldmVyeXRoaW5nIGVsc2Ugd2hlbiBzZWVpbmcgYSAtMS5cbiAgICAgICAgICBpZiAoZ2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaE9iaiA9IGdseXBoTWFwW2dseXBoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFnbHlwaE9iaikge1xuICAgICAgICAgICAgICAvLyAhISEgTk9URTogVHlwciBkb2Vzbid0IGV4cG9zZSBhIHB1YmxpYyBhY2Nlc3NvciBmb3IgdGhlIGdseXBoIGRhdGEsIHNvIHRoaXMganVzdFxuICAgICAgICAgICAgICAvLyBjb3BpZXMgaG93IGl0IHBhcnNlcyB0aGF0IGRhdGEgaW4gVHlwci5VLl9kcmF3R2x5ZiAtLSB0aGlzIG1heSBiZSBmcmFnaWxlLlxuICAgICAgICAgICAgICB2YXIgdHlwckdseXBoID0gVHlwci5nbHlmLl9wYXJzZUdseWYodHlwckZvbnQsIGdseXBoSW5kZXgpIHx8IHt4TWluOiAwLCB4TWF4OiAwLCB5TWluOiAwLCB5TWF4OiAwfTtcbiAgICAgICAgICAgICAgdmFyIHJlZiA9IFR5cHIuVS5nbHlwaFRvUGF0aCh0eXByRm9udCwgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgIHZhciBjbWRzID0gcmVmLmNtZHM7XG4gICAgICAgICAgICAgIHZhciBjcmRzID0gcmVmLmNyZHM7XG5cbiAgICAgICAgICAgICAgZ2x5cGhPYmogPSBnbHlwaE1hcFtnbHlwaEluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogZ2x5cGhJbmRleCxcbiAgICAgICAgICAgICAgICBhZHZhbmNlV2lkdGg6IHR5cHJGb250LmhtdHguYVdpZHRoW2dseXBoSW5kZXhdLFxuICAgICAgICAgICAgICAgIHhNaW46IHR5cHJHbHlwaC54TWluLFxuICAgICAgICAgICAgICAgIHlNaW46IHR5cHJHbHlwaC55TWluLFxuICAgICAgICAgICAgICAgIHhNYXg6IHR5cHJHbHlwaC54TWF4LFxuICAgICAgICAgICAgICAgIHlNYXg6IHR5cHJHbHlwaC55TWF4LFxuICAgICAgICAgICAgICAgIHBhdGhDb21tYW5kQ291bnQ6IGNtZHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGZvckVhY2hQYXRoQ29tbWFuZDogZnVuY3Rpb24gZm9yRWFjaFBhdGhDb21tYW5kKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXJnc0luZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgIHZhciBhcmdzQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1BcmdzID0gY21kQXJnTGVuZ3Roc1tjbWRzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgYXJnc0FycmF5Lmxlbmd0aCA9IDEgKyBudW1BcmdzO1xuICAgICAgICAgICAgICAgICAgICBhcmdzQXJyYXlbMF0gPSBjbWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBudW1BcmdzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzQXJyYXlbal0gPSBjcmRzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmdzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBnbHlwaE9iaiwgZ2x5cGhYLCBjaGFySW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoZ2x5cGhPYmouYWR2YW5jZVdpZHRoKSB7XG4gICAgICAgICAgICAgIGdseXBoWCArPSBnbHlwaE9iai5hZHZhbmNlV2lkdGggKiBmb250U2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgICBnbHlwaFggKz0gbGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFySW5kZXggKz0gKHRleHQuY29kZVBvaW50QXQoY2hhckluZGV4KSA+IDB4ZmZmZiA/IDIgOiAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbHlwaFhcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZvbnRPYmpcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXJzZShidWZmZXIpIHtcbiAgICAvLyBMb29rIHRvIHNlZSBpZiB3ZSBoYXZlIGEgV09GRiBmaWxlIGFuZCBjb252ZXJ0IGl0IGlmIHNvOlxuICAgIHZhciBwZWVrID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCA0KTtcbiAgICB2YXIgdGFnID0gVHlwci5fYmluLnJlYWRBU0NJSShwZWVrLCAwLCA0KTtcbiAgICBpZiAodGFnID09PSAnd09GRicpIHtcbiAgICAgIGJ1ZmZlciA9IHdvZmYyb3RmKGJ1ZmZlcik7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICd3T0YyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b2ZmMiBmb250cyBub3Qgc3VwcG9ydGVkJylcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBGb250T2JqKFR5cHIucGFyc2UoYnVmZmVyKSlcbiAgfVxufVxuXG5cbnZhciB3b3JrZXJNb2R1bGUgPSBkZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBkZXBlbmRlbmNpZXM6IFt0eXByRmFjdG9yeSwgd29mZjJvdGZGYWN0b3J5LCBwYXJzZXJGYWN0b3J5XSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0eXByRmFjdG9yeSwgd29mZjJvdGZGYWN0b3J5LCBwYXJzZXJGYWN0b3J5KSB7XG4gICAgdmFyIFR5cHIgPSB0eXByRmFjdG9yeSgpO1xuICAgIHZhciB3b2ZmMm90ZiA9IHdvZmYyb3RmRmFjdG9yeSgpO1xuICAgIHJldHVybiBwYXJzZXJGYWN0b3J5KFR5cHIsIHdvZmYyb3RmKVxuICB9XG59KTtcblxuLy9pbXBvcnQgZm9udFBhcnNlciBmcm9tICcuL0ZvbnRQYXJzZXJfT3BlblR5cGUuanMnXG5cblxudmFyIENPTkZJRyA9IHtcbiAgZGVmYXVsdEZvbnRVUkw6ICdodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tL3Mvcm9ib3RvL3YxOC9LRk9tQ25xRXU5MkZyMU11NG14TS53b2ZmJywgLy9Sb2JvdG8gUmVndWxhclxuICBzZGZHbHlwaFNpemU6IDY0LFxuICB0ZXh0dXJlV2lkdGg6IDIwNDhcbn07XG52YXIgbGlua0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpOyAvL2ZvciByZXNvbHZpbmcgcmVsYXRpdmUgVVJMcyB0byBhYnNvbHV0ZVxuXG4vKipcbiAqIEN1c3RvbWl6ZXMgdGhlIHRleHQgYnVpbGRlciBjb25maWd1cmF0aW9uLiBUaGlzIG11c3QgYmUgY2FsbGVkIHByaW9yIHRvIHRoZSBmaXJzdCBmb250IHByb2Nlc3NpbmdcbiAqIHJlcXVlc3QsIGFuZCBhcHBsaWVzIHRvIGFsbCBmb250cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRlZmF1bHRGb250VVJMIC0gVGhlIFVSTCBvZiB0aGUgZGVmYXVsdCBmb250IHRvIHVzZSBmb3IgdGV4dCBwcm9jZXNzaW5nXG4gKiAgICAgICAgICAgICAgICAgcmVxdWVzdHMsIGluIGNhc2Ugbm9uZSBpcyBzcGVjaWZpZWQgb3IgdGhlIHNwZWNpZmllZGUgZm9udCBmYWlscyB0byBsb2FkIG9yIHBhcnNlLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIFwiUm9ib3RvIFJlZ3VsYXJcIiBmcm9tIEdvb2dsZSBGb250cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKSB0ZXh0dXJlXG4gKiAgICAgICAgICAgICAgICAgdGhhdCBpcyB1c2VkIGZvciByZW5kZXJpbmcuIE11c3QgYmUgYSBwb3dlci1vZi10d28gbnVtYmVyLCBhbmQgYXBwbGllcyB0byBhbGwgZm9udHMuXG4gKiAgICAgICAgICAgICAgICAgTGFyZ2VyIHNpemVzIGNhbiBpbXByb3ZlIHRoZSBxdWFsaXR5IG9mIGdseXBoIHJlbmRlcmluZyBieSBpbmNyZWFzaW5nIHRoZSBzaGFycG5lc3NcbiAqICAgICAgICAgICAgICAgICBvZiBjb3JuZXJzIGFuZCBwcmV2ZW50aW5nIGxvc3Mgb2YgdmVyeSB0aGluIGxpbmVzLCBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkuIERlZmF1bHRzXG4gKiAgICAgICAgICAgICAgICAgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHkuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnRleHR1cmVXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgU0RGIHRleHR1cmU7IG11c3QgYmUgYSBwb3dlciBvZiAyLiBEZWZhdWx0cyB0b1xuICogICAgICAgICAgICAgICAgIDIwNDggd2hpY2ggaXMgYSBzYWZlIG1heGltdW0gdGV4dHVyZSBkaW1lbnNpb24gYWNjb3JkaW5nIHRvIHRoZSBzdGF0cyBhdFxuICogICAgICAgICAgICAgICAgIGh0dHBzOi8vd2ViZ2xzdGF0cy5jb20vd2ViZ2wvcGFyYW1ldGVyL01BWF9URVhUVVJFX1NJWkUgYW5kIHNob3VsZCBhbGxvdyBmb3IgYVxuICogICAgICAgICAgICAgICAgIHJlYXNvbmFibHkgbGFyZ2UgbnVtYmVyIG9mIGdseXBocyAoZGVmYXVsdCBnbHlwaCBzaXplIG9mIDY0IGFuZCBzYWZlIHRleHR1cmUgc2l6ZSBvZlxuICogICAgICAgICAgICAgICAgIDIwNDheMiBhbGxvd3MgZm9yIDEwMjQgZ2x5cGhzLikgVGhpcyBjYW4gYmUgaW5jcmVhc2VkIGlmIHlvdSBuZWVkIHRvIGluY3JlYXNlIHRoZVxuICogICAgICAgICAgICAgICAgIGdseXBoIHNpemUgYW5kL29yIGhhdmUgYW4gZXh0cmFvcmRpbmFyeSBudW1iZXIgb2YgZ2x5cGhzLlxuICovXG5mdW5jdGlvbiBjb25maWd1cmVUZXh0QnVpbGRlcihjb25maWcpIHtcbiAge1xuICAgIGFzc2lnbihDT05GSUcsIGNvbmZpZyk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFRoZSByYWRpYWwgZGlzdGFuY2UgZnJvbSBnbHlwaCBlZGdlcyBvdmVyIHdoaWNoIHRoZSBTREYgYWxwaGEgd2lsbCBiZSBjYWxjdWxhdGVkOyBpZiB0aGUgYWxwaGFcbiAqIGF0IGRpc3RhbmNlOjAgaXMgMC41LCB0aGVuIHRoZSBhbHBoYSBhdCB0aGlzIGRpc3RhbmNlIHdpbGwgYmUgemVyby4gVGhpcyBpcyBkZWZpbmVkIGFzIGEgcGVyY2VudGFnZVxuICogb2YgZWFjaCBnbHlwaCdzIG1heGltdW0gZGltZW5zaW9uIGluIGZvbnQgc3BhY2UgdW5pdHMgc28gdGhhdCBpdCBtYXBzIHRvIHRoZSBzYW1lIG1pbmltdW0gbnVtYmVyIG9mXG4gKiBTREYgdGV4ZWxzIHJlZ2FyZGxlc3Mgb2YgdGhlIGdseXBoJ3Mgc2l6ZS4gQSBsYXJnZXIgdmFsdWUgcHJvdmlkZXMgZ3JlYXRlciBhbHBoYSBncmFkaWVudCByZXNvbHV0aW9uXG4gKiBhbmQgaW1wcm92ZXMgcmVhZGFiaWxpdHkvYW50aWFsaWFzaW5nIHF1YWxpdHkgYXQgc21hbGwgZGlzcGxheSBzaXplcywgYnV0IGFsc28gZGVjcmVhc2VzIHRoZSBudW1iZXJcbiAqIG9mIHRleGVscyBhdmFpbGFibGUgZm9yIGVuY29kaW5nIHBhdGggZGV0YWlscy5cbiAqL1xudmFyIFNERl9ESVNUQU5DRV9QRVJDRU5UID0gMSAvIDg7XG5cblxuLyoqXG4gKiBSZXBvc2l0b3J5IGZvciBhbGwgZm9udCBTREYgYXRsYXMgdGV4dHVyZXNcbiAqXG4gKiAgIHtcbiAqICAgICBbZm9udF06IHtcbiAqICAgICAgIHNkZlRleHR1cmU6IERhdGFUZXh0dXJlXG4gKiAgICAgfVxuICogICB9XG4gKi9cbnZhciBhdGxhc2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcm9pa2FUZXh0UmVuZGVySW5mbyAtIEZvcm1hdCBvZiB0aGUgcmVzdWx0IGZyb20gYGdldFRleHRSZW5kZXJJbmZvYC5cbiAqIEBwcm9wZXJ0eSB7RGF0YVRleHR1cmV9IHNkZlRleHR1cmVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZGZHbHlwaFNpemVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZGZNaW5EaXN0YW5jZVBlcmNlbnRcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kc1xuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGdseXBoQXRsYXNJbmRpY2VzXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gW2NhcmV0UG9zaXRpb25zXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYXJldEhlaWdodF1cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gdG90YWxCb3VuZHNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gdG90YWxCbG9ja1NpemVcbiAqIEBmcm96ZW5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBnZXRUZXh0UmVuZGVySW5mb35jYWxsYmFja1xuICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAqL1xuXG4vKipcbiAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHJlcXVlc3RpbmcgdGhlIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHRleHQgc3RyaW5nIHdpdGggZ2l2ZW4gZm9udCBwYXJhbWV0ZXJzLlxuICogVGhpcyBpcyBhbiBhc3luY2hyb25vdXMgY2FsbCwgcGVyZm9ybWluZyBtb3N0IG9mIHRoZSBsb2dpYyBpbiBhIHdlYiB3b3JrZXIgdGhyZWFkLlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7Z2V0VGV4dFJlbmRlckluZm9+Y2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRSZW5kZXJJbmZvKGFyZ3MsIGNhbGxiYWNrKSB7XG4gIGFyZ3MgPSBhc3NpZ24oe30sIGFyZ3MpO1xuXG4gIC8vIEFwcGx5IGRlZmF1bHQgZm9udCBoZXJlIHRvIGF2b2lkIGEgJ251bGwnIGF0bGFzLCBhbmQgY29udmVydCByZWxhdGl2ZVxuICAvLyBVUkxzIHRvIGFic29sdXRlIHNvIHRoZXkgY2FuIGJlIHJlc29sdmVkIGluIHRoZSB3b3JrZXJcbiAgbGlua0VsLmhyZWYgPSBhcmdzLmZvbnQgfHwgQ09ORklHLmRlZmF1bHRGb250VVJMO1xuICBhcmdzLmZvbnQgPSBsaW5rRWwuaHJlZjtcblxuICAvLyBOb3JtYWxpemUgdGV4dCB0byBhIHN0cmluZ1xuICBhcmdzLnRleHQgPSAnJyArIGFyZ3MudGV4dDtcblxuICAvLyBJbml0IHRoZSBhdGxhcyBmb3IgdGhpcyBmb250IGlmIG5lZWRlZFxuICB2YXIgc2RmR2x5cGhTaXplID0gQ09ORklHLnNkZkdseXBoU2l6ZTtcbiAgdmFyIHRleHR1cmVXaWR0aCA9IENPTkZJRy50ZXh0dXJlV2lkdGg7XG4gIHZhciBhdGxhcyA9IGF0bGFzZXNbYXJncy5mb250XTtcbiAgaWYgKCFhdGxhcykge1xuICAgIGF0bGFzID0gYXRsYXNlc1thcmdzLmZvbnRdID0ge1xuICAgICAgc2RmVGV4dHVyZTogbmV3IERhdGFUZXh0dXJlKFxuICAgICAgICBuZXcgVWludDhBcnJheShzZGZHbHlwaFNpemUgKiB0ZXh0dXJlV2lkdGgpLFxuICAgICAgICB0ZXh0dXJlV2lkdGgsXG4gICAgICAgIHNkZkdseXBoU2l6ZSxcbiAgICAgICAgTHVtaW5hbmNlRm9ybWF0LFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIExpbmVhckZpbHRlcixcbiAgICAgICAgTGluZWFyRmlsdGVyXG4gICAgICApXG4gICAgfTtcbiAgICBhdGxhcy5zZGZUZXh0dXJlLmZvbnQgPSBhcmdzLmZvbnQ7XG4gIH1cblxuICAvLyBJc3N1ZSByZXF1ZXN0IHRvIHRoZSBGb250UHJvY2Vzc29yIGluIHRoZSB3b3JrZXJcbiAgcHJvY2Vzc0luV29ya2VyKGFyZ3MpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIC8vIElmIHRoZSByZXNwb25zZSBoYXMgbmV3R2x5cGhzLCBjb3B5IHRoZW0gaW50byB0aGUgYXRsYXMgdGV4dHVyZSBhdCB0aGUgc3BlY2lmaWVkIGluZGljZXNcbiAgICBpZiAocmVzdWx0Lm5ld0dseXBoU0RGcykge1xuICAgICAgcmVzdWx0Lm5ld0dseXBoU0RGcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIHRleHR1cmVEYXRhID0gcmVmLnRleHR1cmVEYXRhO1xuICAgICAgICB2YXIgYXRsYXNJbmRleCA9IHJlZi5hdGxhc0luZGV4O1xuXG4gICAgICAgIHZhciB0ZXhJbWcgPSBhdGxhcy5zZGZUZXh0dXJlLmltYWdlO1xuXG4gICAgICAgIC8vIEdyb3cgdGhlIHRleHR1cmUgYnkgcG93ZXIgb2YgMiBpZiBuZWVkZWRcbiAgICAgICAgd2hpbGUgKHRleEltZy5kYXRhLmxlbmd0aCA8IChhdGxhc0luZGV4ICsgMSkgKiBzZGZHbHlwaFNpemUgKiBzZGZHbHlwaFNpemUpIHtcbiAgICAgICAgICB2YXIgYmlnZ2VyQXJyYXkgPSBuZXcgVWludDhBcnJheSh0ZXhJbWcuZGF0YS5sZW5ndGggKiAyKTtcbiAgICAgICAgICBiaWdnZXJBcnJheS5zZXQodGV4SW1nLmRhdGEpO1xuICAgICAgICAgIHRleEltZy5kYXRhID0gYmlnZ2VyQXJyYXk7XG4gICAgICAgICAgdGV4SW1nLmhlaWdodCAqPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBuZXcgZ2x5cGgncyBkYXRhIGludG8gdGhlIGZ1bGwgdGV4dHVyZSBpbWFnZSBhdCB0aGUgY29ycmVjdCBvZmZzZXRzXG4gICAgICAgIHZhciBjb2xzID0gdGV4SW1nLndpZHRoIC8gc2RmR2x5cGhTaXplO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHNkZkdseXBoU2l6ZTsgeSsrKSB7XG4gICAgICAgICAgdmFyIHNyY1N0YXJ0SW5kZXggPSB5ICogc2RmR2x5cGhTaXplO1xuICAgICAgICAgIHZhciB0Z3RTdGFydEluZGV4ID0gdGV4SW1nLndpZHRoICogc2RmR2x5cGhTaXplICogTWF0aC5mbG9vcihhdGxhc0luZGV4IC8gY29scykgLy9mdWxsIHJvd3NcbiAgICAgICAgICAgICsgKGF0bGFzSW5kZXggJSBjb2xzKSAqIHNkZkdseXBoU2l6ZSAvL3BhcnRpYWwgcm93XG4gICAgICAgICAgICArICh5ICogdGV4SW1nLndpZHRoKTsgLy9yb3cgd2l0aGluIGdseXBoXG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzZGZHbHlwaFNpemU7IHgrKykge1xuICAgICAgICAgICAgdGV4SW1nLmRhdGFbdGd0U3RhcnRJbmRleCArIHhdID0gdGV4dHVyZURhdGFbc3JjU3RhcnRJbmRleCArIHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhdGxhcy5zZGZUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aGUgdGV4dCBsYXlvdXQgYXJyYXlzIGFuZCB1cGRhdGVkIHRleHR1cmVcbiAgICBjYWxsYmFjayhPYmplY3QuZnJlZXplKHtcbiAgICAgIHNkZlRleHR1cmU6IGF0bGFzLnNkZlRleHR1cmUsXG4gICAgICBzZGZHbHlwaFNpemU6IHNkZkdseXBoU2l6ZSxcbiAgICAgIHNkZk1pbkRpc3RhbmNlUGVyY2VudDogU0RGX0RJU1RBTkNFX1BFUkNFTlQsXG4gICAgICBnbHlwaEJvdW5kczogcmVzdWx0LmdseXBoQm91bmRzLFxuICAgICAgZ2x5cGhBdGxhc0luZGljZXM6IHJlc3VsdC5nbHlwaEF0bGFzSW5kaWNlcyxcbiAgICAgIGNhcmV0UG9zaXRpb25zOiByZXN1bHQuY2FyZXRQb3NpdGlvbnMsXG4gICAgICBjYXJldEhlaWdodDogcmVzdWx0LmNhcmV0SGVpZ2h0LFxuICAgICAgdG90YWxCb3VuZHM6IHJlc3VsdC50b3RhbEJvdW5kcyxcbiAgICAgIHRvdGFsQmxvY2tTaXplOiByZXN1bHQudG90YWxCbG9ja1NpemVcbiAgICB9KSk7XG4gIH0pO1xufVxuXG4vLyBMb2NhbCBhc3NpZ24gaW1wbCBzbyB3ZSBkb24ndCBoYXZlIHRvIGltcG9ydCB0cm9pa2EtY29yZVxuZnVuY3Rpb24gYXNzaWduKHRvT2JqLCBmcm9tT2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tT2JqKSB7XG4gICAgaWYgKGZyb21PYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdG9PYmpba2V5XSA9IGZyb21PYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvT2JqXG59XG5cblxudmFyIGZvbnRQcm9jZXNzb3JXb3JrZXJNb2R1bGUgPSBkZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBkZXBlbmRlbmNpZXM6IFtcbiAgICBDT05GSUcsXG4gICAgU0RGX0RJU1RBTkNFX1BFUkNFTlQsXG4gICAgd29ya2VyTW9kdWxlLFxuICAgIGNyZWF0ZVNERkdlbmVyYXRvcixcbiAgICBjcmVhdGVGb250UHJvY2Vzc29yXG4gIF0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQoY29uZmlnLCBzZGZEaXN0YW5jZVBlcmNlbnQsIGZvbnRQYXJzZXIsIGNyZWF0ZVNERkdlbmVyYXRvciwgY3JlYXRlRm9udFByb2Nlc3Nvcikge1xuICAgIHZhciBzZGZHZW5lcmF0b3IgPSBjcmVhdGVTREZHZW5lcmF0b3Ioe1xuICAgICAgc2RmVGV4dHVyZVNpemU6IGNvbmZpZy5zZGZHbHlwaFNpemUsXG4gICAgICBzZGZEaXN0YW5jZVBlcmNlbnQ6IHNkZkRpc3RhbmNlUGVyY2VudFxuICAgIH0pO1xuICAgIHJldHVybiBjcmVhdGVGb250UHJvY2Vzc29yKGZvbnRQYXJzZXIsIHNkZkdlbmVyYXRvciwge1xuICAgICAgZGVmYXVsdEZvbnRVcmw6IGNvbmZpZy5kZWZhdWx0Rm9udFVSTFxuICAgIH0pXG4gIH1cbn0pO1xuXG52YXIgcHJvY2Vzc0luV29ya2VyID0gZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgZGVwZW5kZW5jaWVzOiBbZm9udFByb2Nlc3Nvcldvcmtlck1vZHVsZSwgVGhlbmFibGVXb3JrZXJNb2R1bGVdLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KGZvbnRQcm9jZXNzb3IsIFRoZW5hYmxlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIHZhciB0aGVuYWJsZSA9IG5ldyBUaGVuYWJsZSgpO1xuICAgICAgZm9udFByb2Nlc3Nvci5wcm9jZXNzKGFyZ3MsIHRoZW5hYmxlLnJlc29sdmUpO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlXG4gICAgfVxuICB9LFxuICBnZXRUcmFuc2ZlcmFibGVzOiBmdW5jdGlvbiBnZXRUcmFuc2ZlcmFibGVzKHJlc3VsdCkge1xuICAgIC8vIE1hcmsgYXJyYXkgYnVmZmVycyBhcyB0cmFuc2ZlcmFibGUgdG8gYXZvaWQgY2xvbmluZyBkdXJpbmcgcG9zdE1lc3NhZ2VcbiAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IFtcbiAgICAgIHJlc3VsdC5nbHlwaEJvdW5kcy5idWZmZXIsXG4gICAgICByZXN1bHQuZ2x5cGhBdGxhc0luZGljZXMuYnVmZmVyXG4gICAgXTtcbiAgICBpZiAocmVzdWx0LmNhcmV0UG9zaXRpb25zKSB7XG4gICAgICB0cmFuc2ZlcmFibGVzLnB1c2gocmVzdWx0LmNhcmV0UG9zaXRpb25zLmJ1ZmZlcik7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubmV3R2x5cGhTREZzKSB7XG4gICAgICByZXN1bHQubmV3R2x5cGhTREZzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGQudGV4dHVyZURhdGEuYnVmZmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmZXJhYmxlc1xuICB9XG59KTtcblxuLypcbndpbmRvdy5fZHVtcFNERnMgPSBmdW5jdGlvbigpIHtcbiAgT2JqZWN0LnZhbHVlcyhhdGxhc2VzKS5mb3JFYWNoKGF0bGFzID0+IHtcbiAgICBjb25zdCBpbWdEYXRhID0gYXRsYXMuc2RmVGV4dHVyZS5pbWFnZS5kYXRhXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBhdGxhcy5zZGZUZXh0dXJlLmltYWdlXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjdHguZmlsbFN0eWxlID0gJyNmZmYnXG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBgcmdiYSgwLDAsMCwke2ltZ0RhdGFbeSAqIHdpZHRoICsgeF0vMjU1fSlgXG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCAxLCAxKVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxuICAgIGltZy5zcmMgPSBjYW52YXMudG9EYXRhVVJMKClcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZylcbiAgICBjb25zb2xlLmxvZyhpbWcpXG4gIH0pXG59XG4qL1xuXG52YXIgdGVtcGxhdGVHZW9tZXRyeSA9IG5ldyBQbGFuZUJ1ZmZlckdlb21ldHJ5KDEsIDEpLnRyYW5zbGF0ZSgwLjUsIDAuNSwgMCk7XG52YXIgdGVtcFZlYzMgPSBuZXcgVmVjdG9yMygpO1xuXG52YXIgZ2x5cGhCb3VuZHNBdHRyTmFtZSA9ICdhVHJvaWthR2x5cGhCb3VuZHMnO1xudmFyIGdseXBoSW5kZXhBdHRyTmFtZSA9ICdhVHJvaWthR2x5cGhJbmRleCc7XG5cblxuXG4vKipcbkBjbGFzcyBHbHlwaHNHZW9tZXRyeVxuXG5BIHNwZWNpYWxpemVkIEdlb21ldHJ5IGZvciByZW5kZXJpbmcgYSBzZXQgb2YgdGV4dCBnbHlwaHMuIFVzZXMgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgdG9cbnJlbmRlciB0aGUgZ2x5cGhzIHVzaW5nIEdQVSBpbnN0YW5jaW5nIG9mIGEgc2luZ2xlIHF1YWQsIHJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyBhIHdob2xlXG5nZW9tZXRyeSB3aXRoIHZlcnRpY2VzLCBmb3IgbXVjaCBzbWFsbGVyIGF0dHJpYnV0ZSBhcnJheWJ1ZmZlcnMgYWNjb3JkaW5nIHRvIHRoaXMgbWF0aDpcblxuICBXaGVyZSBOID0gbnVtYmVyIG9mIGdseXBocy4uLlxuXG4gIEluc3RhbmNlZDpcbiAgLSBwb3NpdGlvbjogNCAqIDNcbiAgLSBpbmRleDogMiAqIDNcbiAgLSBub3JtYWw6IDQgKiAzXG4gIC0gdXY6IDQgKiAyXG4gIC0gZ2x5cGggeC95IGJvdW5kczogTiAqIDRcbiAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICA9IDVOICsgMzhcblxuICBOb24taW5zdGFuY2VkOlxuICAtIHBvc2l0aW9uOiBOICogNCAqIDNcbiAgLSBpbmRleDogTiAqIDIgKiAzXG4gIC0gbm9ybWFsOiBOICogNCAqIDNcbiAgLSB1djogTiAqIDQgKiAyXG4gIC0gZ2x5cGggaW5kaWNlczogTiAqIDFcbiAgPSAzOU5cblxuQSBkb3duc2lkZSBvZiB0aGlzIGlzIHRoZSByYXJlLWJ1dC1wb3NzaWJsZSBsYWNrIG9mIHRoZSBpbnN0YW5jZWQgYXJyYXlzIGV4dGVuc2lvbixcbndoaWNoIHdlIGNvdWxkIHBvdGVudGlhbGx5IHdvcmsgYXJvdW5kIHdpdGggYSBmYWxsYmFjayBub24taW5zdGFuY2VkIGltcGxlbWVudGF0aW9uLlxuXG4qL1xudmFyIEdseXBoc0dlb21ldHJ5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gR2x5cGhzR2VvbWV0cnkoKSB7XG4gICAgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkuY2FsbCh0aGlzKTtcblxuICAgIC8vIEJhc2UgcGVyLWluc3RhbmNlIGF0dHJpYnV0ZXNcbiAgICB0aGlzLmNvcHkodGVtcGxhdGVHZW9tZXRyeSk7XG5cbiAgICAvLyBQcmVhbGxvY2F0ZSB6ZXJvLXJhZGl1cyBib3VuZGluZyBzcGhlcmVcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICB9XG5cbiAgaWYgKCBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSApIEdseXBoc0dlb21ldHJ5Ll9fcHJvdG9fXyA9IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5O1xuICBHbHlwaHNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSAmJiBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgR2x5cGhzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2x5cGhzR2VvbWV0cnk7XG5cbiAgR2x5cGhzR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSA9IGZ1bmN0aW9uIGNvbXB1dGVCb3VuZGluZ1NwaGVyZSAoKSB7XG4gICAgLy8gTm8tb3A7IHdlJ2xsIHN5bmMgdGhlIGJvdW5kaW5nU3BoZXJlIHByb2FjdGl2ZWx5IGluIGB1cGRhdGVHbHlwaHNgLlxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGdlb21ldHJ5IGZvciBhIG5ldyBzZXQgb2YgZ2x5cGhzLlxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZ2x5cGhCb3VuZHMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBwbGFuYXIgYm91bmRzIGZvciBhbGwgZ2x5cGhzXG4gICAqICAgICAgICB0byBiZSByZW5kZXJlZCwgNCBlbnRyaWVzIGZvciBlYWNoIGdseXBoOiB4MSx4Mix5MSx5MVxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZ2x5cGhBdGxhc0luZGljZXMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBpbmRleCBvZiBlYWNoIGdseXBoIHdpdGhpblxuICAgKiAgICAgICAgdGhlIFNERiBhdGxhcyB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0FycmF5fSB0b3RhbEJvdW5kcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBhY3Jvc3MgYWxsIGdseXBoc1xuICAgKi9cbiAgR2x5cGhzR2VvbWV0cnkucHJvdG90eXBlLnVwZGF0ZUdseXBocyA9IGZ1bmN0aW9uIHVwZGF0ZUdseXBocyAoZ2x5cGhCb3VuZHMsIGdseXBoQXRsYXNJbmRpY2VzLCB0b3RhbEJvdW5kcykge1xuICAgIC8vIFVwZGF0ZSB0aGUgaW5zdGFuY2UgYXR0cmlidXRlc1xuICAgIHVwZGF0ZUJ1ZmZlckF0dHIodGhpcywgZ2x5cGhCb3VuZHNBdHRyTmFtZSwgZ2x5cGhCb3VuZHMsIDQpO1xuICAgIHVwZGF0ZUJ1ZmZlckF0dHIodGhpcywgZ2x5cGhJbmRleEF0dHJOYW1lLCBnbHlwaEF0bGFzSW5kaWNlcywgMSk7XG4gICAgdGhpcy5tYXhJbnN0YW5jZWRDb3VudCA9IGdseXBoQXRsYXNJbmRpY2VzLmxlbmd0aDtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYm91bmRpbmdTcGhlcmUgYmFzZWQgb24gdGhlIHRvdGFsIGJvdW5kc1xuICAgIHZhciBzcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuICAgIHNwaGVyZS5jZW50ZXIuc2V0KFxuICAgICAgKHRvdGFsQm91bmRzWzBdICsgdG90YWxCb3VuZHNbMl0pIC8gMixcbiAgICAgICh0b3RhbEJvdW5kc1sxXSArIHRvdGFsQm91bmRzWzNdKSAvIDIsXG4gICAgICAwXG4gICAgKTtcbiAgICBzcGhlcmUucmFkaXVzID0gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvKHRlbXBWZWMzLnNldCh0b3RhbEJvdW5kc1swXSwgdG90YWxCb3VuZHNbMV0sIDApKTtcbiAgfTtcblxuICByZXR1cm4gR2x5cGhzR2VvbWV0cnk7XG59KEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KSk7XG5cbi8vIENvbXBhdCBmb3IgcHJlIHIxMDk6XG5pZiAoIUdseXBoc0dlb21ldHJ5LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUpIHtcbiAgR2x5cGhzR2VvbWV0cnkucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cblxuZnVuY3Rpb24gdXBkYXRlQnVmZmVyQXR0cihnZW9tLCBhdHRyTmFtZSwgbmV3QXJyYXksIGl0ZW1TaXplKSB7XG4gIHZhciBhdHRyID0gZ2VvbS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAvLyBJZiBsZW5ndGggaXNuJ3QgY2hhbmdpbmcsIGp1c3QgdXBkYXRlIHRoZSBhdHRyaWJ1dGUncyBhcnJheSBkYXRhXG4gIGlmIChhdHRyICYmIGF0dHIuYXJyYXkubGVuZ3RoID09PSBuZXdBcnJheS5sZW5ndGgpIHtcbiAgICBhdHRyLmFycmF5LnNldChuZXdBcnJheSk7XG4gICAgYXR0ci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgZ2VvbS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUobmV3QXJyYXksIGl0ZW1TaXplKSk7XG4gIH1cbn1cblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFZFUlRFWF9ERUZTID0gXCJcXG51bmlmb3JtIHZlYzIgdVRyb2lrYVNERlRleHR1cmVTaXplO1xcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYVNERkdseXBoU2l6ZTtcXG51bmlmb3JtIHZlYzQgdVRyb2lrYVRvdGFsQm91bmRzO1xcbmF0dHJpYnV0ZSB2ZWM0IGFUcm9pa2FHbHlwaEJvdW5kcztcXG5hdHRyaWJ1dGUgZmxvYXQgYVRyb2lrYUdseXBoSW5kZXg7XFxudmFyeWluZyB2ZWMyIHZUcm9pa2FTREZUZXh0dXJlVVY7XFxudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaFVWO1xcbnZhcnlpbmcgdmVjMyB2VHJvaWthTG9jYWxQb3M7XFxuXCI7XG5cbi8vIGxhbmd1YWdlPUdMU0wgcHJlZml4PVwidm9pZCBtYWluKCkge1wiIHN1ZmZpeD1cIn1cIlxudmFyIFZFUlRFWF9UUkFOU0ZPUk0gPSBcIlxcbnZUcm9pa2FHbHlwaFVWID0gdmVjMihwb3NpdGlvbik7XFxuXFxudmVjMiBjb2xzQW5kUm93cyA9IHVUcm9pa2FTREZUZXh0dXJlU2l6ZSAvIHVUcm9pa2FTREZHbHlwaFNpemU7XFxudlRyb2lrYVNERlRleHR1cmVVViA9IHZlYzIoXFxuICBtb2QoYVRyb2lrYUdseXBoSW5kZXgsIGNvbHNBbmRSb3dzLngpICsgcG9zaXRpb24ueCxcXG4gIGZsb29yKGFUcm9pa2FHbHlwaEluZGV4IC8gY29sc0FuZFJvd3MueCkgKyBwb3NpdGlvbi55XFxuKSAqIHVUcm9pa2FTREZHbHlwaFNpemUgLyB1VHJvaWthU0RGVGV4dHVyZVNpemU7XFxuXFxucG9zaXRpb24gPSB2ZWMzKFxcbiAgbWl4KGFUcm9pa2FHbHlwaEJvdW5kcy54LCBhVHJvaWthR2x5cGhCb3VuZHMueiwgcG9zaXRpb24ueCksXFxuICBtaXgoYVRyb2lrYUdseXBoQm91bmRzLnksIGFUcm9pa2FHbHlwaEJvdW5kcy53LCBwb3NpdGlvbi55KSxcXG4gIHBvc2l0aW9uLnpcXG4pO1xcbnZUcm9pa2FMb2NhbFBvcyA9IHZlYzMocG9zaXRpb24pO1xcblxcbnV2ID0gdmVjMihcXG4gIChwb3NpdGlvbi54IC0gdVRyb2lrYVRvdGFsQm91bmRzLngpIC8gKHVUcm9pa2FUb3RhbEJvdW5kcy56IC0gdVRyb2lrYVRvdGFsQm91bmRzLngpLFxcbiAgKHBvc2l0aW9uLnkgLSB1VHJvaWthVG90YWxCb3VuZHMueSkgLyAodVRyb2lrYVRvdGFsQm91bmRzLncgLSB1VHJvaWthVG90YWxCb3VuZHMueSlcXG4pO1xcblwiO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgRlJBR01FTlRfREVGUyA9IFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRyb2lrYVNERlRleHR1cmU7XFxudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGTWluRGlzdGFuY2VQY3Q7XFxudW5pZm9ybSBib29sIHVUcm9pa2FTREZEZWJ1ZztcXG51bmlmb3JtIHZlYzQgdVRyb2lrYUNsaXBSZWN0O1xcbnZhcnlpbmcgdmVjMiB2VHJvaWthU0RGVGV4dHVyZVVWO1xcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhVVjtcXG52YXJ5aW5nIHZlYzMgdlRyb2lrYUxvY2FsUG9zO1xcblxcbmZsb2F0IHRyb2lrYUdldENsaXBBbHBoYSgpIHtcXG4gIHZlYzQgY2xpcCA9IHVUcm9pa2FDbGlwUmVjdDtcXG4gIHZlYzMgcG9zID0gdlRyb2lrYUxvY2FsUG9zO1xcbiAgZmxvYXQgZENsaXAgPSBtaW4oXFxuICAgIG1pbihwb3MueCAtIG1pbihjbGlwLngsIGNsaXAueiksIG1heChjbGlwLngsIGNsaXAueikgLSBwb3MueCksXFxuICAgIG1pbihwb3MueSAtIG1pbihjbGlwLnksIGNsaXAudyksIG1heChjbGlwLnksIGNsaXAudykgLSBwb3MueSlcXG4gICk7XFxuICAjaWYgZGVmaW5lZChHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMpIHx8IF9fVkVSU0lPTl9fID49IDMwMFxcbiAgZmxvYXQgYWEgPSBsZW5ndGgoZndpZHRoKHBvcykpICogMC41O1xcbiAgcmV0dXJuIHNtb290aHN0ZXAoLWFhLCBhYSwgZENsaXApO1xcbiAgI2Vsc2VcXG4gIHJldHVybiBzdGVwKDAuMCwgZENsaXApO1xcbiAgI2VuZGlmXFxufVxcblxcbmZsb2F0IHRyb2lrYUdldFRleHRBbHBoYSgpIHtcXG4gIGZsb2F0IHRyb2lrYVNERlZhbHVlID0gdGV4dHVyZTJEKHVUcm9pa2FTREZUZXh0dXJlLCB2VHJvaWthU0RGVGV4dHVyZVVWKS5yO1xcbiAgXFxuICAjaWYgZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgfHwgZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcXG4gIGZsb2F0IGFscGhhID0gc3RlcCgwLjUsIHRyb2lrYVNERlZhbHVlKTtcXG4gICNlbHNlXFxuICBcIiArICgnJykgKyBcIlxcbiAgI2lmIGRlZmluZWQoR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzKSB8fCBfX1ZFUlNJT05fXyA+PSAzMDBcXG4gIGZsb2F0IGFhRGlzdCA9IG1pbihcXG4gICAgMC41LFxcbiAgICAwLjUgKiBtaW4oXFxuICAgICAgZndpZHRoKHZUcm9pa2FHbHlwaFVWLngpLFxcbiAgICAgIGZ3aWR0aCh2VHJvaWthR2x5cGhVVi55KVxcbiAgICApXFxuICApIC8gdVRyb2lrYVNERk1pbkRpc3RhbmNlUGN0O1xcbiAgI2Vsc2VcXG4gIGZsb2F0IGFhRGlzdCA9IDAuMDE7XFxuICAjZW5kaWZcXG4gIFxcbiAgZmxvYXQgYWxwaGEgPSB1VHJvaWthU0RGRGVidWcgPyB0cm9pa2FTREZWYWx1ZSA6IHNtb290aHN0ZXAoXFxuICAgIDAuNSAtIGFhRGlzdCxcXG4gICAgMC41ICsgYWFEaXN0LFxcbiAgICB0cm9pa2FTREZWYWx1ZVxcbiAgKTtcXG4gICNlbmRpZlxcbiAgXFxuICByZXR1cm4gbWluKGFscGhhLCB0cm9pa2FHZXRDbGlwQWxwaGEoKSk7XFxufVxcblwiO1xuXG4vLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbnZhciBGUkFHTUVOVF9UUkFOU0ZPUk0gPSBcIlxcbmZsb2F0IHRyb2lrYUFscGhhTXVsdCA9IHRyb2lrYUdldFRleHRBbHBoYSgpO1xcbmlmICh0cm9pa2FBbHBoYU11bHQgPT0gMC4wKSB7XFxuICBkaXNjYXJkO1xcbn0gZWxzZSB7XFxuICBnbF9GcmFnQ29sb3IuYSAqPSB0cm9pa2FBbHBoYU11bHQ7XFxufVxcblwiO1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbWF0ZXJpYWwgZm9yIHJlbmRlcmluZyB0ZXh0LCBkZXJpdmVkIGZyb20gYSBiYXNlTWF0ZXJpYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgdmFyIHRleHRNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIHtcbiAgICBleHRlbnNpb25zOiB7ZGVyaXZhdGl2ZXM6IHRydWV9LFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICB1VHJvaWthU0RGVGV4dHVyZToge3ZhbHVlOiBudWxsfSxcbiAgICAgIHVUcm9pa2FTREZUZXh0dXJlU2l6ZToge3ZhbHVlOiBuZXcgVmVjdG9yMigpfSxcbiAgICAgIHVUcm9pa2FTREZHbHlwaFNpemU6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthU0RGTWluRGlzdGFuY2VQY3Q6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthVG90YWxCb3VuZHM6IHt2YWx1ZTogbmV3IFZlY3RvcjQoKX0sXG4gICAgICB1VHJvaWthQ2xpcFJlY3Q6IHt2YWx1ZTogbmV3IFZlY3RvcjQoKX0sXG4gICAgICB1VHJvaWthU0RGRGVidWc6IHt2YWx1ZTogZmFsc2V9XG4gICAgfSxcbiAgICB2ZXJ0ZXhEZWZzOiBWRVJURVhfREVGUyxcbiAgICB2ZXJ0ZXhUcmFuc2Zvcm06IFZFUlRFWF9UUkFOU0ZPUk0sXG4gICAgZnJhZ21lbnREZWZzOiBGUkFHTUVOVF9ERUZTLFxuICAgIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm06IEZSQUdNRU5UX1RSQU5TRk9STVxuICB9KTtcblxuICAvLyBGb3JjZSB0cmFuc3BhcmVuY3kgLSBUT0RPIGlzIHRoaXMgcmVhc29uYWJsZT9cbiAgdGV4dE1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAvLyBXZWJHTFNoYWRvd01hcCByZXZlcnNlcyB0aGUgc2lkZSBvZiB0aGUgc2hhZG93IG1hdGVyaWFsIGJ5IGRlZmF1bHQsIHdoaWNoIGZhaWxzXG4gIC8vIGZvciBwbGFuZXMsIHNvIGhlcmUgd2UgZm9yY2UgdGhlIGBzaGFkb3dTaWRlYCB0byBhbHdheXMgbWF0Y2ggdGhlIG1haW4gc2lkZS5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRleHRNYXRlcmlhbCwgJ3NoYWRvd1NpZGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWRlXG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGV4dE1hdGVyaWFsXG59XG5cbnZhciBkZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICBjb2xvcjogMHhmZmZmZmYsXG4gIHNpZGU6IERvdWJsZVNpZGUsXG4gIHRyYW5zcGFyZW50OiB0cnVlXG59KTtcblxudmFyIHRlbXBNYXQ0ID0gbmV3IE1hdHJpeDQoKTtcblxudmFyIHJheWNhc3RNZXNoID0gbmV3IE1lc2goXG4gIG5ldyBQbGFuZUJ1ZmZlckdlb21ldHJ5KDEsIDEpLnRyYW5zbGF0ZSgwLjUsIDAuNSwgMCksXG4gIGRlZmF1bHRNYXRlcmlhbFxuKTtcblxuXG5cbi8qKlxuICogQGNsYXNzIFRleHRNZXNoXG4gKlxuICogQSBUaHJlZUpTIE1lc2ggdGhhdCByZW5kZXJzIGEgc3RyaW5nIG9mIHRleHQgb24gYSBwbGFuZSBpbiAzRCBzcGFjZSB1c2luZyBzaWduZWQgZGlzdGFuY2VcbiAqIGZpZWxkcyAoU0RGKS5cbiAqL1xudmFyIFRleHRNZXNoID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWVzaCkge1xuICBmdW5jdGlvbiBUZXh0TWVzaChtYXRlcmlhbCkge1xuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBHbHlwaHNHZW9tZXRyeSgpO1xuICAgIE1lc2guY2FsbCh0aGlzLCBnZW9tZXRyeSwgbnVsbCk7XG5cbiAgICAvLyA9PT0gVGV4dCBsYXlvdXQgcHJvcGVydGllczogPT09IC8vXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRleHRcbiAgICAgKiBUaGUgc3RyaW5nIG9mIHRleHQgdG8gYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgdGhpcy50ZXh0ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtBcnJheTxudW1iZXI+fSBhbmNob3JcbiAgICAgKiBEZWZpbmVzIHdoZXJlIGluIHRoZSB0ZXh0IGJsb2NrIHNob3VsZCBjb3JyZXNwb25kIHRvIHRoZSBtZXNoJ3MgbG9jYWwgcG9zaXRpb24sIGFzIGEgc2V0XG4gICAgICogb2YgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcGVyY2VudGFnZXMgZnJvbSAwIHRvIDEuIEEgdmFsdWUgb2YgYFswLCAwXWAgKHRoZSBkZWZhdWx0KVxuICAgICAqIGFuY2hvcnMgYXQgdGhlIHRvcC1sZWZ0LCBgWzEsIDFdYCBhdCB0aGUgYm90dG9tLXJpZ2h0LCBhbmQgYFswLjUsIDAuNV1gIGNlbnRlcnMgdGhlXG4gICAgICogYmxvY2sgYXQgdGhlIG1lc2gncyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGZvbnRcbiAgICAgKiBVUkwgb2YgYSBjdXN0b20gZm9udCB0byBiZSB1c2VkLiBGb250IGZpbGVzIGNhbiBiZSBhbnkgb2YgdGhlIGZvcm1hdHMgc3VwcG9ydGVkIGJ5XG4gICAgICogT3BlblR5cGUgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbnR5cGVqcy9vcGVudHlwZS5qcykuXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIFJvYm90byBmb250IGxvYWRlZCBmcm9tIEdvb2dsZSBGb250cy5cbiAgICAgKi9cbiAgICB0aGlzLmZvbnQgPSBudWxsOyAvL3dpbGwgdXNlIGRlZmF1bHQgZnJvbSBUZXh0QnVpbGRlclxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBmb250U2l6ZVxuICAgICAqIFRoZSBzaXplIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgZm9udCBpbiBsb2NhbCB1bml0czsgY29ycmVzcG9uZHMgdG8gdGhlIGVtLWJveCBoZWlnaHRcbiAgICAgKiBvZiB0aGUgY2hvc2VuIGBmb250YC5cbiAgICAgKi9cbiAgICB0aGlzLmZvbnRTaXplID0gMC4xO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZXR0ZXJTcGFjaW5nXG4gICAgICogU2V0cyBhIHVuaWZvcm0gYWRqdXN0bWVudCB0byBzcGFjaW5nIGJldHdlZW4gbGV0dGVycyBhZnRlciBrZXJuaW5nIGlzIGFwcGxpZWQuIFBvc2l0aXZlXG4gICAgICogbnVtYmVycyBpbmNyZWFzZSBzcGFjaW5nIGFuZCBuZWdhdGl2ZSBudW1iZXJzIGRlY3JlYXNlIGl0LlxuICAgICAqL1xuICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBsaW5lSGVpZ2h0XG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIGVhY2ggbGluZSBvZiB0ZXh0LCBhcyBhIG11bHRpcGxlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byAnbm9ybWFsJ1xuICAgICAqIHdoaWNoIGNob29zZXMgYSByZWFzb25hYmxlIGhlaWdodCBiYXNlZCBvbiB0aGUgY2hvc2VuIGZvbnQncyBhc2NlbmRlci9kZXNjZW5kZXIgbWV0cmljcy5cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVIZWlnaHQgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbWF4V2lkdGhcbiAgICAgKiBUaGUgbWF4aW11bSB3aWR0aCBvZiB0aGUgdGV4dCBibG9jaywgYWJvdmUgd2hpY2ggdGV4dCBtYXkgc3RhcnQgd3JhcHBpbmcgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIGB3aGl0ZVNwYWNlYCBhbmQgYG92ZXJmbG93V3JhcGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICB0aGlzLm1heFdpZHRoID0gSW5maW5pdHk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG92ZXJmbG93V3JhcFxuICAgICAqIERlZmluZXMgaG93IHRleHQgd3JhcHMgaWYgdGhlIGB3aGl0ZVNwYWNlYCBwcm9wZXJ0eSBpcyBgbm9ybWFsYC4gQ2FuIGJlIGVpdGhlciBgJ25vcm1hbCdgXG4gICAgICogdG8gYnJlYWsgYXQgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLCBvciBgJ2JyZWFrLXdvcmQnYCB0byBhbGxvdyBicmVha2luZyB3aXRoaW4gd29yZHMuXG4gICAgICogRGVmYXVsdHMgdG8gYCdub3JtYWwnYC5cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJmbG93V3JhcCA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0QWxpZ25cbiAgICAgKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgZWFjaCBsaW5lIG9mIHRleHQgd2l0aGluIHRoZSBvdmVyYWxsIHRleHQgYm91bmRpbmcgYm94LlxuICAgICAqL1xuICAgIHRoaXMudGV4dEFsaWduID0gJ2xlZnQnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB3aGl0ZVNwYWNlXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRleHQgc2hvdWxkIHdyYXAgd2hlbiBhIGxpbmUgcmVhY2hlcyB0aGUgYG1heFdpZHRoYC4gQ2FuXG4gICAgICogYmUgZWl0aGVyIGAnbm9ybWFsJ2AgKHRoZSBkZWZhdWx0KSwgdG8gYWxsb3cgd3JhcHBpbmcgYWNjb3JkaW5nIHRvIHRoZSBgb3ZlcmZsb3dXcmFwYCBwcm9wZXJ0eSxcbiAgICAgKiBvciBgJ25vd3JhcCdgIHRvIHByZXZlbnQgd3JhcHBpbmcuIE5vdGUgdGhhdCBgJ25vcm1hbCdgIGhlcmUgaG9ub3JzIG5ld2xpbmUgY2hhcmFjdGVycyB0b1xuICAgICAqIG1hbnVhbGx5IGJyZWFrIGxpbmVzLCBtYWtpbmcgaXQgYmVoYXZlIG1vcmUgbGlrZSBgJ3ByZS13cmFwJ2AgZG9lcyBpbiBDU1MuXG4gICAgICovXG4gICAgdGhpcy53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG5cblxuICAgIC8vID09PSBQcmVzZW50YXRpb24gcHJvcGVydGllczogPT09IC8vXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtUSFJFRS5NYXRlcmlhbH0gbWF0ZXJpYWxcbiAgICAgKiBEZWZpbmVzIGEgX2Jhc2VfIG1hdGVyaWFsIHRvIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgdGhlIHRleHQuIFRoaXMgbWF0ZXJpYWwgd2lsbCBiZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgd2l0aCBhIG1hdGVyaWFsIGRlcml2ZWQgZnJvbSBpdCwgdGhhdCBhZGRzIHNoYWRlciBjb2RlIHRvXG4gICAgICogZGVjcmVhc2UgdGhlIGFscGhhIGZvciBlYWNoIGZyYWdtZW50IChwaXhlbCkgb3V0c2lkZSB0aGUgdGV4dCBnbHlwaHMsIHdpdGggYW50aWFsaWFzaW5nLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQgd2lsbCBkZXJpdmUgZnJvbSBhIHNpbXBsZSB3aGl0ZSBNZXNoQmFzaWNNYXRlcmlhbCwgYnV0IHlvdSBjYW4gdXNlIGFueVxuICAgICAqIG9mIHRoZSBvdGhlciBtZXNoIG1hdGVyaWFscyB0byBnYWluIG90aGVyIGZlYXR1cmVzIGxpa2UgbGlnaHRpbmcsIHRleHR1cmUgbWFwcywgZXRjLlxuICAgICAqXG4gICAgICogQWxzbyBzZWUgdGhlIGBjb2xvcmAgc2hvcnRjdXQgcHJvcGVydHkuXG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBjb2xvclxuICAgICAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3Igc2V0dGluZyB0aGUgYGNvbG9yYCBvZiB0aGUgdGV4dCdzIG1hdGVyaWFsLiBZb3UgY2FuIHVzZSB0aGlzXG4gICAgICogaWYgeW91IGRvbid0IHdhbnQgdG8gc3BlY2lmeSBhIHdob2xlIGN1c3RvbSBgbWF0ZXJpYWxgLlxuICAgICAqL1xuICAgIHRoaXMuY29sb3IgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBkZXB0aE9mZnNldFxuICAgICAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3Igc2V0dGluZyB0aGUgbWF0ZXJpYWwncyBgcG9seWdvbk9mZnNldGAgYW5kIHJlbGF0ZWQgcHJvcGVydGllcyxcbiAgICAgKiB3aGljaCBjYW4gYmUgdXNlZnVsIGluIHByZXZlbnRpbmcgei1maWdodGluZyB3aGVuIHRoaXMgdGV4dCBpcyBsYWlkIG9uIHRvcCBvZiBhbm90aGVyXG4gICAgICogcGxhbmUgaW4gdGhlIHNjZW5lLiBQb3NpdGl2ZSBudW1iZXJzIGFyZSBmdXJ0aGVyIGZyb20gdGhlIGNhbWVyYSwgbmVnYXRpdmVzIGNsb3Nlci5cbiAgICAgKi9cbiAgICB0aGlzLmRlcHRoT2Zmc2V0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0FycmF5PG51bWJlcj59IGNsaXBSZWN0XG4gICAgICogSWYgc3BlY2lmaWVkLCBkZWZpbmVzIGEgYFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXWAgb2YgYSByZWN0YW5nbGUgb3V0c2lkZSBvZiB3aGljaCBhbGxcbiAgICAgKiBwaXhlbHMgd2lsbCBiZSBkaXNjYXJkZWQuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGUgdG8gY2xpcCBvdmVyZmxvd2luZyB0ZXh0IHdoZW5cbiAgICAgKiBgd2hpdGVTcGFjZT0nbm93cmFwJ2AuXG4gICAgICovXG4gICAgdGhpcy5jbGlwUmVjdCA9IG51bGw7XG5cbiAgICB0aGlzLmRlYnVnU0RGID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIE1lc2ggKSBUZXh0TWVzaC5fX3Byb3RvX18gPSBNZXNoO1xuICBUZXh0TWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoICYmIE1lc2gucHJvdG90eXBlICk7XG4gIFRleHRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRNZXNoO1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHRleHRSZW5kZXJJbmZvOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LG1hdGVyaWFsOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGN1c3RvbURlcHRoTWF0ZXJpYWw6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY3VzdG9tRGlzdGFuY2VNYXRlcmlhbDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0ZXh0IHJlbmRlcmluZyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdGV4dC1yZWxhdGVkIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcy5cbiAgICogVGhpcyBpcyBhbiBhc3luYyBwcm9jZXNzLCBzbyB5b3UgY2FuIHBhc3MgaW4gYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIGl0XG4gICAqIGZpbmlzaGVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqL1xuICBUZXh0TWVzaC5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIHN5bmMgKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fbmVlZHNTeW5jKSB7XG4gICAgICB0aGlzLl9uZWVkc1N5bmMgPSBmYWxzZTtcblxuICAgICAgLy8gSWYgdGhlcmUncyBhbm90aGVyIHN5bmMgc3RpbGwgaW4gcHJvZ3Jlc3MsIHF1ZXVlXG4gICAgICBpZiAodGhpcy5faXNTeW5jaW5nKSB7XG4gICAgICAgICh0aGlzLl9xdWV1ZWRTeW5jcyB8fCAodGhpcy5fcXVldWVkU3luY3MgPSBbXSkpLnB1c2goY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNTeW5jaW5nID0gdHJ1ZTtcblxuICAgICAgICBnZXRUZXh0UmVuZGVySW5mbyh7XG4gICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgIGZvbnQ6IHRoaXMuZm9udCxcbiAgICAgICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSxcbiAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcsXG4gICAgICAgICAgbGluZUhlaWdodDogdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgIG1heFdpZHRoOiB0aGlzLm1heFdpZHRoLFxuICAgICAgICAgIHRleHRBbGlnbjogdGhpcy50ZXh0QWxpZ24sXG4gICAgICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgICAgIG92ZXJmbG93V3JhcDogdGhpcy5vdmVyZmxvd1dyYXAsXG4gICAgICAgICAgYW5jaG9yOiB0aGlzLmFuY2hvcixcbiAgICAgICAgICBpbmNsdWRlQ2FyZXRQb3NpdGlvbnM6IHRydWUgLy9UT0RPIHBhcmFtZXRlcml6ZVxuICAgICAgICB9LCBmdW5jdGlvbiAodGV4dFJlbmRlckluZm8pIHtcbiAgICAgICAgICB0aGlzJDEuX2lzU3luY2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gU2F2ZSByZXN1bHQgZm9yIGxhdGVyIHVzZSBpbiBvbkJlZm9yZVJlbmRlclxuICAgICAgICAgIHRoaXMkMS5fdGV4dFJlbmRlckluZm8gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgYXR0cmlidXRlc1xuICAgICAgICAgIHRoaXMkMS5nZW9tZXRyeS51cGRhdGVHbHlwaHModGV4dFJlbmRlckluZm8uZ2x5cGhCb3VuZHMsIHRleHRSZW5kZXJJbmZvLmdseXBoQXRsYXNJbmRpY2VzLCB0ZXh0UmVuZGVySW5mby50b3RhbEJvdW5kcyk7XG5cbiAgICAgICAgICAvLyBJZiB3ZSBoYWQgZXh0cmEgc3luYyByZXF1ZXN0cyBxdWV1ZWQgdXAsIGtpY2sgaXQgb2ZmXG4gICAgICAgICAgdmFyIHF1ZXVlZCA9IHRoaXMkMS5fcXVldWVkU3luY3M7XG4gICAgICAgICAgaWYgKHF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcyQxLl9xdWV1ZWRTeW5jcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzJDEuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzJDEuc3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHF1ZXVlZC5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4gJiYgZm4oKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgc3luYyBpZiBuZWVkZWQgLSBub3RlIGl0IHdvbid0IGNvbXBsZXRlIHVudGlsIG5leHQgZnJhbWUgYXQgdGhlXG4gICAqIGVhcmxpZXN0IHNvIGlmIHBvc3NpYmxlIGl0J3MgYSBnb29kIGlkZWEgdG8gY2FsbCBzeW5jKCkgbWFudWFsbHkgYXMgc29vbiBhc1xuICAgKiBhbGwgdGhlIHByb3BlcnRpZXMgaGF2ZSBiZWVuIHNldC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBUZXh0TWVzaC5wcm90b3R5cGUub25CZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiBvbkJlZm9yZVJlbmRlciAoKSB7XG4gICAgdGhpcy5zeW5jKCk7XG4gICAgdGhpcy5fcHJlcGFyZU1hdGVyaWFsKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IHRvIGRpc3Bvc2UgdGhlIGdlb21ldHJ5IHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAqIE5vdGU6IHdlIGRvbid0IGFsc28gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBoZXJlIGJlY2F1c2UgaWYgYW55dGhpbmcgZWxzZSBpc1xuICAgKiBzaGFyaW5nIHRoZSBzYW1lIGJhc2UgbWF0ZXJpYWwgaXQgd2lsbCByZXN1bHQgaW4gYSBwYXVzZSBuZXh0IGZyYW1lIGFzIHRoZSBwcm9ncmFtXG4gICAqIGlzIHJlY29tcGlsZWQuIEluc3RlYWQgdXNlcnMgY2FuIGRpc3Bvc2UgdGhlIGJhc2UgbWF0ZXJpYWwgbWFudWFsbHksIGxpa2Ugbm9ybWFsLFxuICAgKiBhbmQgd2UnbGwgYWxzbyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGF0IHRoYXQgdGltZS5cbiAgICovXG4gIFRleHRNZXNoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSAoKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7VHJvaWthVGV4dFJlbmRlckluZm98bnVsbH0gdGV4dFJlbmRlckluZm9cbiAgICogQHJlYWRvbmx5XG4gICAqIFRoZSBjdXJyZW50IHByb2Nlc3NlZCByZW5kZXJpbmcgZGF0YSBmb3IgdGhpcyBUZXh0TWVzaCwgcmV0dXJuZWQgYnkgdGhlIFRleHRCdWlsZGVyIGFmdGVyXG4gICAqIGEgYHN5bmMoKWAgY2FsbC4gVGhpcyB3aWxsIGJlIGBudWxsYCBpbml0aWFsbHksIGFuZCBtYXkgYmUgc3RhbGUgZm9yIGEgc2hvcnQgcGVyaW9kIHVudGlsXG4gICAqIHRoZSBhc3luY2hyb3VzIGBzeW5jKClgIHByb2Nlc3MgY29tcGxldGVzLlxuICAgKi9cbiAgcHJvdG90eXBlQWNjZXNzb3JzLnRleHRSZW5kZXJJbmZvLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dFJlbmRlckluZm8gfHwgbnVsbFxuICB9O1xuXG4gIC8vIEhhbmRsZXIgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgdGhlIGJhc2UgbWF0ZXJpYWwgd2l0aCBvdXIgdXBncmFkZXMuIFdlIGRvIHRoZSB3cmFwcGluZ1xuICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5tYXRlcmlhbC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbDtcbiAgICB2YXIgYmFzZU1hdGVyaWFsID0gdGhpcy5fYmFzZU1hdGVyaWFsIHx8IGRlZmF1bHRNYXRlcmlhbDtcbiAgICBpZiAoIWRlcml2ZWRNYXRlcmlhbCB8fCBkZXJpdmVkTWF0ZXJpYWwuYmFzZU1hdGVyaWFsICE9PSBiYXNlTWF0ZXJpYWwpIHtcbiAgICAgIGlmIChkZXJpdmVkTWF0ZXJpYWwpIHtcbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKTtcbiAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgIGJhc2VNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMubWF0ZXJpYWwuc2V0ID0gZnVuY3Rpb24gKGJhc2VNYXRlcmlhbCkge1xuICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5jdXN0b21EZXB0aE1hdGVyaWFsLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlTGF5b3V0VW5pZm9ybXModGhpcy5tYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKCkpXG4gIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5jdXN0b21EaXN0YW5jZU1hdGVyaWFsLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlTGF5b3V0VW5pZm9ybXModGhpcy5tYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKCkpXG4gIH07XG5cbiAgVGV4dE1lc2gucHJvdG90eXBlLl9wcmVwYXJlTWF0ZXJpYWwgPSBmdW5jdGlvbiBfcHJlcGFyZU1hdGVyaWFsICgpIHtcbiAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWw7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0VW5pZm9ybXMobWF0ZXJpYWwpO1xuXG4gICAgLy8gcHJlc2VudGF0aW9uIHVuaWZvcm1zOlxuICAgIHZhciB1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuICAgIHVuaWZvcm1zLnVUcm9pa2FTREZEZWJ1Zy52YWx1ZSA9ICEhdGhpcy5kZWJ1Z1NERjtcbiAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gISF0aGlzLmRlcHRoT2Zmc2V0O1xuICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgPSB0aGlzLmRlcHRoT2Zmc2V0IHx8IDA7XG5cbiAgICAvLyBzaG9ydGN1dCBmb3Igc2V0dGluZyBtYXRlcmlhbCBjb2xvciB2aWEgZmFjYWRlIHByb3A6XG4gICAgdmFyIGNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICBpZiAoY29sb3IgIT0gbnVsbCAmJiBtYXRlcmlhbC5jb2xvciAmJiBtYXRlcmlhbC5jb2xvci5pc0NvbG9yICYmIGNvbG9yICE9PSBtYXRlcmlhbC5fdHJvaWthQ29sb3IpIHtcbiAgICAgIG1hdGVyaWFsLmNvbG9yLnNldChtYXRlcmlhbC5fdHJvaWthQ29sb3IgPSBjb2xvcik7XG4gICAgfVxuICB9O1xuXG4gIFRleHRNZXNoLnByb3RvdHlwZS5fdXBkYXRlTGF5b3V0VW5pZm9ybXMgPSBmdW5jdGlvbiBfdXBkYXRlTGF5b3V0VW5pZm9ybXMgKG1hdGVyaWFsKSB7XG4gICAgdmFyIHRleHRJbmZvID0gdGhpcy50ZXh0UmVuZGVySW5mbztcbiAgICB2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcbiAgICBpZiAodGV4dEluZm8pIHtcbiAgICAgIHZhciBzZGZUZXh0dXJlID0gdGV4dEluZm8uc2RmVGV4dHVyZTtcbiAgICAgIHZhciB0b3RhbEJvdW5kcyA9IHRleHRJbmZvLnRvdGFsQm91bmRzO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmUudmFsdWUgPSBzZGZUZXh0dXJlO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmVTaXplLnZhbHVlLnNldChzZGZUZXh0dXJlLmltYWdlLndpZHRoLCBzZGZUZXh0dXJlLmltYWdlLmhlaWdodCk7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGR2x5cGhTaXplLnZhbHVlID0gdGV4dEluZm8uc2RmR2x5cGhTaXplO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERk1pbkRpc3RhbmNlUGN0LnZhbHVlID0gdGV4dEluZm8uc2RmTWluRGlzdGFuY2VQZXJjZW50O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVRvdGFsQm91bmRzLnZhbHVlLmZyb21BcnJheSh0b3RhbEJvdW5kcyk7XG5cbiAgICAgIHZhciBjbGlwUmVjdCA9IHRoaXMuY2xpcFJlY3Q7XG4gICAgICBpZiAoIShjbGlwUmVjdCAmJiBBcnJheS5pc0FycmF5KGNsaXBSZWN0KSAmJiBjbGlwUmVjdC5sZW5ndGggPT09IDQpKSB7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZS5mcm9tQXJyYXkodG90YWxCb3VuZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlLnNldChcbiAgICAgICAgICBNYXRoLm1heCh0b3RhbEJvdW5kc1swXSwgY2xpcFJlY3RbMF0pLFxuICAgICAgICAgIE1hdGgubWF4KHRvdGFsQm91bmRzWzFdLCBjbGlwUmVjdFsxXSksXG4gICAgICAgICAgTWF0aC5taW4odG90YWxCb3VuZHNbMl0sIGNsaXBSZWN0WzJdKSxcbiAgICAgICAgICBNYXRoLm1pbih0b3RhbEJvdW5kc1szXSwgY2xpcFJlY3RbM10pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRlcmlhbFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGUgQ3VzdG9tIHJheWNhc3RpbmcgdG8gdGVzdCBhZ2FpbnN0IHRoZSB3aG9sZSB0ZXh0IGJsb2NrJ3MgbWF4IHJlY3Rhbmd1bGFyIGJvdW5kc1xuICAgKiBUT0RPIGlzIHRoZXJlIGFueSByZWFzb24gdG8gbWFrZSB0aGlzIG1vcmUgZ3JhbnVsYXIsIGxpa2Ugd2l0aGluIGluZGl2aWR1YWwgbGluZSBvciBnbHlwaCByZWN0cz9cbiAgICovXG4gIFRleHRNZXNoLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gcmF5Y2FzdCAocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG4gICAgdmFyIHRleHRJbmZvID0gdGhpcy50ZXh0UmVuZGVySW5mbztcbiAgICBpZiAodGV4dEluZm8pIHtcbiAgICAgIHZhciBib3VuZHMgPSB0ZXh0SW5mby50b3RhbEJvdW5kcztcbiAgICAgIHJheWNhc3RNZXNoLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQsXG4gICAgICAgIHRlbXBNYXQ0LnNldChcbiAgICAgICAgICBib3VuZHNbMl0gLSBib3VuZHNbMF0sIDAsIDAsIGJvdW5kc1swXSxcbiAgICAgICAgICAwLCBib3VuZHNbM10gLSBib3VuZHNbMV0sIDAsIGJvdW5kc1sxXSxcbiAgICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAgIDAsIDAsIDAsIDFcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJheWNhc3RNZXNoLnJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKTtcbiAgICB9XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRleHRNZXNoLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIFRleHRNZXNoO1xufShNZXNoKSk7XG5cblxuLy8gQ3JlYXRlIHNldHRlcnMgZm9yIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGV4dCBsYXlvdXQ6XG52YXIgU1lOQ0FCTEVfUFJPUFMgPSBbXG4gICdmb250JyxcbiAgJ2ZvbnRTaXplJyxcbiAgJ2xldHRlclNwYWNpbmcnLFxuICAnbGluZUhlaWdodCcsXG4gICdtYXhXaWR0aCcsXG4gICdvdmVyZmxvd1dyYXAnLFxuICAndGV4dCcsXG4gICd0ZXh0QWxpZ24nLFxuICAnd2hpdGVTcGFjZScsXG4gICdhbmNob3InXG5dO1xuU1lOQ0FCTEVfUFJPUFMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICB2YXIgcHJpdmF0ZUtleSA9ICdfcHJpdmF0ZV8nICsgcHJvcDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHRNZXNoLnByb3RvdHlwZSwgcHJvcCwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpc1twcml2YXRlS2V5XVxuICAgIH0sXG4gICAgc2V0OiBwcm9wID09PSAnYW5jaG9yJ1xuICAgICAgPyBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkodmFsdWUpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzW3ByaXZhdGVLZXldKSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZUtleV0gPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLl9uZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpc1twcml2YXRlS2V5XSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZUtleV0gPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLl9uZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gIH0pO1xufSk7XG5cbmV4cG9ydCB7IEdseXBoc0dlb21ldHJ5LCBUZXh0TWVzaCwgY29uZmlndXJlVGV4dEJ1aWxkZXIsIGZvbnRQcm9jZXNzb3JXb3JrZXJNb2R1bGUgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/troika-3d-text/dist/textmesh-standalone.esm.js\n");

/***/ }),

/***/ "./node_modules/troika-three-utils/dist/troika-three-utils.umd.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.umd.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\")) :\n  undefined;\n}(this, (function (exports, three) { 'use strict';\n\n  /**\n   * Regular expression for matching the `void main() {` opener line in GLSL.\n   * @type {RegExp}\n   */\n  var voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n  /**\n   * Recursively expands all `#include <xyz>` statements within string of shader code.\n   * Copied from three's WebGLProgram#parseIncludes for external use.\n   *\n   * @param {string} source - The GLSL source code to evaluate\n   * @return {string} The GLSL code with all includes expanded\n   */\n  function expandShaderIncludes( source ) {\n    var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function replace(match, include) {\n      var chunk = three.ShaderChunk[include];\n      return chunk ? expandShaderIncludes(chunk) : match\n    }\n    return source.replace( pattern, replace )\n  }\n\n  // Local assign polyfill to avoid importing troika-core\n  var assign = Object.assign || function(/*target, ...sources*/) {\n    var arguments$1 = arguments;\n\n    var target = arguments[0];\n    for (var i = 1, len = arguments.length; i < len; i++) {\n      var source = arguments$1[i];\n      if (source) {\n        for (var prop in source) {\n          if (source.hasOwnProperty(prop)) {\n            target[prop] = source[prop];\n          }\n        }\n      }\n    }\n    return target\n  };\n\n\n  var idCtr = 0;\n  var epoch = Date.now();\n  var CACHE = new WeakMap(); //threejs requires WeakMap internally so should be safe to assume support\n\n\n  /**\n   * A utility for creating a custom shader material derived from another material's\n   * shaders. This allows you to inject custom shader logic and transforms into the\n   * builtin ThreeJS materials without having to recreate them from scratch.\n   *\n   * @param {THREE.Material} baseMaterial - the original material to derive from\n   *\n   * @param {Object} options - How the base material should be modified.\n   * @param {Object} options.defines - Custom `defines` for the material\n   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n   *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n   *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n   *        both shaders, and it will automatically be updated on each render frame with a number of\n   *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n   *        true calendar time.\n   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n   *        those attributes exposed by their normal names as read/write values.\n   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n   *        shader's `void main` function.\n   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n   *        output value. Will be injected after all other `void main` logic has executed.\n   *        TODO allow injecting before base shader logic or elsewhere?\n   *\n   * @return {THREE.Material}\n   *\n   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n   * which can be called to get a variant of the derived material for use in shadow casting. If the\n   * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n   * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n   * scenarios, e.g. skipping antialiasing or expensive shader logic.\n   */\n  function createDerivedMaterial(baseMaterial, options) {\n    // First check the cache to see if we've already derived from this baseMaterial using\n    // this unique set of options, and if so just return a clone instead of a new subclass\n    // which is faster and allows their shader program to be shared when rendering.\n    var optionsHash = getOptionsHash(options);\n    var cached = CACHE.get(baseMaterial);\n    if (!cached) {\n      cached = Object.create(null);\n      CACHE.set(baseMaterial, cached);\n    }\n    if (cached[optionsHash]) {\n      return cached[optionsHash].clone()\n    }\n\n    var id = ++idCtr;\n    var privateDerivedShadersProp = \"_derivedShaders\" + id;\n    var privateBeforeCompileProp = \"_onBeforeCompile\" + id;\n    var distanceMaterialTpl, depthMaterialTpl;\n\n    // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material's program\n    function onBeforeCompile(shaderInfo) {\n      baseMaterial.onBeforeCompile.call(this, shaderInfo);\n\n      // Upgrade the shaders, caching the result\n      var ref = this[privateDerivedShadersProp] || (this[privateDerivedShadersProp] = {vertex: {}, fragment: {}});\n      var vertex = ref.vertex;\n      var fragment = ref.fragment;\n      if (vertex.source !== shaderInfo.vertexShader || fragment.source !== shaderInfo.fragmentShader) {\n        var upgraded = upgradeShaders(shaderInfo, options, id);\n        vertex.source = shaderInfo.vertexShader;\n        vertex.result = upgraded.vertexShader;\n        fragment.source = shaderInfo.fragmentShader;\n        fragment.result = upgraded.fragmentShader;\n      }\n\n      // Inject upgraded shaders and uniforms into the program\n      shaderInfo.vertexShader = vertex.result;\n      shaderInfo.fragmentShader = fragment.result;\n      assign(shaderInfo.uniforms, this.uniforms);\n\n      // Inject auto-updating time uniform if requested\n      if (options.timeUniform) {\n        shaderInfo.uniforms[options.timeUniform] = {\n          get value() {return Date.now() - epoch}\n        };\n      }\n\n      // Users can still add their own handlers on top of ours\n      if (this[privateBeforeCompileProp]) {\n        this[privateBeforeCompileProp](shaderInfo);\n      }\n    }\n\n    function DerivedMaterial() {\n      baseMaterial.constructor.apply(this, arguments);\n      this._listeners = undefined; //don't inherit EventDispatcher listeners\n    }\n    DerivedMaterial.prototype = Object.create(baseMaterial, {\n      constructor: {value: DerivedMaterial},\n      isDerivedMaterial: {value: true},\n      baseMaterial: {value: baseMaterial},\n\n      onBeforeCompile: {\n        get: function get() {\n          return onBeforeCompile\n        },\n        set: function set(fn) {\n          this[privateBeforeCompileProp] = fn;\n        }\n      },\n\n      copy: {\n        value: function (source) {\n          baseMaterial.copy.call(this, source);\n          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n            this.extensions = assign({}, source.extensions);\n            this.defines = assign({}, source.defines);\n            this.uniforms = three.UniformsUtils.clone(source.uniforms);\n          }\n          return this\n        }\n      },\n\n      /**\n       * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDepthMaterial: {value: function() {\n        var depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          if (!depthMaterialTpl) {\n            depthMaterialTpl = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDepthMaterial()\n                : new three.MeshDepthMaterial({depthPacking: three.RGBADepthPacking}),\n              options\n            );\n            depthMaterialTpl.defines.IS_DEPTH_MATERIAL = '';\n          }\n          depthMaterial = this._depthMaterial = depthMaterialTpl.clone();\n        }\n        return depthMaterial\n      }},\n\n      /**\n       * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDistanceMaterial: {value: function() {\n        var distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          if (!distanceMaterialTpl) {\n            distanceMaterialTpl = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDistanceMaterial()\n                : new three.MeshDistanceMaterial(),\n              options\n            );\n            distanceMaterialTpl.defines.IS_DISTANCE_MATERIAL = '';\n          }\n          distanceMaterial = this._distanceMaterial = distanceMaterialTpl.clone();\n        }\n        return distanceMaterial\n      }},\n\n      dispose: {value: function value() {\n        var ref = this;\n        var _depthMaterial = ref._depthMaterial;\n        var _distanceMaterial = ref._distanceMaterial;\n        if (_depthMaterial) { _depthMaterial.dispose(); }\n        if (_distanceMaterial) { _distanceMaterial.dispose(); }\n        baseMaterial.dispose.call(this);\n      }}\n    });\n\n    var material = new DerivedMaterial();\n    material.copy(baseMaterial);\n\n    // Merge uniforms, defines, and extensions\n    material.uniforms = assign(three.UniformsUtils.clone(baseMaterial.uniforms || {}), options.uniforms);\n    material.defines = assign({}, baseMaterial.defines, options.defines);\n    material.defines.TROIKA_DERIVED_MATERIAL = id; //force a program change from the base material\n    material.extensions = assign({}, baseMaterial.extensions, options.extensions);\n\n    cached[optionsHash] = material;\n    return material.clone() //return a clone so changes made to it don't affect the cached object\n  }\n\n\n  function upgradeShaders(ref, options, id) {\n    var vertexShader = ref.vertexShader;\n    var fragmentShader = ref.fragmentShader;\n\n    var vertexDefs = options.vertexDefs;\n    var vertexMainIntro = options.vertexMainIntro;\n    var vertexTransform = options.vertexTransform;\n    var fragmentDefs = options.fragmentDefs;\n    var fragmentMainIntro = options.fragmentMainIntro;\n    var fragmentColorTransform = options.fragmentColorTransform;\n    var timeUniform = options.timeUniform;\n\n    // Inject auto-updating time uniform if requested\n    if (timeUniform) {\n      var code = \"\\nuniform float \" + timeUniform + \";\\n\";\n      vertexDefs = (vertexDefs || '') + code;\n      fragmentDefs = (fragmentDefs || '') + code;\n    }\n\n    // Modify vertex shader\n    if (vertexDefs || vertexMainIntro || vertexTransform) {\n      // If there's a position transform, we need to:\n      // - expand all include statements\n      // - replace all usages of the `position` attribute with a mutable variable\n      // - inject the transform code into a function and call it to transform the position\n      if (vertexTransform) {\n        vertexShader = expandShaderIncludes(vertexShader);\n        vertexDefs = (vertexDefs || '') + \"\\nvoid troikaVertexTransform\" + id + \"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  \" + vertexTransform + \"\\n}\\n\";\n        vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, function (match, match1, index, fullStr) {\n          return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : (\"troika_\" + match1 + \"_\" + id)\n        });\n        vertexMainIntro = \"\\nvec3 troika_position_\" + id + \" = vec3(position);\\nvec3 troika_normal_\" + id + \" = vec3(normal);\\nvec2 troika_uv_\" + id + \" = vec2(uv);\\ntroikaVertexTransform\" + id + \"(troika_position_\" + id + \", troika_normal_\" + id + \", troika_uv_\" + id + \");\\n\" + (vertexMainIntro || '') + \"\\n\";\n      }\n\n      vertexShader = vertexShader.replace(\n        voidMainRegExp,\n        ((vertexDefs || '') + \"\\n\\n$&\\n\\n\" + (vertexMainIntro || '')));\n    }\n\n    // Modify fragment shader\n    if (fragmentDefs || fragmentMainIntro || fragmentColorTransform) {\n      fragmentShader = expandShaderIncludes(fragmentShader);\n      fragmentShader = fragmentShader.replace(voidMainRegExp, (\"\\n\" + (fragmentDefs || '') + \"\\nvoid troikaOrigMain\" + id + \"() {\\n\" + (fragmentMainIntro || '') + \"\\n\"));\n      fragmentShader += \"\\nvoid main() {\\n  troikaOrigMain\" + id + \"();\\n  \" + (fragmentColorTransform || '') + \"\\n}\";\n    }\n\n    return {\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    }\n  }\n\n\n  function getOptionsHash(options) {\n    return JSON.stringify(options, optionsJsonReplacer)\n  }\n  function optionsJsonReplacer(key, value) {\n    return key === 'uniforms' ? undefined : value\n  }\n\n  // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n  // TODO how can we keep this from getting stale?\n  var MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'phong',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite'\n  };\n\n  /**\n   * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n   * used to render that material.\n   *\n   * @param material - the Material instance\n   * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n   */\n  function getShadersForMaterial(material) {\n    var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n  }\n\n  /**\n   * Find all uniforms and their types within a shader code string.\n   *\n   * @param {string} shader - The shader code to parse\n   * @return {object} mapping of uniform names to their glsl type\n   */\n  function getShaderUniformTypes(shader) {\n    var uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n    var uniforms = Object.create(null);\n    var match;\n    while ((match = uniformRE.exec(shader)) !== null) {\n      uniforms[match[2]] = match[1];\n    }\n    return uniforms\n  }\n\n  /**\n   * @class ShaderFloatArray\n   *\n   * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\n   * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\n   * because:\n   *\n   *   - GLSL \"array\" uniforms can only be of a constant length.\n   *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\n   *     extension is available.\n   *\n   * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\n   * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms\n   * and GLSL code for you to put in your custom shader to query the float values by array index.\n   *\n   * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\n   * only allow texture lookups in fragment shaders.\n   *\n   * TODO:\n   *   - Use a float texture if the extension is available so we can skip the encoding process\n   */\n  var ShaderFloatArray = function ShaderFloatArray(name) {\n    this.name = name;\n    this.textureUniform = \"dataTex_\" + name;\n    this.textureSizeUniform = \"dataTexSize_\" + name;\n    this.multiplierUniform = \"dataMultiplier_\" + name;\n\n    /**\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\n     * length of the data array.\n     * @type {string}\n     */\n    this.dataSizeUniform = \"dataSize_\" + name;\n\n    /**\n     * @property readFunction - the name of the GLSL function that should be called to\n     * read data out of the array by index.\n     * @type {string}\n     */\n    this.readFunction = \"readData_\" + name;\n\n    this._raw = new Float32Array(0);\n    this._texture = new three.DataTexture(new Uint8Array(0), 0, 1);\n    this._length = 0;\n    this._multiplier = 1;\n  };\n\n  var prototypeAccessors = { length: { configurable: true } };\n\n  /**\n   * @property length - the current length of the data array\n   * @type {number}\n   */\n  prototypeAccessors.length.set = function (value) {\n    if (value !== this._length) {\n      // Find nearest power-of-2 that holds the new length\n      var size = Math.pow(2, Math.ceil(Math.log2(value)));\n      var raw = this._raw;\n      if (size < raw.length) {\n        this._raw = raw.subarray(0, size);\n      }\n      else if(size > raw.length) {\n        this._raw = new Float32Array(size);\n        this._raw.set(raw);\n      }\n      this._length = value;\n    }\n  };\n  prototypeAccessors.length.get = function () {\n    return this._length\n  };\n\n  /**\n   * Add a value to the end of the data array\n   * @param {number} value\n   */\n  ShaderFloatArray.prototype.push = function push (value) {\n    return this.set(this.length++, value)\n  };\n\n  /**\n   * Replace the existing data with that from a new array\n   * @param {ArrayLike<number>} array\n   */\n  ShaderFloatArray.prototype.setArray = function setArray (array) {\n    this.length = array.length;\n    this._raw.set(array);\n    this._needsRepack = true;\n  };\n\n  /**\n   * Get the current value at index\n   * @param {number} index\n   * @return {number}\n   */\n  ShaderFloatArray.prototype.get = function get (index) {\n    return this._raw[index]\n  };\n\n  ShaderFloatArray.prototype.set = function set (index, value) {\n    if (index + 1 > this._length) {\n      this.length = index + 1;\n    }\n    if (value !== this._raw[index]) {\n      this._raw[index] = value;\n      encodeFloatToFourInts(\n        value / this._multiplier,\n        this._texture.image.data,\n        index * 4\n      );\n      this._needsMultCheck = true;\n    }\n  };\n\n  /**\n   * Make a copy of this ShaderFloatArray\n   * @return {ShaderFloatArray}\n   */\n  ShaderFloatArray.prototype.clone = function clone () {\n    var clone = new ShaderFloatArray(this.name);\n    clone.setArray(this._raw);\n    return clone\n  };\n\n  /**\n   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\n   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\n   * @return {Object}\n   */\n  ShaderFloatArray.prototype.getShaderUniforms = function getShaderUniforms () {\n      var obj;\n\n    var me = this;\n    return ( obj = {}, obj[this.textureUniform] = {get value() {\n        me._sync();\n        return me._texture\n      }}, obj[this.textureSizeUniform] = {get value() {\n        me._sync();\n        return me._texture.image.width\n      }}, obj[this.dataSizeUniform] = {get value() {\n        me._sync();\n        return me.length\n      }}, obj[this.multiplierUniform] = {get value() {\n        me._sync();\n        return me._multiplier\n      }}, obj )\n  };\n\n  /**\n   * Retrieve the GLSL code that must be injected into the shader's definitions area to\n   * enable reading from the data array. This exposes a function with a name matching\n   * the {@link #readFunction} property, which other shader code can call to read values\n   * from the array by their index.\n   * @return {string}\n   */\n  ShaderFloatArray.prototype.getShaderHeaderCode = function getShaderHeaderCode () {\n    var ref = this;\n      var textureUniform = ref.textureUniform;\n      var textureSizeUniform = ref.textureSizeUniform;\n      var dataSizeUniform = ref.dataSizeUniform;\n      var multiplierUniform = ref.multiplierUniform;\n      var readFunction = ref.readFunction;\n    return (\"\\nuniform sampler2D \" + textureUniform + \";\\nuniform float \" + textureSizeUniform + \";\\nuniform float \" + dataSizeUniform + \";\\nuniform float \" + multiplierUniform + \";\\n\\nfloat \" + readFunction + \"(float index) {\\n  vec2 texUV = vec2((index + 0.5) / \" + textureSizeUniform + \", 0.5);\\n  vec4 pixel = texture2D(\" + textureUniform + \", texUV);\\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * \" + multiplierUniform + \";\\n}\\n\")\n  };\n\n  /**\n   * @private Synchronize any pending changes to the underlying DataTexture\n   */\n  ShaderFloatArray.prototype._sync = function _sync () {\n    var tex = this._texture;\n    var raw = this._raw;\n    var needsRepack = this._needsRepack;\n\n    // If the size of the raw array changed, resize the texture to match\n    if (raw.length !== tex.image.width) {\n      tex.image = {\n        data: new Uint8Array(raw.length * 4),\n        width: raw.length,\n        height: 1\n      };\n      needsRepack = true;\n    }\n\n    // If the values changed, check the multiplier. This should be a value by which\n    // all the values are divided to constrain them to the [0,1] range required by\n    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\n    // maximum value for greatest accuracy.\n    if (needsRepack || this._needsMultCheck) {\n      var maxVal = this._raw.reduce(function (a, b) { return Math.max(a, b); }, 0);\n      var mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\n      if (mult !== this._multiplier) {\n        this._multiplier = mult;\n        needsRepack = true;\n      }\n      tex.needsUpdate = true;\n      this._needsMultCheck = false;\n    }\n\n    // If things changed in a way we need to repack, do so\n    if (needsRepack) {\n      for (var i = 0, len = raw.length, mult$1 = this._multiplier; i < len; i++) {\n        encodeFloatToFourInts(raw[i] / mult$1, tex.image.data, i * 4);\n      }\n      this._needsRepack = false;\n    }\n  };\n\n  Object.defineProperties( ShaderFloatArray.prototype, prototypeAccessors );\n\n\n\n  /**\n   * Encode a floating point number into a set of four 8-bit integers.\n   * Also see the companion decoder function #decodeFloatFromFourInts.\n   *\n   * This is adapted to JavaScript from the basic approach at\n   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n   * but writes out integers in the range 0-255 instead of floats in the range 0-1\n   * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\n   *\n   * Some precision will necessarily be lost during the encoding and decoding process.\n   * Testing shows that the maximum precision error is ~1.18e-10 which should be good\n   * enough for most cases.\n   *\n   * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\n   *        otherwise the results will be incorrect.\n   * @param {Array|Uint8Array} array - an array into which the four ints should be written\n   * @param {Number} startIndex - index in the output array at which to start writing the ints\n   * @return {Array|Uint8Array}\n   */\n  function encodeFloatToFourInts(value, array, startIndex) {\n    // This is adapted to JS from the basic approach at\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    // but writes to a Uint8Array instead of floats. Input values must be in\n    // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\n    var enc0 = 255 * value;\n    var enc1 = 255 * (enc0 % 1);\n    var enc2 = 255 * (enc1 % 1);\n    var enc3 = 255 * (enc2 % 1);\n\n    enc0 = enc0 & 255;\n    enc1 = enc1 & 255;\n    enc2 = enc2 & 255;\n    enc3 = Math.round(enc3) & 255;\n\n    array[startIndex] = enc0;\n    array[startIndex + 1] = enc1;\n    array[startIndex + 2] = enc2;\n    array[startIndex + 3] = enc3;\n    return array\n  }\n\n  /*\n  Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,\n  divided into a reasonable number of height segments.\n  */\n\n  var vertexDefs = \"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\";\n\n  var vertexTransform = \"\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \\\"sideways\\\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won't see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n\";\n\n  var fragmentDefs = \"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\";\n\n  var fragmentMainIntro = \"\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n\";\n\n  // Debugging: separate color for each of the 6 sides:\n  // const fragmentColorTransform = `\n  // float sideNum = floor(vUV.x * 6.0);\n  // vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n  //   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n  //   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n  //   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n  //   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n  //   vec3(1.0, 0.0, 1.0);\n  // gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n  // `\n\n\n\n  function createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(\n      baseMaterial,\n      {\n        uniforms: {\n          pointA: {value: new three.Vector3()},\n          controlA: {value: new three.Vector3()},\n          controlB: {value: new three.Vector3()},\n          pointB: {value: new three.Vector3()},\n          radius: {value: 0.01},\n          dashing: {value: new three.Vector3()} //on, off, offset\n        },\n        vertexDefs: vertexDefs,\n        vertexTransform: vertexTransform,\n        fragmentDefs: fragmentDefs,\n        fragmentMainIntro: fragmentMainIntro\n      }\n    )\n  }\n\n  var geometry = null;\n\n  var defaultBaseMaterial = new three.MeshStandardMaterial({color: 0xffffff, side: three.DoubleSide});\n\n\n  /**\n   * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n   * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n   * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n   * automatically.\n   *\n   * The cubiz bezier path is determined by its four `Vector3` properties:\n   * - `pointA`\n   * - `controlA`\n   * - `controlB`\n   * - `pointB`\n   *\n   * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n   *\n   * You can also give the tube a dashed appearance with two properties:\n   *\n   * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n   *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n   *   used as input to the cubic bezier function, not its visible length.)\n   * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n   *\n   * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n   * thicker tubes.\n   *\n   * TODO: proper geometry bounding sphere and raycasting\n   * TODO: allow control of the geometry's segment counts\n   */\n  var BezierMesh = /*@__PURE__*/(function (Mesh) {\n    function BezierMesh() {\n      Mesh.call(\n        this, geometry || (geometry =\n          new three.CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n        ),\n        defaultBaseMaterial\n      );\n\n      this.pointA = new three.Vector3();\n      this.controlA = new three.Vector3();\n      this.controlB = new three.Vector3();\n      this.pointB = new three.Vector3();\n      this.radius = 0.01;\n      this.dashArray = new three.Vector2();\n      this.dashOffset = 0;\n\n      // TODO - disabling frustum culling until I figure out how to customize the\n      //  geometry's bounding sphere that gets used\n      this.frustumCulled = false;\n    }\n\n    if ( Mesh ) BezierMesh.__proto__ = Mesh;\n    BezierMesh.prototype = Object.create( Mesh && Mesh.prototype );\n    BezierMesh.prototype.constructor = BezierMesh;\n\n    var prototypeAccessors = { material: { configurable: true },customDepthMaterial: { configurable: true },customDistanceMaterial: { configurable: true } };\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    prototypeAccessors.material.get = function () {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || defaultBaseMaterial;\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        if (derivedMaterial) {\n          derivedMaterial.dispose();\n        }\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial\n    };\n    prototypeAccessors.material.set = function (baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    };\n\n    // Create and update material for shadows upon request:\n    prototypeAccessors.customDepthMaterial.get = function () {\n      return this._updateBezierUniforms(this.material.getDepthMaterial())\n    };\n    prototypeAccessors.customDistanceMaterial.get = function () {\n      return this._updateBezierUniforms(this.material.getDistanceMaterial())\n    };\n\n    BezierMesh.prototype.onBeforeRender = function onBeforeRender (shaderInfo) {\n      this._updateBezierUniforms(this.material);\n    };\n\n    BezierMesh.prototype._updateBezierUniforms = function _updateBezierUniforms (material) {\n      var uniforms = material.uniforms;\n      var ref = this;\n      var pointA = ref.pointA;\n      var controlA = ref.controlA;\n      var controlB = ref.controlB;\n      var pointB = ref.pointB;\n      var radius = ref.radius;\n      var dashArray = ref.dashArray;\n      var dashOffset = ref.dashOffset;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n      return material\n    };\n\n    BezierMesh.prototype.raycast = function raycast (raycaster, intersects) {\n      // TODO - just fail for now\n    };\n\n    Object.defineProperties( BezierMesh.prototype, prototypeAccessors );\n\n    return BezierMesh;\n  }(three.Mesh));\n\n  exports.BezierMesh = BezierMesh;\n  exports.ShaderFloatArray = ShaderFloatArray;\n  exports.createDerivedMaterial = createDerivedMaterial;\n  exports.expandShaderIncludes = expandShaderIncludes;\n  exports.getShaderUniformTypes = getShaderUniformTypes;\n  exports.getShadersForMaterial = getShadersForMaterial;\n  exports.voidMainRegExp = voidMainRegExp;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLnVtZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdXRpbHMvZGlzdC90cm9pa2EtdGhyZWUtdXRpbHMudW1kLmpzP2UwZWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCd0aHJlZScpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAndGhyZWUnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnRyb2lrYV90aHJlZV91dGlscyA9IHt9LCBnbG9iYWwuVEhSRUUpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCB0aHJlZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgdGhlIGB2b2lkIG1haW4oKSB7YCBvcGVuZXIgbGluZSBpbiBHTFNMLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgdmFyIHZvaWRNYWluUmVnRXhwID0gL1xcYnZvaWRcXHMrbWFpblxccypcXChcXHMqXFwpXFxzKnsvZztcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgZXhwYW5kcyBhbGwgYCNpbmNsdWRlIDx4eXo+YCBzdGF0ZW1lbnRzIHdpdGhpbiBzdHJpbmcgb2Ygc2hhZGVyIGNvZGUuXG4gICAqIENvcGllZCBmcm9tIHRocmVlJ3MgV2ViR0xQcm9ncmFtI3BhcnNlSW5jbHVkZXMgZm9yIGV4dGVybmFsIHVzZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBHTFNMIHNvdXJjZSBjb2RlIHRvIGV2YWx1YXRlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdMU0wgY29kZSB3aXRoIGFsbCBpbmNsdWRlcyBleHBhbmRlZFxuICAgKi9cbiAgZnVuY3Rpb24gZXhwYW5kU2hhZGVySW5jbHVkZXMoIHNvdXJjZSApIHtcbiAgICB2YXIgcGF0dGVybiA9IC9eWyBcXHRdKiNpbmNsdWRlICs8KFtcXHdcXGQuL10rKT4vZ207XG4gICAgZnVuY3Rpb24gcmVwbGFjZShtYXRjaCwgaW5jbHVkZSkge1xuICAgICAgdmFyIGNodW5rID0gdGhyZWUuU2hhZGVyQ2h1bmtbaW5jbHVkZV07XG4gICAgICByZXR1cm4gY2h1bmsgPyBleHBhbmRTaGFkZXJJbmNsdWRlcyhjaHVuaykgOiBtYXRjaFxuICAgIH1cbiAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2UgKVxuICB9XG5cbiAgLy8gTG9jYWwgYXNzaWduIHBvbHlmaWxsIHRvIGF2b2lkIGltcG9ydGluZyB0cm9pa2EtY29yZVxuICB2YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbigvKnRhcmdldCwgLi4uc291cmNlcyovKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzJDFbaV07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH07XG5cblxuICB2YXIgaWRDdHIgPSAwO1xuICB2YXIgZXBvY2ggPSBEYXRlLm5vdygpO1xuICB2YXIgQ0FDSEUgPSBuZXcgV2Vha01hcCgpOyAvL3RocmVlanMgcmVxdWlyZXMgV2Vha01hcCBpbnRlcm5hbGx5IHNvIHNob3VsZCBiZSBzYWZlIHRvIGFzc3VtZSBzdXBwb3J0XG5cblxuICAvKipcbiAgICogQSB1dGlsaXR5IGZvciBjcmVhdGluZyBhIGN1c3RvbSBzaGFkZXIgbWF0ZXJpYWwgZGVyaXZlZCBmcm9tIGFub3RoZXIgbWF0ZXJpYWwnc1xuICAgKiBzaGFkZXJzLiBUaGlzIGFsbG93cyB5b3UgdG8gaW5qZWN0IGN1c3RvbSBzaGFkZXIgbG9naWMgYW5kIHRyYW5zZm9ybXMgaW50byB0aGVcbiAgICogYnVpbHRpbiBUaHJlZUpTIG1hdGVyaWFscyB3aXRob3V0IGhhdmluZyB0byByZWNyZWF0ZSB0aGVtIGZyb20gc2NyYXRjaC5cbiAgICpcbiAgICogQHBhcmFtIHtUSFJFRS5NYXRlcmlhbH0gYmFzZU1hdGVyaWFsIC0gdGhlIG9yaWdpbmFsIG1hdGVyaWFsIHRvIGRlcml2ZSBmcm9tXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gSG93IHRoZSBiYXNlIG1hdGVyaWFsIHNob3VsZCBiZSBtb2RpZmllZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGVmaW5lcyAtIEN1c3RvbSBgZGVmaW5lc2AgZm9yIHRoZSBtYXRlcmlhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5leHRlbnNpb25zIC0gQ3VzdG9tIGBleHRlbnNpb25zYCBmb3IgdGhlIG1hdGVyaWFsLCBlLmcuIGB7ZGVyaXZhdGl2ZXM6IHRydWV9YFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy51bmlmb3JtcyAtIEN1c3RvbSBgdW5pZm9ybXNgIGZvciB1c2UgaW4gdGhlIG1vZGlmaWVkIHNoYWRlci4gVGhlc2UgY2FuXG4gICAqICAgICAgICBiZSBhY2Nlc3NlZCBhbmQgbWFuaXB1bGF0ZWQgdmlhIHRoZSByZXN1bHRpbmcgbWF0ZXJpYWwncyBgdW5pZm9ybXNgIHByb3BlcnR5LCBqdXN0IGxpa2VcbiAgICogICAgICAgIGluIGEgU2hhZGVyTWF0ZXJpYWwuIFlvdSBkbyBub3QgbmVlZCB0byByZXBlYXQgdGhlIGJhc2UgbWF0ZXJpYWwncyBvd24gdW5pZm9ybXMgaGVyZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltZVVuaWZvcm0gLSBJZiBzcGVjaWZpZWQsIGEgdW5pZm9ybSBvZiB0aGlzIG5hbWUgd2lsbCBiZSBpbmplY3RlZCBpbnRvXG4gICAqICAgICAgICBib3RoIHNoYWRlcnMsIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgdXBkYXRlZCBvbiBlYWNoIHJlbmRlciBmcmFtZSB3aXRoIGEgbnVtYmVyIG9mXG4gICAqICAgICAgICBlbGFwc2VkIG1pbGxpc2Vjb25kcy4gVGhlIFwiemVyb1wiIGVwb2NoIHRpbWUgaXMgbm90IHNpZ25pZmljYW50IHNvIGRvbid0IHJlbHkgb24gdGhpcyBhcyBhXG4gICAqICAgICAgICB0cnVlIGNhbGVuZGFyIHRpbWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleERlZnMgLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBpbnRvIHRoZSB2ZXJ0ZXggc2hhZGVyJ3MgdG9wLWxldmVsXG4gICAqICAgICAgICBkZWZpbml0aW9ucywgYWJvdmUgdGhlIGB2b2lkIG1haW4oKWAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleE1haW5JbnRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSB0b3Agb2YgdGhlIHZlcnRleFxuICAgKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleFRyYW5zZm9ybSAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gbWFuaXB1bGF0ZSB0aGUgYHBvc2l0aW9uYCwgYG5vcm1hbGAsXG4gICAqICAgICAgICBhbmQvb3IgYHV2YCB2ZXJ0ZXggYXR0cmlidXRlcy4gVGhpcyBjb2RlIHdpbGwgYmUgd3JhcHBlZCB3aXRoaW4gYSBzdGFuZGFsb25lIGZ1bmN0aW9uIHdpdGhcbiAgICogICAgICAgIHRob3NlIGF0dHJpYnV0ZXMgZXhwb3NlZCBieSB0aGVpciBub3JtYWwgbmFtZXMgYXMgcmVhZC93cml0ZSB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50RGVmcyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGludG8gdGhlIGZyYWdtZW50IHNoYWRlcidzIHRvcC1sZXZlbFxuICAgKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudE1haW5JbnRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSB0b3Agb2YgdGhlIGZyYWdtZW50XG4gICAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnRDb2xvclRyYW5zZm9ybSAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gbWFuaXB1bGF0ZSB0aGUgYGdsX0ZyYWdDb2xvcmBcbiAgICogICAgICAgIG91dHB1dCB2YWx1ZS4gV2lsbCBiZSBpbmplY3RlZCBhZnRlciBhbGwgb3RoZXIgYHZvaWQgbWFpbmAgbG9naWMgaGFzIGV4ZWN1dGVkLlxuICAgKiAgICAgICAgVE9ETyBhbGxvdyBpbmplY3RpbmcgYmVmb3JlIGJhc2Ugc2hhZGVyIGxvZ2ljIG9yIGVsc2V3aGVyZT9cbiAgICpcbiAgICogQHJldHVybiB7VEhSRUUuTWF0ZXJpYWx9XG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBtYXRlcmlhbCB3aWxsIGFsc28gaGF2ZSB0d28gbmV3IG1ldGhvZHMsIGBnZXREZXB0aE1hdGVyaWFsKClgIGFuZCBgZ2V0RGlzdGFuY2VNYXRlcmlhbCgpYCxcbiAgICogd2hpY2ggY2FuIGJlIGNhbGxlZCB0byBnZXQgYSB2YXJpYW50IG9mIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGZvciB1c2UgaW4gc2hhZG93IGNhc3RpbmcuIElmIHRoZVxuICAgKiB0YXJnZXQgbWVzaCBpcyBleHBlY3RlZCB0byBjYXN0IHNoYWRvd3MsIHRoZW4geW91IGNhbiBhc3NpZ24gdGhlc2UgdG8gdGhlIG1lc2gncyBgY3VzdG9tRGVwdGhNYXRlcmlhbGBcbiAgICogKGZvciBkaXJlY3Rpb25hbCBhbmQgc3BvdCBsaWdodHMpIGFuZC9vciBgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbGAgKGZvciBwb2ludCBsaWdodHMpIHByb3BlcnRpZXMgdG9cbiAgICogYWxsb3cgdGhlIGNhc3Qgc2hhZG93IHRvIGhvbm9yIHlvdXIgZGVyaXZlZCBzaGFkZXIncyB2ZXJ0ZXggdHJhbnNmb3JtcyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy4gVGhlc2VcbiAgICogd2lsbCBhbHNvIHNldCBhIGN1c3RvbSBgI2RlZmluZSBJU19ERVBUSF9NQVRFUklBTGAgb3IgYCNkZWZpbmUgSVNfRElTVEFOQ0VfTUFURVJJQUxgIHRoYXQgeW91IGNhbiBsb29rXG4gICAqIGZvciBpbiB5b3VyIGRlcml2ZWQgc2hhZGVycyB3aXRoIGAjaWZkZWZgIHRvIGN1c3RvbWl6ZSB0aGVpciBiZWhhdmlvciBmb3IgdGhlIGRlcHRoIG9yIGRpc3RhbmNlXG4gICAqIHNjZW5hcmlvcywgZS5nLiBza2lwcGluZyBhbnRpYWxpYXNpbmcgb3IgZXhwZW5zaXZlIHNoYWRlciBsb2dpYy5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIG9wdGlvbnMpIHtcbiAgICAvLyBGaXJzdCBjaGVjayB0aGUgY2FjaGUgdG8gc2VlIGlmIHdlJ3ZlIGFscmVhZHkgZGVyaXZlZCBmcm9tIHRoaXMgYmFzZU1hdGVyaWFsIHVzaW5nXG4gICAgLy8gdGhpcyB1bmlxdWUgc2V0IG9mIG9wdGlvbnMsIGFuZCBpZiBzbyBqdXN0IHJldHVybiBhIGNsb25lIGluc3RlYWQgb2YgYSBuZXcgc3ViY2xhc3NcbiAgICAvLyB3aGljaCBpcyBmYXN0ZXIgYW5kIGFsbG93cyB0aGVpciBzaGFkZXIgcHJvZ3JhbSB0byBiZSBzaGFyZWQgd2hlbiByZW5kZXJpbmcuXG4gICAgdmFyIG9wdGlvbnNIYXNoID0gZ2V0T3B0aW9uc0hhc2gob3B0aW9ucyk7XG4gICAgdmFyIGNhY2hlZCA9IENBQ0hFLmdldChiYXNlTWF0ZXJpYWwpO1xuICAgIGlmICghY2FjaGVkKSB7XG4gICAgICBjYWNoZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgQ0FDSEUuc2V0KGJhc2VNYXRlcmlhbCwgY2FjaGVkKTtcbiAgICB9XG4gICAgaWYgKGNhY2hlZFtvcHRpb25zSGFzaF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRbb3B0aW9uc0hhc2hdLmNsb25lKClcbiAgICB9XG5cbiAgICB2YXIgaWQgPSArK2lkQ3RyO1xuICAgIHZhciBwcml2YXRlRGVyaXZlZFNoYWRlcnNQcm9wID0gXCJfZGVyaXZlZFNoYWRlcnNcIiArIGlkO1xuICAgIHZhciBwcml2YXRlQmVmb3JlQ29tcGlsZVByb3AgPSBcIl9vbkJlZm9yZUNvbXBpbGVcIiArIGlkO1xuICAgIHZhciBkaXN0YW5jZU1hdGVyaWFsVHBsLCBkZXB0aE1hdGVyaWFsVHBsO1xuXG4gICAgLy8gUHJpdmF0ZSBvbkJlZm9yZUNvbXBpbGUgaGFuZGxlciB0aGF0IGluamVjdHMgdGhlIG1vZGlmaWVkIHNoYWRlcnMgYW5kIHVuaWZvcm1zIHdoZW5cbiAgICAvLyB0aGUgcmVuZGVyZXIgc3dpdGNoZXMgdG8gdGhpcyBtYXRlcmlhbCdzIHByb2dyYW1cbiAgICBmdW5jdGlvbiBvbkJlZm9yZUNvbXBpbGUoc2hhZGVySW5mbykge1xuICAgICAgYmFzZU1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZS5jYWxsKHRoaXMsIHNoYWRlckluZm8pO1xuXG4gICAgICAvLyBVcGdyYWRlIHRoZSBzaGFkZXJzLCBjYWNoaW5nIHRoZSByZXN1bHRcbiAgICAgIHZhciByZWYgPSB0aGlzW3ByaXZhdGVEZXJpdmVkU2hhZGVyc1Byb3BdIHx8ICh0aGlzW3ByaXZhdGVEZXJpdmVkU2hhZGVyc1Byb3BdID0ge3ZlcnRleDoge30sIGZyYWdtZW50OiB7fX0pO1xuICAgICAgdmFyIHZlcnRleCA9IHJlZi52ZXJ0ZXg7XG4gICAgICB2YXIgZnJhZ21lbnQgPSByZWYuZnJhZ21lbnQ7XG4gICAgICBpZiAodmVydGV4LnNvdXJjZSAhPT0gc2hhZGVySW5mby52ZXJ0ZXhTaGFkZXIgfHwgZnJhZ21lbnQuc291cmNlICE9PSBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyKSB7XG4gICAgICAgIHZhciB1cGdyYWRlZCA9IHVwZ3JhZGVTaGFkZXJzKHNoYWRlckluZm8sIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgdmVydGV4LnNvdXJjZSA9IHNoYWRlckluZm8udmVydGV4U2hhZGVyO1xuICAgICAgICB2ZXJ0ZXgucmVzdWx0ID0gdXBncmFkZWQudmVydGV4U2hhZGVyO1xuICAgICAgICBmcmFnbWVudC5zb3VyY2UgPSBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBmcmFnbWVudC5yZXN1bHQgPSB1cGdyYWRlZC5mcmFnbWVudFNoYWRlcjtcbiAgICAgIH1cblxuICAgICAgLy8gSW5qZWN0IHVwZ3JhZGVkIHNoYWRlcnMgYW5kIHVuaWZvcm1zIGludG8gdGhlIHByb2dyYW1cbiAgICAgIHNoYWRlckluZm8udmVydGV4U2hhZGVyID0gdmVydGV4LnJlc3VsdDtcbiAgICAgIHNoYWRlckluZm8uZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudC5yZXN1bHQ7XG4gICAgICBhc3NpZ24oc2hhZGVySW5mby51bmlmb3JtcywgdGhpcy51bmlmb3Jtcyk7XG5cbiAgICAgIC8vIEluamVjdCBhdXRvLXVwZGF0aW5nIHRpbWUgdW5pZm9ybSBpZiByZXF1ZXN0ZWRcbiAgICAgIGlmIChvcHRpb25zLnRpbWVVbmlmb3JtKSB7XG4gICAgICAgIHNoYWRlckluZm8udW5pZm9ybXNbb3B0aW9ucy50aW1lVW5pZm9ybV0gPSB7XG4gICAgICAgICAgZ2V0IHZhbHVlKCkge3JldHVybiBEYXRlLm5vdygpIC0gZXBvY2h9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXJzIGNhbiBzdGlsbCBhZGQgdGhlaXIgb3duIGhhbmRsZXJzIG9uIHRvcCBvZiBvdXJzXG4gICAgICBpZiAodGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdKSB7XG4gICAgICAgIHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXShzaGFkZXJJbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEZXJpdmVkTWF0ZXJpYWwoKSB7XG4gICAgICBiYXNlTWF0ZXJpYWwuY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHVuZGVmaW5lZDsgLy9kb24ndCBpbmhlcml0IEV2ZW50RGlzcGF0Y2hlciBsaXN0ZW5lcnNcbiAgICB9XG4gICAgRGVyaXZlZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZU1hdGVyaWFsLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBEZXJpdmVkTWF0ZXJpYWx9LFxuICAgICAgaXNEZXJpdmVkTWF0ZXJpYWw6IHt2YWx1ZTogdHJ1ZX0sXG4gICAgICBiYXNlTWF0ZXJpYWw6IHt2YWx1ZTogYmFzZU1hdGVyaWFsfSxcblxuICAgICAgb25CZWZvcmVDb21waWxlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBvbkJlZm9yZUNvbXBpbGVcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZm4pIHtcbiAgICAgICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0gPSBmbjtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY29weToge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgIGJhc2VNYXRlcmlhbC5jb3B5LmNhbGwodGhpcywgc291cmNlKTtcbiAgICAgICAgICBpZiAoIWJhc2VNYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmICFiYXNlTWF0ZXJpYWwuaXNEZXJpdmVkTWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGFzc2lnbih7fSwgc291cmNlLmV4dGVuc2lvbnMpO1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVzID0gYXNzaWduKHt9LCBzb3VyY2UuZGVmaW5lcyk7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zID0gdGhyZWUuVW5pZm9ybXNVdGlscy5jbG9uZShzb3VyY2UudW5pZm9ybXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERlcHRoTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAgICogdHJhbnNmb3JtYXRpb25zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLlxuICAgICAgICovXG4gICAgICBnZXREZXB0aE1hdGVyaWFsOiB7dmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVwdGhNYXRlcmlhbCA9IHRoaXMuX2RlcHRoTWF0ZXJpYWw7XG4gICAgICAgIGlmICghZGVwdGhNYXRlcmlhbCkge1xuICAgICAgICAgIGlmICghZGVwdGhNYXRlcmlhbFRwbCkge1xuICAgICAgICAgICAgZGVwdGhNYXRlcmlhbFRwbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgICAgYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsXG4gICAgICAgICAgICAgICAgPyBiYXNlTWF0ZXJpYWwuZ2V0RGVwdGhNYXRlcmlhbCgpXG4gICAgICAgICAgICAgICAgOiBuZXcgdGhyZWUuTWVzaERlcHRoTWF0ZXJpYWwoe2RlcHRoUGFja2luZzogdGhyZWUuUkdCQURlcHRoUGFja2luZ30pLFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVwdGhNYXRlcmlhbFRwbC5kZWZpbmVzLklTX0RFUFRIX01BVEVSSUFMID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsID0gZGVwdGhNYXRlcmlhbFRwbC5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXB0aE1hdGVyaWFsXG4gICAgICB9fSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVdGlsaXR5IHRvIGdldCBhIE1lc2hEaXN0YW5jZU1hdGVyaWFsIHRoYXQgd2lsbCBob25vciB0aGlzIGRlcml2ZWQgbWF0ZXJpYWwncyB2ZXJ0ZXhcbiAgICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgICAqL1xuICAgICAgZ2V0RGlzdGFuY2VNYXRlcmlhbDoge3ZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRpc3RhbmNlTWF0ZXJpYWwpIHtcbiAgICAgICAgICBpZiAoIWRpc3RhbmNlTWF0ZXJpYWxUcGwpIHtcbiAgICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWxUcGwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoXG4gICAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICAgIDogbmV3IHRocmVlLk1lc2hEaXN0YW5jZU1hdGVyaWFsKCksXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsVHBsLmRlZmluZXMuSVNfRElTVEFOQ0VfTUFURVJJQUwgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbCA9IHRoaXMuX2Rpc3RhbmNlTWF0ZXJpYWwgPSBkaXN0YW5jZU1hdGVyaWFsVHBsLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlTWF0ZXJpYWxcbiAgICAgIH19LFxuXG4gICAgICBkaXNwb3NlOiB7dmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIF9kZXB0aE1hdGVyaWFsID0gcmVmLl9kZXB0aE1hdGVyaWFsO1xuICAgICAgICB2YXIgX2Rpc3RhbmNlTWF0ZXJpYWwgPSByZWYuX2Rpc3RhbmNlTWF0ZXJpYWw7XG4gICAgICAgIGlmIChfZGVwdGhNYXRlcmlhbCkgeyBfZGVwdGhNYXRlcmlhbC5kaXNwb3NlKCk7IH1cbiAgICAgICAgaWYgKF9kaXN0YW5jZU1hdGVyaWFsKSB7IF9kaXN0YW5jZU1hdGVyaWFsLmRpc3Bvc2UoKTsgfVxuICAgICAgICBiYXNlTWF0ZXJpYWwuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgfX1cbiAgICB9KTtcblxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBEZXJpdmVkTWF0ZXJpYWwoKTtcbiAgICBtYXRlcmlhbC5jb3B5KGJhc2VNYXRlcmlhbCk7XG5cbiAgICAvLyBNZXJnZSB1bmlmb3JtcywgZGVmaW5lcywgYW5kIGV4dGVuc2lvbnNcbiAgICBtYXRlcmlhbC51bmlmb3JtcyA9IGFzc2lnbih0aHJlZS5Vbmlmb3Jtc1V0aWxzLmNsb25lKGJhc2VNYXRlcmlhbC51bmlmb3JtcyB8fCB7fSksIG9wdGlvbnMudW5pZm9ybXMpO1xuICAgIG1hdGVyaWFsLmRlZmluZXMgPSBhc3NpZ24oe30sIGJhc2VNYXRlcmlhbC5kZWZpbmVzLCBvcHRpb25zLmRlZmluZXMpO1xuICAgIG1hdGVyaWFsLmRlZmluZXMuVFJPSUtBX0RFUklWRURfTUFURVJJQUwgPSBpZDsgLy9mb3JjZSBhIHByb2dyYW0gY2hhbmdlIGZyb20gdGhlIGJhc2UgbWF0ZXJpYWxcbiAgICBtYXRlcmlhbC5leHRlbnNpb25zID0gYXNzaWduKHt9LCBiYXNlTWF0ZXJpYWwuZXh0ZW5zaW9ucywgb3B0aW9ucy5leHRlbnNpb25zKTtcblxuICAgIGNhY2hlZFtvcHRpb25zSGFzaF0gPSBtYXRlcmlhbDtcbiAgICByZXR1cm4gbWF0ZXJpYWwuY2xvbmUoKSAvL3JldHVybiBhIGNsb25lIHNvIGNoYW5nZXMgbWFkZSB0byBpdCBkb24ndCBhZmZlY3QgdGhlIGNhY2hlZCBvYmplY3RcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdXBncmFkZVNoYWRlcnMocmVmLCBvcHRpb25zLCBpZCkge1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSByZWYudmVydGV4U2hhZGVyO1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHJlZi5mcmFnbWVudFNoYWRlcjtcblxuICAgIHZhciB2ZXJ0ZXhEZWZzID0gb3B0aW9ucy52ZXJ0ZXhEZWZzO1xuICAgIHZhciB2ZXJ0ZXhNYWluSW50cm8gPSBvcHRpb25zLnZlcnRleE1haW5JbnRybztcbiAgICB2YXIgdmVydGV4VHJhbnNmb3JtID0gb3B0aW9ucy52ZXJ0ZXhUcmFuc2Zvcm07XG4gICAgdmFyIGZyYWdtZW50RGVmcyA9IG9wdGlvbnMuZnJhZ21lbnREZWZzO1xuICAgIHZhciBmcmFnbWVudE1haW5JbnRybyA9IG9wdGlvbnMuZnJhZ21lbnRNYWluSW50cm87XG4gICAgdmFyIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gPSBvcHRpb25zLmZyYWdtZW50Q29sb3JUcmFuc2Zvcm07XG4gICAgdmFyIHRpbWVVbmlmb3JtID0gb3B0aW9ucy50aW1lVW5pZm9ybTtcblxuICAgIC8vIEluamVjdCBhdXRvLXVwZGF0aW5nIHRpbWUgdW5pZm9ybSBpZiByZXF1ZXN0ZWRcbiAgICBpZiAodGltZVVuaWZvcm0pIHtcbiAgICAgIHZhciBjb2RlID0gXCJcXG51bmlmb3JtIGZsb2F0IFwiICsgdGltZVVuaWZvcm0gKyBcIjtcXG5cIjtcbiAgICAgIHZlcnRleERlZnMgPSAodmVydGV4RGVmcyB8fCAnJykgKyBjb2RlO1xuICAgICAgZnJhZ21lbnREZWZzID0gKGZyYWdtZW50RGVmcyB8fCAnJykgKyBjb2RlO1xuICAgIH1cblxuICAgIC8vIE1vZGlmeSB2ZXJ0ZXggc2hhZGVyXG4gICAgaWYgKHZlcnRleERlZnMgfHwgdmVydGV4TWFpbkludHJvIHx8IHZlcnRleFRyYW5zZm9ybSkge1xuICAgICAgLy8gSWYgdGhlcmUncyBhIHBvc2l0aW9uIHRyYW5zZm9ybSwgd2UgbmVlZCB0bzpcbiAgICAgIC8vIC0gZXhwYW5kIGFsbCBpbmNsdWRlIHN0YXRlbWVudHNcbiAgICAgIC8vIC0gcmVwbGFjZSBhbGwgdXNhZ2VzIG9mIHRoZSBgcG9zaXRpb25gIGF0dHJpYnV0ZSB3aXRoIGEgbXV0YWJsZSB2YXJpYWJsZVxuICAgICAgLy8gLSBpbmplY3QgdGhlIHRyYW5zZm9ybSBjb2RlIGludG8gYSBmdW5jdGlvbiBhbmQgY2FsbCBpdCB0byB0cmFuc2Zvcm0gdGhlIHBvc2l0aW9uXG4gICAgICBpZiAodmVydGV4VHJhbnNmb3JtKSB7XG4gICAgICAgIHZlcnRleFNoYWRlciA9IGV4cGFuZFNoYWRlckluY2x1ZGVzKHZlcnRleFNoYWRlcik7XG4gICAgICAgIHZlcnRleERlZnMgPSAodmVydGV4RGVmcyB8fCAnJykgKyBcIlxcbnZvaWQgdHJvaWthVmVydGV4VHJhbnNmb3JtXCIgKyBpZCArIFwiKGlub3V0IHZlYzMgcG9zaXRpb24sIGlub3V0IHZlYzMgbm9ybWFsLCBpbm91dCB2ZWMyIHV2KSB7XFxuICBcIiArIHZlcnRleFRyYW5zZm9ybSArIFwiXFxufVxcblwiO1xuICAgICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxiKHBvc2l0aW9ufG5vcm1hbHx1dilcXGIvZywgZnVuY3Rpb24gKG1hdGNoLCBtYXRjaDEsIGluZGV4LCBmdWxsU3RyKSB7XG4gICAgICAgICAgcmV0dXJuIC9cXGJhdHRyaWJ1dGVcXHMrdmVjWzIzXVxccyskLy50ZXN0KGZ1bGxTdHIuc3Vic3RyKDAsIGluZGV4KSkgPyBtYXRjaDEgOiAoXCJ0cm9pa2FfXCIgKyBtYXRjaDEgKyBcIl9cIiArIGlkKVxuICAgICAgICB9KTtcbiAgICAgICAgdmVydGV4TWFpbkludHJvID0gXCJcXG52ZWMzIHRyb2lrYV9wb3NpdGlvbl9cIiArIGlkICsgXCIgPSB2ZWMzKHBvc2l0aW9uKTtcXG52ZWMzIHRyb2lrYV9ub3JtYWxfXCIgKyBpZCArIFwiID0gdmVjMyhub3JtYWwpO1xcbnZlYzIgdHJvaWthX3V2X1wiICsgaWQgKyBcIiA9IHZlYzIodXYpO1xcbnRyb2lrYVZlcnRleFRyYW5zZm9ybVwiICsgaWQgKyBcIih0cm9pa2FfcG9zaXRpb25fXCIgKyBpZCArIFwiLCB0cm9pa2Ffbm9ybWFsX1wiICsgaWQgKyBcIiwgdHJvaWthX3V2X1wiICsgaWQgKyBcIik7XFxuXCIgKyAodmVydGV4TWFpbkludHJvIHx8ICcnKSArIFwiXFxuXCI7XG4gICAgICB9XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKFxuICAgICAgICB2b2lkTWFpblJlZ0V4cCxcbiAgICAgICAgKCh2ZXJ0ZXhEZWZzIHx8ICcnKSArIFwiXFxuXFxuJCZcXG5cXG5cIiArICh2ZXJ0ZXhNYWluSW50cm8gfHwgJycpKSk7XG4gICAgfVxuXG4gICAgLy8gTW9kaWZ5IGZyYWdtZW50IHNoYWRlclxuICAgIGlmIChmcmFnbWVudERlZnMgfHwgZnJhZ21lbnRNYWluSW50cm8gfHwgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSkge1xuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBleHBhbmRTaGFkZXJJbmNsdWRlcyhmcmFnbWVudFNoYWRlcik7XG4gICAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2Uodm9pZE1haW5SZWdFeHAsIChcIlxcblwiICsgKGZyYWdtZW50RGVmcyB8fCAnJykgKyBcIlxcbnZvaWQgdHJvaWthT3JpZ01haW5cIiArIGlkICsgXCIoKSB7XFxuXCIgKyAoZnJhZ21lbnRNYWluSW50cm8gfHwgJycpICsgXCJcXG5cIikpO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gXCJcXG52b2lkIG1haW4oKSB7XFxuICB0cm9pa2FPcmlnTWFpblwiICsgaWQgKyBcIigpO1xcbiAgXCIgKyAoZnJhZ21lbnRDb2xvclRyYW5zZm9ybSB8fCAnJykgKyBcIlxcbn1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmVydGV4U2hhZGVyOiB2ZXJ0ZXhTaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnRTaGFkZXJcbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnNIYXNoKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgb3B0aW9uc0pzb25SZXBsYWNlcilcbiAgfVxuICBmdW5jdGlvbiBvcHRpb25zSnNvblJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ga2V5ID09PSAndW5pZm9ybXMnID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgfVxuXG4gIC8vIENvcGllZCBmcm9tIHRocmVlanMgV2ViR0xQcm9ncmFtcy5qcyBzbyB3ZSBjYW4gcmVzb2x2ZSBidWlsdGluIG1hdGVyaWFscyB0byB0aGVpciBzaGFkZXJzXG4gIC8vIFRPRE8gaG93IGNhbiB3ZSBrZWVwIHRoaXMgZnJvbSBnZXR0aW5nIHN0YWxlP1xuICB2YXIgTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSUyA9IHtcbiAgICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgICBNZXNoRGlzdGFuY2VNYXRlcmlhbDogJ2Rpc3RhbmNlUkdCQScsXG4gICAgTWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcbiAgICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgICBNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXG4gICAgTWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG4gICAgTWVzaFRvb25NYXRlcmlhbDogJ3Bob25nJyxcbiAgICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgICBNZXNoUGh5c2ljYWxNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgICBNZXNoTWF0Y2FwTWF0ZXJpYWw6ICdtYXRjYXAnLFxuICAgIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICAgIExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXG4gICAgUG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnLFxuICAgIFNoYWRvd01hdGVyaWFsOiAnc2hhZG93JyxcbiAgICBTcHJpdGVNYXRlcmlhbDogJ3Nwcml0ZSdcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBUaHJlZS5qcyBgTWF0ZXJpYWxgIGluc3RhbmNlLCBmaW5kIHRoZSBzaGFkZXJzL3VuaWZvcm1zIHRoYXQgd2lsbCBiZVxuICAgKiB1c2VkIHRvIHJlbmRlciB0aGF0IG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0gbWF0ZXJpYWwgLSB0aGUgTWF0ZXJpYWwgaW5zdGFuY2VcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIHRoZSBtYXRlcmlhbCdzIHNoYWRlciBpbmZvOiBge3VuaWZvcm1zOnt9LCBmcmFnbWVudFNoYWRlcjonJywgdmVydGV4U2hhZGVyOicnfWBcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNoYWRlcnNGb3JNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgIHZhciBidWlsdGluVHlwZSA9IE1BVEVSSUFMX1RZUEVTX1RPX1NIQURFUlNbbWF0ZXJpYWwudHlwZV07XG4gICAgcmV0dXJuIGJ1aWx0aW5UeXBlID8gdGhyZWUuU2hhZGVyTGliW2J1aWx0aW5UeXBlXSA6IG1hdGVyaWFsIC8vVE9ETyBmYWxsYmFjayBmb3IgdW5rbm93biB0eXBlP1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIHVuaWZvcm1zIGFuZCB0aGVpciB0eXBlcyB3aXRoaW4gYSBzaGFkZXIgY29kZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXIgLSBUaGUgc2hhZGVyIGNvZGUgdG8gcGFyc2VcbiAgICogQHJldHVybiB7b2JqZWN0fSBtYXBwaW5nIG9mIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgZ2xzbCB0eXBlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTaGFkZXJVbmlmb3JtVHlwZXMoc2hhZGVyKSB7XG4gICAgdmFyIHVuaWZvcm1SRSA9IC9cXGJ1bmlmb3JtXFxzKyhpbnR8ZmxvYXR8dmVjWzIzNF0pXFxzKyhbQS1aYS16X11bXFx3XSopL2c7XG4gICAgdmFyIHVuaWZvcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IHVuaWZvcm1SRS5leGVjKHNoYWRlcikpICE9PSBudWxsKSB7XG4gICAgICB1bmlmb3Jtc1ttYXRjaFsyXV0gPSBtYXRjaFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaWZvcm1zXG4gIH1cblxuICAvKipcbiAgICogQGNsYXNzIFNoYWRlckZsb2F0QXJyYXlcbiAgICpcbiAgICogV2hlbiB3cml0aW5nIGEgY3VzdG9tIFdlYkdMIHNoYWRlciwgc29tZXRpbWVzIHlvdSBuZWVkIHRvIHBhc3MgaXQgYW4gYXJyYXkgb2YgZmxvYXRpbmdcbiAgICogcG9pbnQgbnVtYmVycyB0aGF0IGl0IGNhbiByZWFkIGZyb20uIFVuZm9ydHVuYXRlbHkgdGhpcyBpcyB2ZXJ5IGRpZmZpY3VsdCB0byBkbyBpbiBXZWJHTCxcbiAgICogYmVjYXVzZTpcbiAgICpcbiAgICogICAtIEdMU0wgXCJhcnJheVwiIHVuaWZvcm1zIGNhbiBvbmx5IGJlIG9mIGEgY29uc3RhbnQgbGVuZ3RoLlxuICAgKiAgIC0gVGV4dHVyZXMgY2FuIG9ubHkgaG9sZCBmbG9hdGluZyBwb2ludCBudW1iZXJzIGluIFdlYkdMMSBpZiB0aGUgYE9FU190ZXh0dXJlX2Zsb2F0YFxuICAgKiAgICAgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogU2hhZGVyRmxvYXRBcnJheSBpcyBhbiBhcnJheS1saWtlIGFic3RyYWN0aW9uIHRoYXQgZW5jb2RlcyBpdHMgZmxvYXRpbmcgcG9pbnQgZGF0YSBpbnRvXG4gICAqIGFuIFJHQkEgdGV4dHVyZSdzIGZvdXIgVWludDggY29tcG9uZW50cywgYW5kIHByb3ZpZGVzIHRoZSBjb3JyZXNwb25kaW5nIFRocmVlSlMgdW5pZm9ybXNcbiAgICogYW5kIEdMU0wgY29kZSBmb3IgeW91IHRvIHB1dCBpbiB5b3VyIGN1c3RvbSBzaGFkZXIgdG8gcXVlcnkgdGhlIGZsb2F0IHZhbHVlcyBieSBhcnJheSBpbmRleC5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG9ubHkgYmUgdXNlZCB3aXRoaW4gYSBmcmFnbWVudCBzaGFkZXIsIGFzIHNvbWUgZW52aXJvbm1lbnRzIChlLmcuIGlPUylcbiAgICogb25seSBhbGxvdyB0ZXh0dXJlIGxvb2t1cHMgaW4gZnJhZ21lbnQgc2hhZGVycy5cbiAgICpcbiAgICogVE9ETzpcbiAgICogICAtIFVzZSBhIGZsb2F0IHRleHR1cmUgaWYgdGhlIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUgc28gd2UgY2FuIHNraXAgdGhlIGVuY29kaW5nIHByb2Nlc3NcbiAgICovXG4gIHZhciBTaGFkZXJGbG9hdEFycmF5ID0gZnVuY3Rpb24gU2hhZGVyRmxvYXRBcnJheShuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnRleHR1cmVVbmlmb3JtID0gXCJkYXRhVGV4X1wiICsgbmFtZTtcbiAgICB0aGlzLnRleHR1cmVTaXplVW5pZm9ybSA9IFwiZGF0YVRleFNpemVfXCIgKyBuYW1lO1xuICAgIHRoaXMubXVsdGlwbGllclVuaWZvcm0gPSBcImRhdGFNdWx0aXBsaWVyX1wiICsgbmFtZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBkYXRhU2l6ZVVuaWZvcm0gLSB0aGUgbmFtZSBvZiB0aGUgR0xTTCB1bmlmb3JtIHRoYXQgd2lsbCBob2xkIHRoZVxuICAgICAqIGxlbmd0aCBvZiB0aGUgZGF0YSBhcnJheS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZGF0YVNpemVVbmlmb3JtID0gXCJkYXRhU2l6ZV9cIiArIG5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgcmVhZEZ1bmN0aW9uIC0gdGhlIG5hbWUgb2YgdGhlIEdMU0wgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHRvXG4gICAgICogcmVhZCBkYXRhIG91dCBvZiB0aGUgYXJyYXkgYnkgaW5kZXguXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlYWRGdW5jdGlvbiA9IFwicmVhZERhdGFfXCIgKyBuYW1lO1xuXG4gICAgdGhpcy5fcmF3ID0gbmV3IEZsb2F0MzJBcnJheSgwKTtcbiAgICB0aGlzLl90ZXh0dXJlID0gbmV3IHRocmVlLkRhdGFUZXh0dXJlKG5ldyBVaW50OEFycmF5KDApLCAwLCAxKTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX211bHRpcGxpZXIgPSAxO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGxlbmd0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgbGVuZ3RoIC0gdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBkYXRhIGFycmF5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBwcm90b3R5cGVBY2Nlc3NvcnMubGVuZ3RoLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAvLyBGaW5kIG5lYXJlc3QgcG93ZXItb2YtMiB0aGF0IGhvbGRzIHRoZSBuZXcgbGVuZ3RoXG4gICAgICB2YXIgc2l6ZSA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIodmFsdWUpKSk7XG4gICAgICB2YXIgcmF3ID0gdGhpcy5fcmF3O1xuICAgICAgaWYgKHNpemUgPCByYXcubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3JhdyA9IHJhdy5zdWJhcnJheSgwLCBzaXplKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoc2l6ZSA+IHJhdy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmF3ID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgdGhpcy5fcmF3LnNldChyYXcpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMubGVuZ3RoLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoXG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHZhbHVlIHRvIHRoZSBlbmQgb2YgdGhlIGRhdGEgYXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqL1xuICBTaGFkZXJGbG9hdEFycmF5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQodGhpcy5sZW5ndGgrKywgdmFsdWUpXG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGV4aXN0aW5nIGRhdGEgd2l0aCB0aGF0IGZyb20gYSBuZXcgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheUxpa2U8bnVtYmVyPn0gYXJyYXlcbiAgICovXG4gIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLnNldEFycmF5ID0gZnVuY3Rpb24gc2V0QXJyYXkgKGFycmF5KSB7XG4gICAgdGhpcy5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgdGhpcy5fcmF3LnNldChhcnJheSk7XG4gICAgdGhpcy5fbmVlZHNSZXBhY2sgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgYXQgaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3W2luZGV4XVxuICB9O1xuXG4gIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaW5kZXgsIHZhbHVlKSB7XG4gICAgaWYgKGluZGV4ICsgMSA+IHRoaXMuX2xlbmd0aCkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbmRleCArIDE7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcmF3W2luZGV4XSkge1xuICAgICAgdGhpcy5fcmF3W2luZGV4XSA9IHZhbHVlO1xuICAgICAgZW5jb2RlRmxvYXRUb0ZvdXJJbnRzKFxuICAgICAgICB2YWx1ZSAvIHRoaXMuX211bHRpcGxpZXIsXG4gICAgICAgIHRoaXMuX3RleHR1cmUuaW1hZ2UuZGF0YSxcbiAgICAgICAgaW5kZXggKiA0XG4gICAgICApO1xuICAgICAgdGhpcy5fbmVlZHNNdWx0Q2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIGNvcHkgb2YgdGhpcyBTaGFkZXJGbG9hdEFycmF5XG4gICAqIEByZXR1cm4ge1NoYWRlckZsb2F0QXJyYXl9XG4gICAqL1xuICBTaGFkZXJGbG9hdEFycmF5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgU2hhZGVyRmxvYXRBcnJheSh0aGlzLm5hbWUpO1xuICAgIGNsb25lLnNldEFycmF5KHRoaXMuX3Jhdyk7XG4gICAgcmV0dXJuIGNsb25lXG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBzZXQgb2YgVW5pZm9ybXMgdGhhdCBtdXN0IHRvIGJlIGFkZGVkIHRvIHRoZSB0YXJnZXQgU2hhZGVyTWF0ZXJpYWwgb3JcbiAgICogRGVyaXZlZE1hdGVyaWFsLCB0byBmZWVkIHRoZSBHTFNMIGNvZGUgZ2VuZXJhdGVkIGJ5IHtAbGluayAjZ2V0U2hhZGVySGVhZGVyQ29kZX0uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLmdldFNoYWRlclVuaWZvcm1zID0gZnVuY3Rpb24gZ2V0U2hhZGVyVW5pZm9ybXMgKCkge1xuICAgICAgdmFyIG9iajtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgcmV0dXJuICggb2JqID0ge30sIG9ialt0aGlzLnRleHR1cmVVbmlmb3JtXSA9IHtnZXQgdmFsdWUoKSB7XG4gICAgICAgIG1lLl9zeW5jKCk7XG4gICAgICAgIHJldHVybiBtZS5fdGV4dHVyZVxuICAgICAgfX0sIG9ialt0aGlzLnRleHR1cmVTaXplVW5pZm9ybV0gPSB7Z2V0IHZhbHVlKCkge1xuICAgICAgICBtZS5fc3luYygpO1xuICAgICAgICByZXR1cm4gbWUuX3RleHR1cmUuaW1hZ2Uud2lkdGhcbiAgICAgIH19LCBvYmpbdGhpcy5kYXRhU2l6ZVVuaWZvcm1dID0ge2dldCB2YWx1ZSgpIHtcbiAgICAgICAgbWUuX3N5bmMoKTtcbiAgICAgICAgcmV0dXJuIG1lLmxlbmd0aFxuICAgICAgfX0sIG9ialt0aGlzLm11bHRpcGxpZXJVbmlmb3JtXSA9IHtnZXQgdmFsdWUoKSB7XG4gICAgICAgIG1lLl9zeW5jKCk7XG4gICAgICAgIHJldHVybiBtZS5fbXVsdGlwbGllclxuICAgICAgfX0sIG9iaiApXG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBHTFNMIGNvZGUgdGhhdCBtdXN0IGJlIGluamVjdGVkIGludG8gdGhlIHNoYWRlcidzIGRlZmluaXRpb25zIGFyZWEgdG9cbiAgICogZW5hYmxlIHJlYWRpbmcgZnJvbSB0aGUgZGF0YSBhcnJheS4gVGhpcyBleHBvc2VzIGEgZnVuY3Rpb24gd2l0aCBhIG5hbWUgbWF0Y2hpbmdcbiAgICogdGhlIHtAbGluayAjcmVhZEZ1bmN0aW9ufSBwcm9wZXJ0eSwgd2hpY2ggb3RoZXIgc2hhZGVyIGNvZGUgY2FuIGNhbGwgdG8gcmVhZCB2YWx1ZXNcbiAgICogZnJvbSB0aGUgYXJyYXkgYnkgdGhlaXIgaW5kZXguXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLmdldFNoYWRlckhlYWRlckNvZGUgPSBmdW5jdGlvbiBnZXRTaGFkZXJIZWFkZXJDb2RlICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciB0ZXh0dXJlVW5pZm9ybSA9IHJlZi50ZXh0dXJlVW5pZm9ybTtcbiAgICAgIHZhciB0ZXh0dXJlU2l6ZVVuaWZvcm0gPSByZWYudGV4dHVyZVNpemVVbmlmb3JtO1xuICAgICAgdmFyIGRhdGFTaXplVW5pZm9ybSA9IHJlZi5kYXRhU2l6ZVVuaWZvcm07XG4gICAgICB2YXIgbXVsdGlwbGllclVuaWZvcm0gPSByZWYubXVsdGlwbGllclVuaWZvcm07XG4gICAgICB2YXIgcmVhZEZ1bmN0aW9uID0gcmVmLnJlYWRGdW5jdGlvbjtcbiAgICByZXR1cm4gKFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgXCIgKyB0ZXh0dXJlVW5pZm9ybSArIFwiO1xcbnVuaWZvcm0gZmxvYXQgXCIgKyB0ZXh0dXJlU2l6ZVVuaWZvcm0gKyBcIjtcXG51bmlmb3JtIGZsb2F0IFwiICsgZGF0YVNpemVVbmlmb3JtICsgXCI7XFxudW5pZm9ybSBmbG9hdCBcIiArIG11bHRpcGxpZXJVbmlmb3JtICsgXCI7XFxuXFxuZmxvYXQgXCIgKyByZWFkRnVuY3Rpb24gKyBcIihmbG9hdCBpbmRleCkge1xcbiAgdmVjMiB0ZXhVViA9IHZlYzIoKGluZGV4ICsgMC41KSAvIFwiICsgdGV4dHVyZVNpemVVbmlmb3JtICsgXCIsIDAuNSk7XFxuICB2ZWM0IHBpeGVsID0gdGV4dHVyZTJEKFwiICsgdGV4dHVyZVVuaWZvcm0gKyBcIiwgdGV4VVYpO1xcbiAgcmV0dXJuIGRvdChwaXhlbCwgMS4wIC8gdmVjNCgxLjAsIDI1NS4wLCA2NTAyNS4wLCAxNjU4MTM3NS4wKSkgKiBcIiArIG11bHRpcGxpZXJVbmlmb3JtICsgXCI7XFxufVxcblwiKVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBTeW5jaHJvbml6ZSBhbnkgcGVuZGluZyBjaGFuZ2VzIHRvIHRoZSB1bmRlcmx5aW5nIERhdGFUZXh0dXJlXG4gICAqL1xuICBTaGFkZXJGbG9hdEFycmF5LnByb3RvdHlwZS5fc3luYyA9IGZ1bmN0aW9uIF9zeW5jICgpIHtcbiAgICB2YXIgdGV4ID0gdGhpcy5fdGV4dHVyZTtcbiAgICB2YXIgcmF3ID0gdGhpcy5fcmF3O1xuICAgIHZhciBuZWVkc1JlcGFjayA9IHRoaXMuX25lZWRzUmVwYWNrO1xuXG4gICAgLy8gSWYgdGhlIHNpemUgb2YgdGhlIHJhdyBhcnJheSBjaGFuZ2VkLCByZXNpemUgdGhlIHRleHR1cmUgdG8gbWF0Y2hcbiAgICBpZiAocmF3Lmxlbmd0aCAhPT0gdGV4LmltYWdlLndpZHRoKSB7XG4gICAgICB0ZXguaW1hZ2UgPSB7XG4gICAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KHJhdy5sZW5ndGggKiA0KSxcbiAgICAgICAgd2lkdGg6IHJhdy5sZW5ndGgsXG4gICAgICAgIGhlaWdodDogMVxuICAgICAgfTtcbiAgICAgIG5lZWRzUmVwYWNrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWVzIGNoYW5nZWQsIGNoZWNrIHRoZSBtdWx0aXBsaWVyLiBUaGlzIHNob3VsZCBiZSBhIHZhbHVlIGJ5IHdoaWNoXG4gICAgLy8gYWxsIHRoZSB2YWx1ZXMgYXJlIGRpdmlkZWQgdG8gY29uc3RyYWluIHRoZW0gdG8gdGhlIFswLDFdIHJhbmdlIHJlcXVpcmVkIGJ5XG4gICAgLy8gdGhlIFVpbnQ4IHBhY2tpbmcgYWxnb3JpdGhtLiBXZSBwaWNrIHRoZSBuZWFyZXN0IHBvd2VyIG9mIDIgdGhhdCBob2xkcyB0aGVcbiAgICAvLyBtYXhpbXVtIHZhbHVlIGZvciBncmVhdGVzdCBhY2N1cmFjeS5cbiAgICBpZiAobmVlZHNSZXBhY2sgfHwgdGhpcy5fbmVlZHNNdWx0Q2hlY2spIHtcbiAgICAgIHZhciBtYXhWYWwgPSB0aGlzLl9yYXcucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLm1heChhLCBiKTsgfSwgMCk7XG4gICAgICB2YXIgbXVsdCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobWF4VmFsKSkpO1xuICAgICAgaWYgKG11bHQgIT09IHRoaXMuX211bHRpcGxpZXIpIHtcbiAgICAgICAgdGhpcy5fbXVsdGlwbGllciA9IG11bHQ7XG4gICAgICAgIG5lZWRzUmVwYWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRleC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLl9uZWVkc011bHRDaGVjayA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoaW5ncyBjaGFuZ2VkIGluIGEgd2F5IHdlIG5lZWQgdG8gcmVwYWNrLCBkbyBzb1xuICAgIGlmIChuZWVkc1JlcGFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhdy5sZW5ndGgsIG11bHQkMSA9IHRoaXMuX211bHRpcGxpZXI7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbmNvZGVGbG9hdFRvRm91ckludHMocmF3W2ldIC8gbXVsdCQxLCB0ZXguaW1hZ2UuZGF0YSwgaSAqIDQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbmVlZHNSZXBhY2sgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuXG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIGZsb2F0aW5nIHBvaW50IG51bWJlciBpbnRvIGEgc2V0IG9mIGZvdXIgOC1iaXQgaW50ZWdlcnMuXG4gICAqIEFsc28gc2VlIHRoZSBjb21wYW5pb24gZGVjb2RlciBmdW5jdGlvbiAjZGVjb2RlRmxvYXRGcm9tRm91ckludHMuXG4gICAqXG4gICAqIFRoaXMgaXMgYWRhcHRlZCB0byBKYXZhU2NyaXB0IGZyb20gdGhlIGJhc2ljIGFwcHJvYWNoIGF0XG4gICAqIGh0dHA6Ly9hcmFzLXAuaW5mby9ibG9nLzIwMDkvMDcvMzAvZW5jb2RpbmctZmxvYXRzLXRvLXJnYmEtdGhlLWZpbmFsL1xuICAgKiBidXQgd3JpdGVzIG91dCBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgMC0yNTUgaW5zdGVhZCBvZiBmbG9hdHMgaW4gdGhlIHJhbmdlIDAtMVxuICAgKiBzbyB0aGV5IGNhbiBiZSBtb3JlIGVhc2lseSB1c2VkIGluIGEgVWludDhBcnJheSBmb3Igc3RhbmRhcmQgV2ViR0wgcmdiYSB0ZXh0dXJlcy5cbiAgICpcbiAgICogU29tZSBwcmVjaXNpb24gd2lsbCBuZWNlc3NhcmlseSBiZSBsb3N0IGR1cmluZyB0aGUgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHByb2Nlc3MuXG4gICAqIFRlc3Rpbmcgc2hvd3MgdGhhdCB0aGUgbWF4aW11bSBwcmVjaXNpb24gZXJyb3IgaXMgfjEuMThlLTEwIHdoaWNoIHNob3VsZCBiZSBnb29kXG4gICAqIGVub3VnaCBmb3IgbW9zdCBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciB0byBlbmNvZGUuIE11c3QgYmUgaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgKiAgICAgICAgb3RoZXJ3aXNlIHRoZSByZXN1bHRzIHdpbGwgYmUgaW5jb3JyZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fFVpbnQ4QXJyYXl9IGFycmF5IC0gYW4gYXJyYXkgaW50byB3aGljaCB0aGUgZm91ciBpbnRzIHNob3VsZCBiZSB3cml0dGVuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4IC0gaW5kZXggaW4gdGhlIG91dHB1dCBhcnJheSBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nIHRoZSBpbnRzXG4gICAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBlbmNvZGVGbG9hdFRvRm91ckludHModmFsdWUsIGFycmF5LCBzdGFydEluZGV4KSB7XG4gICAgLy8gVGhpcyBpcyBhZGFwdGVkIHRvIEpTIGZyb20gdGhlIGJhc2ljIGFwcHJvYWNoIGF0XG4gICAgLy8gaHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXG4gICAgLy8gYnV0IHdyaXRlcyB0byBhIFVpbnQ4QXJyYXkgaW5zdGVhZCBvZiBmbG9hdHMuIElucHV0IHZhbHVlcyBtdXN0IGJlIGluXG4gICAgLy8gdGhlIHJhbmdlIFswLCAxXS4gVGhlIG1heGltdW0gZXJyb3IgYWZ0ZXIgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGlzIH4xLjE4ZS0xMFxuICAgIHZhciBlbmMwID0gMjU1ICogdmFsdWU7XG4gICAgdmFyIGVuYzEgPSAyNTUgKiAoZW5jMCAlIDEpO1xuICAgIHZhciBlbmMyID0gMjU1ICogKGVuYzEgJSAxKTtcbiAgICB2YXIgZW5jMyA9IDI1NSAqIChlbmMyICUgMSk7XG5cbiAgICBlbmMwID0gZW5jMCAmIDI1NTtcbiAgICBlbmMxID0gZW5jMSAmIDI1NTtcbiAgICBlbmMyID0gZW5jMiAmIDI1NTtcbiAgICBlbmMzID0gTWF0aC5yb3VuZChlbmMzKSAmIDI1NTtcblxuICAgIGFycmF5W3N0YXJ0SW5kZXhdID0gZW5jMDtcbiAgICBhcnJheVtzdGFydEluZGV4ICsgMV0gPSBlbmMxO1xuICAgIGFycmF5W3N0YXJ0SW5kZXggKyAyXSA9IGVuYzI7XG4gICAgYXJyYXlbc3RhcnRJbmRleCArIDNdID0gZW5jMztcbiAgICByZXR1cm4gYXJyYXlcbiAgfVxuXG4gIC8qXG4gIElucHV0IGdlb21ldHJ5IGlzIGEgY3lsaW5kZXIgd2l0aCByPTEsIGhlaWdodCBpbiB5IGRpbWVuc2lvbiBmcm9tIDAgdG8gMSxcbiAgZGl2aWRlZCBpbnRvIGEgcmVhc29uYWJsZSBudW1iZXIgb2YgaGVpZ2h0IHNlZ21lbnRzLlxuICAqL1xuXG4gIHZhciB2ZXJ0ZXhEZWZzID0gXCJcXG51bmlmb3JtIHZlYzMgcG9pbnRBO1xcbnVuaWZvcm0gdmVjMyBjb250cm9sQTtcXG51bmlmb3JtIHZlYzMgY29udHJvbEI7XFxudW5pZm9ybSB2ZWMzIHBvaW50QjtcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XFxuXFxudmVjMyBjdWJpY0Jlemllcih2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XFxuICBmbG9hdCB0MiA9IDEuMCAtIHQ7XFxuICBmbG9hdCBiMCA9IHQyICogdDIgKiB0MjtcXG4gIGZsb2F0IGIxID0gMy4wICogdCAqIHQyICogdDI7XFxuICBmbG9hdCBiMiA9IDMuMCAqIHQgKiB0ICogdDI7XFxuICBmbG9hdCBiMyA9IHQgKiB0ICogdDtcXG4gIHJldHVybiBiMCAqIHAxICsgYjEgKiBjMSArIGIyICogYzIgKyBiMyAqIHAyO1xcbn1cXG5cXG52ZWMzIGN1YmljQmV6aWVyRGVyaXZhdGl2ZSh2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XFxuICBmbG9hdCB0MiA9IDEuMCAtIHQ7XFxuICByZXR1cm4gLTMuMCAqIHAxICogdDIgKiB0MiArXFxuICAgIGMxICogKDMuMCAqIHQyICogdDIgLSA2LjAgKiB0MiAqIHQpICtcXG4gICAgYzIgKiAoNi4wICogdDIgKiB0IC0gMy4wICogdCAqIHQpICtcXG4gICAgMy4wICogcDIgKiB0ICogdDtcXG59XFxuXCI7XG5cbiAgdmFyIHZlcnRleFRyYW5zZm9ybSA9IFwiXFxuZmxvYXQgdCA9IHBvc2l0aW9uLnk7XFxuYmV6aWVyVCA9IHQ7XFxudmVjMyBiZXppZXJDZW50ZXJQb3MgPSBjdWJpY0Jlemllcihwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KTtcXG52ZWMzIGJlemllckRpciA9IG5vcm1hbGl6ZShjdWJpY0JlemllckRlcml2YXRpdmUocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCkpO1xcblxcbi8vIE1ha2UgXFxcInNpZGV3YXlzXFxcIiBhbHdheXMgcGVycGVuZGljdWxhciB0byB0aGUgY2FtZXJhIHJheTsgdGhpcyBlbnN1cmVzIHRoYXQgYW55IHR3aXN0c1xcbi8vIGluIHRoZSBjeWxpbmRlciBvY2N1ciB3aGVyZSB5b3Ugd29uJ3Qgc2VlIHRoZW06IFxcbnZlYzMgdmlld0RpcmVjdGlvbiA9IG5vcm1hbE1hdHJpeCAqIHZlYzMoMC4wLCAwLjAsIDEuMCk7XFxuaWYgKGJlemllckRpciA9PSB2aWV3RGlyZWN0aW9uKSB7XFxuICBiZXppZXJEaXIgPSBub3JtYWxpemUoY3ViaWNCZXppZXJEZXJpdmF0aXZlKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQgPT0gMS4wID8gdCAtIDAuMDAwMSA6IHQgKyAwLjAwMDEpKTtcXG59XFxudmVjMyBzaWRld2F5cyA9IG5vcm1hbGl6ZShjcm9zcyhiZXppZXJEaXIsIHZpZXdEaXJlY3Rpb24pKTtcXG52ZWMzIHVwaXNoID0gbm9ybWFsaXplKGNyb3NzKHNpZGV3YXlzLCBiZXppZXJEaXIpKTtcXG5cXG4vLyBCdWlsZCBhIG1hdHJpeCBmb3IgdHJhbnNmb3JtaW5nIHRoaXMgZGlzYyBpbiB0aGUgY3lsaW5kZXI6XFxubWF0NCBkaXNjVHg7XFxuZGlzY1R4WzBdLnh5eiA9IHNpZGV3YXlzICogcmFkaXVzO1xcbmRpc2NUeFsxXS54eXogPSBiZXppZXJEaXIgKiByYWRpdXM7XFxuZGlzY1R4WzJdLnh5eiA9IHVwaXNoICogcmFkaXVzO1xcbmRpc2NUeFszXS54eXogPSBiZXppZXJDZW50ZXJQb3M7XFxuZGlzY1R4WzNdWzNdID0gMS4wO1xcblxcbi8vIEFwcGx5IHRyYW5zZm9ybSwgaWdub3Jpbmcgb3JpZ2luYWwgeVxcbnBvc2l0aW9uID0gKGRpc2NUeCAqIHZlYzQocG9zaXRpb24ueCwgMC4wLCBwb3NpdGlvbi56LCAxLjApKS54eXo7XFxubm9ybWFsID0gbm9ybWFsaXplKG1hdDMoZGlzY1R4KSAqIG5vcm1hbCk7XFxuXCI7XG5cbiAgdmFyIGZyYWdtZW50RGVmcyA9IFwiXFxudW5pZm9ybSB2ZWMzIGRhc2hpbmc7XFxudmFyeWluZyBmbG9hdCBiZXppZXJUO1xcblwiO1xuXG4gIHZhciBmcmFnbWVudE1haW5JbnRybyA9IFwiXFxuaWYgKGRhc2hpbmcueCArIGRhc2hpbmcueSA+IDAuMCkge1xcbiAgZmxvYXQgZGFzaEZyYWMgPSBtb2QoYmV6aWVyVCAtIGRhc2hpbmcueiwgZGFzaGluZy54ICsgZGFzaGluZy55KTtcXG4gIGlmIChkYXNoRnJhYyA+IGRhc2hpbmcueCkge1xcbiAgICBkaXNjYXJkO1xcbiAgfVxcbn1cXG5cIjtcblxuICAvLyBEZWJ1Z2dpbmc6IHNlcGFyYXRlIGNvbG9yIGZvciBlYWNoIG9mIHRoZSA2IHNpZGVzOlxuICAvLyBjb25zdCBmcmFnbWVudENvbG9yVHJhbnNmb3JtID0gYFxuICAvLyBmbG9hdCBzaWRlTnVtID0gZmxvb3IodlVWLnggKiA2LjApO1xuICAvLyB2ZWMzIG1peENvbG9yID0gc2lkZU51bSA8IDEuMCA/IHZlYzMoMS4wLCAwLjAsIDAuMCkgOlxuICAvLyAgIHNpZGVOdW0gPCAyLjAgPyB2ZWMzKDAuMCwgMS4wLCAxLjApIDpcbiAgLy8gICBzaWRlTnVtIDwgMy4wID8gdmVjMygxLjAsIDEuMCwgMC4wKSA6XG4gIC8vICAgc2lkZU51bSA8IDQuMCA/IHZlYzMoMC4wLCAwLjAsIDEuMCkgOlxuICAvLyAgIHNpZGVOdW0gPCA1LjAgPyB2ZWMzKDAuMCwgMS4wLCAwLjApIDpcbiAgLy8gICB2ZWMzKDEuMCwgMC4wLCAxLjApO1xuICAvLyBnbF9GcmFnQ29sb3IueHl6ID0gbWl4KGdsX0ZyYWdDb2xvci54eXosIG1peENvbG9yLCAwLjUpO1xuICAvLyBgXG5cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgYmFzZU1hdGVyaWFsLFxuICAgICAge1xuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHBvaW50QToge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSxcbiAgICAgICAgICBjb250cm9sQToge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSxcbiAgICAgICAgICBjb250cm9sQjoge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSxcbiAgICAgICAgICBwb2ludEI6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoKX0sXG4gICAgICAgICAgcmFkaXVzOiB7dmFsdWU6IDAuMDF9LFxuICAgICAgICAgIGRhc2hpbmc6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoKX0gLy9vbiwgb2ZmLCBvZmZzZXRcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGV4RGVmczogdmVydGV4RGVmcyxcbiAgICAgICAgdmVydGV4VHJhbnNmb3JtOiB2ZXJ0ZXhUcmFuc2Zvcm0sXG4gICAgICAgIGZyYWdtZW50RGVmczogZnJhZ21lbnREZWZzLFxuICAgICAgICBmcmFnbWVudE1haW5JbnRybzogZnJhZ21lbnRNYWluSW50cm9cbiAgICAgIH1cbiAgICApXG4gIH1cblxuICB2YXIgZ2VvbWV0cnkgPSBudWxsO1xuXG4gIHZhciBkZWZhdWx0QmFzZU1hdGVyaWFsID0gbmV3IHRocmVlLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtjb2xvcjogMHhmZmZmZmYsIHNpZGU6IHRocmVlLkRvdWJsZVNpZGV9KTtcblxuXG4gIC8qKlxuICAgKiBBIFRocmVlSlMgYE1lc2hgIHRoYXQgYmVuZHMgYSB0dWJlIHNoYXBlIGFsb25nIGEgM0QgY3ViaWMgYmV6aWVyIHBhdGguIFRoZSBiZW5kaW5nIGlzIGRvbmVcbiAgICogYnkgZGVmb3JtaW5nIGEgc3RyYWlnaHQgY3lsaW5kcmljYWwgZ2VvbWV0cnkgaW4gdGhlIHZlcnRleCBzaGFkZXIgYmFzZWQgb24gYSBzZXQgb2YgZm91clxuICAgKiBjb250cm9sIHBvaW50IHVuaWZvcm1zLiBJdCBwYXRjaGVzIHRoZSBuZWNlc3NhcnkgR0xTTCBpbnRvIHRoZSBtZXNoJ3MgYXNzaWduZWQgYG1hdGVyaWFsYFxuICAgKiBhdXRvbWF0aWNhbGx5LlxuICAgKlxuICAgKiBUaGUgY3ViaXogYmV6aWVyIHBhdGggaXMgZGV0ZXJtaW5lZCBieSBpdHMgZm91ciBgVmVjdG9yM2AgcHJvcGVydGllczpcbiAgICogLSBgcG9pbnRBYFxuICAgKiAtIGBjb250cm9sQWBcbiAgICogLSBgY29udHJvbEJgXG4gICAqIC0gYHBvaW50QmBcbiAgICpcbiAgICogVGhlIHR1YmUncyByYWRpdXMgaXMgY29udHJvbGxlZCBieSBpdHMgYHJhZGl1c2AgcHJvcGVydHksIHdoaWNoIGRlZmF1bHRzIHRvIGAwLjAxYC5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIGdpdmUgdGhlIHR1YmUgYSBkYXNoZWQgYXBwZWFyYW5jZSB3aXRoIHR3byBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAtIGBkYXNoQXJyYXlgIC0gYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMsIGRlZmluaW5nIHRoZSBsZW5ndGggb2YgXCJvblwiIGFuZCBcIm9mZlwiIHBhcnRzIG9mXG4gICAqICAgdGhlIGRhc2guIEVhY2ggaXMgYSAwLTEgcmF0aW8gb2YgdGhlIGVudGlyZSBwYXRoJ3MgbGVuZ3RoLiAoQWN0dWFsbHkgdGhpcyBpcyB0aGUgYHRgIGxlbmd0aFxuICAgKiAgIHVzZWQgYXMgaW5wdXQgdG8gdGhlIGN1YmljIGJlemllciBmdW5jdGlvbiwgbm90IGl0cyB2aXNpYmxlIGxlbmd0aC4pXG4gICAqIC0gYGRhc2hPZmZzZXRgIC0gb2Zmc2V0IG9mIHdoZXJlIHRoZSBkYXNoIHN0YXJ0cy4gWW91IGNhbiBhbmltYXRlIHRoaXMgdG8gbWFrZSB0aGUgZGFzaGVzIG1vdmUuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgZGFzaGVzIHdpbGwgYXBwZWFyIGxpa2UgYSBob2xsb3cgdHViZSwgbm90IHNvbGlkLiBUaGlzIHdpbGwgYmUgbW9yZSBhcHBhcmVudCBvblxuICAgKiB0aGlja2VyIHR1YmVzLlxuICAgKlxuICAgKiBUT0RPOiBwcm9wZXIgZ2VvbWV0cnkgYm91bmRpbmcgc3BoZXJlIGFuZCByYXljYXN0aW5nXG4gICAqIFRPRE86IGFsbG93IGNvbnRyb2wgb2YgdGhlIGdlb21ldHJ5J3Mgc2VnbWVudCBjb3VudHNcbiAgICovXG4gIHZhciBCZXppZXJNZXNoID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWVzaCkge1xuICAgIGZ1bmN0aW9uIEJlemllck1lc2goKSB7XG4gICAgICBNZXNoLmNhbGwoXG4gICAgICAgIHRoaXMsIGdlb21ldHJ5IHx8IChnZW9tZXRyeSA9XG4gICAgICAgICAgbmV3IHRocmVlLkN5bGluZGVyQnVmZmVyR2VvbWV0cnkoMSwgMSwgMSwgNiwgNjQpLnRyYW5zbGF0ZSgwLCAwLjUsIDApXG4gICAgICAgICksXG4gICAgICAgIGRlZmF1bHRCYXNlTWF0ZXJpYWxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMucG9pbnRBID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY29udHJvbEEgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICAgICAgdGhpcy5jb250cm9sQiA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgICB0aGlzLnBvaW50QiA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgICB0aGlzLnJhZGl1cyA9IDAuMDE7XG4gICAgICB0aGlzLmRhc2hBcnJheSA9IG5ldyB0aHJlZS5WZWN0b3IyKCk7XG4gICAgICB0aGlzLmRhc2hPZmZzZXQgPSAwO1xuXG4gICAgICAvLyBUT0RPIC0gZGlzYWJsaW5nIGZydXN0dW0gY3VsbGluZyB1bnRpbCBJIGZpZ3VyZSBvdXQgaG93IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICAgIC8vICBnZW9tZXRyeSdzIGJvdW5kaW5nIHNwaGVyZSB0aGF0IGdldHMgdXNlZFxuICAgICAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCBNZXNoICkgQmV6aWVyTWVzaC5fX3Byb3RvX18gPSBNZXNoO1xuICAgIEJlemllck1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaCAmJiBNZXNoLnByb3RvdHlwZSApO1xuICAgIEJlemllck1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmV6aWVyTWVzaDtcblxuICAgIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IG1hdGVyaWFsOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGN1c3RvbURlcHRoTWF0ZXJpYWw6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY3VzdG9tRGlzdGFuY2VNYXRlcmlhbDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gICAgLy8gSGFuZGxlciBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyB0aGUgYmFzZSBtYXRlcmlhbCB3aXRoIG91ciB1cGdyYWRlcy4gV2UgZG8gdGhlIHdyYXBwaW5nXG4gICAgLy8gbGF6aWx5IG9uIF9yZWFkXyByYXRoZXIgdGhhbiB3cml0ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3cmFwcGluZyBvbiB0cmFuc2llbnQgdmFsdWVzLlxuICAgIHByb3RvdHlwZUFjY2Vzc29ycy5tYXRlcmlhbC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsO1xuICAgICAgdmFyIGJhc2VNYXRlcmlhbCA9IHRoaXMuX2Jhc2VNYXRlcmlhbCB8fCBkZWZhdWx0QmFzZU1hdGVyaWFsO1xuICAgICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgZGVyaXZlZE1hdGVyaWFsLmJhc2VNYXRlcmlhbCAhPT0gYmFzZU1hdGVyaWFsKSB7XG4gICAgICAgIGlmIChkZXJpdmVkTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpO1xuICAgICAgICAvLyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHdoZW4gaXRzIGJhc2UgbWF0ZXJpYWwgaXMgZGlzcG9zZWQ6XG4gICAgICAgIGJhc2VNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICAgIGJhc2VNYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25EaXNwb3NlKTtcbiAgICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXJpdmVkTWF0ZXJpYWxcbiAgICB9O1xuICAgIHByb3RvdHlwZUFjY2Vzc29ycy5tYXRlcmlhbC5zZXQgPSBmdW5jdGlvbiAoYmFzZU1hdGVyaWFsKSB7XG4gICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBhbmQgdXBkYXRlIG1hdGVyaWFsIGZvciBzaGFkb3dzIHVwb24gcmVxdWVzdDpcbiAgICBwcm90b3R5cGVBY2Nlc3NvcnMuY3VzdG9tRGVwdGhNYXRlcmlhbC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlQmV6aWVyVW5pZm9ybXModGhpcy5tYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKCkpXG4gICAgfTtcbiAgICBwcm90b3R5cGVBY2Nlc3NvcnMuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlQmV6aWVyVW5pZm9ybXModGhpcy5tYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKCkpXG4gICAgfTtcblxuICAgIEJlemllck1lc2gucHJvdG90eXBlLm9uQmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gb25CZWZvcmVSZW5kZXIgKHNoYWRlckluZm8pIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJlemllclVuaWZvcm1zKHRoaXMubWF0ZXJpYWwpO1xuICAgIH07XG5cbiAgICBCZXppZXJNZXNoLnByb3RvdHlwZS5fdXBkYXRlQmV6aWVyVW5pZm9ybXMgPSBmdW5jdGlvbiBfdXBkYXRlQmV6aWVyVW5pZm9ybXMgKG1hdGVyaWFsKSB7XG4gICAgICB2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIHBvaW50QSA9IHJlZi5wb2ludEE7XG4gICAgICB2YXIgY29udHJvbEEgPSByZWYuY29udHJvbEE7XG4gICAgICB2YXIgY29udHJvbEIgPSByZWYuY29udHJvbEI7XG4gICAgICB2YXIgcG9pbnRCID0gcmVmLnBvaW50QjtcbiAgICAgIHZhciByYWRpdXMgPSByZWYucmFkaXVzO1xuICAgICAgdmFyIGRhc2hBcnJheSA9IHJlZi5kYXNoQXJyYXk7XG4gICAgICB2YXIgZGFzaE9mZnNldCA9IHJlZi5kYXNoT2Zmc2V0O1xuICAgICAgdW5pZm9ybXMucG9pbnRBLnZhbHVlLmNvcHkocG9pbnRBKTtcbiAgICAgIHVuaWZvcm1zLmNvbnRyb2xBLnZhbHVlLmNvcHkoY29udHJvbEEpO1xuICAgICAgdW5pZm9ybXMuY29udHJvbEIudmFsdWUuY29weShjb250cm9sQik7XG4gICAgICB1bmlmb3Jtcy5wb2ludEIudmFsdWUuY29weShwb2ludEIpO1xuICAgICAgdW5pZm9ybXMucmFkaXVzLnZhbHVlID0gcmFkaXVzO1xuICAgICAgdW5pZm9ybXMuZGFzaGluZy52YWx1ZS5zZXQoZGFzaEFycmF5LngsIGRhc2hBcnJheS55LCBkYXNoT2Zmc2V0IHx8IDApO1xuICAgICAgcmV0dXJuIG1hdGVyaWFsXG4gICAgfTtcblxuICAgIEJlemllck1lc2gucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbiByYXljYXN0IChyYXljYXN0ZXIsIGludGVyc2VjdHMpIHtcbiAgICAgIC8vIFRPRE8gLSBqdXN0IGZhaWwgZm9yIG5vd1xuICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggQmV6aWVyTWVzaC5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gICAgcmV0dXJuIEJlemllck1lc2g7XG4gIH0odGhyZWUuTWVzaCkpO1xuXG4gIGV4cG9ydHMuQmV6aWVyTWVzaCA9IEJlemllck1lc2g7XG4gIGV4cG9ydHMuU2hhZGVyRmxvYXRBcnJheSA9IFNoYWRlckZsb2F0QXJyYXk7XG4gIGV4cG9ydHMuY3JlYXRlRGVyaXZlZE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsO1xuICBleHBvcnRzLmV4cGFuZFNoYWRlckluY2x1ZGVzID0gZXhwYW5kU2hhZGVySW5jbHVkZXM7XG4gIGV4cG9ydHMuZ2V0U2hhZGVyVW5pZm9ybVR5cGVzID0gZ2V0U2hhZGVyVW5pZm9ybVR5cGVzO1xuICBleHBvcnRzLmdldFNoYWRlcnNGb3JNYXRlcmlhbCA9IGdldFNoYWRlcnNGb3JNYXRlcmlhbDtcbiAgZXhwb3J0cy52b2lkTWFpblJlZ0V4cCA9IHZvaWRNYWluUmVnRXhwO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxXQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/troika-three-utils/dist/troika-three-utils.umd.js\n");

/***/ }),

/***/ "./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js":
/*!**************************************************************************!*\
  !*** ./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n  /**\n   * Lightweight thenable implementation that is entirely self-contained within a single\n   * function with no external dependencies so it can be easily shipped across to a WorkerModule.\n   *\n   * This implementation conforms fully to the Promises/A+ spec so it can safely interoperate\n   * with other thenable implementations. https://github.com/promises-aplus/promises-spec\n   *\n   * *However*, it is _not_ a full implementation of ES2015 Promises, e.g. it does not\n   * have the same constructor signature and does not expose a `catch` method or the static\n   * `resolve`/`reject`/`all`/`race` initializer methods. If you need to hand a Thenable\n   * instance off to consuming code that may expect a true Promise, you'll want to wrap it\n   * in a native-or-polyfilled Promise first.\n   *\n   * (Why yet another Promises/A+ implementation? Great question. We needed a polyfill-like\n   * thing that was (a) wrapped in a single function for easy serialization across to a Worker,\n   * and (b) was as small as possible -- at ~900B minified (~500B gzipped) this is the smallest\n   * implementation I've found. And also, exercises like this are challenging and fun.)\n   */\n  function BespokeThenable() {\n    var state = 0; // 0=pending, 1=fulfilled, -1=rejected\n    var queue = [];\n    var value;\n    var scheduled = 0;\n    var completeCalled = 0;\n\n    function then(onResolve, onReject) {\n      var nextThenable = BespokeThenable();\n\n      function handleNext() {\n        var cb = state > 0 ? onResolve : onReject;\n        if (isFn(cb)) {\n          try {\n            var result = cb(value);\n            if (result === nextThenable) {\n              recursiveError();\n            }\n            var resultThen = getThenableThen(result);\n            if (resultThen) {\n              resultThen.call(result, nextThenable.resolve, nextThenable.reject);\n            } else {\n              nextThenable.resolve(result);\n            }\n          } catch (err) {\n            nextThenable.reject(err);\n          }\n        } else {\n          nextThenable[state > 0 ? 'resolve' : 'reject'](value);\n        }\n      }\n\n      queue.push(handleNext);\n      if (state) {\n        scheduleQueueFlush();\n      }\n      return nextThenable\n    }\n\n    var resolve = oneTime(function (val) {\n      if (!completeCalled) {\n        complete(1, val);\n      }\n    });\n\n    var reject = oneTime(function (reason) {\n      if (!completeCalled) {\n        complete(-1, reason);\n      }\n    });\n\n    function complete(st, val) {\n      completeCalled++;\n      var ignoreThrow = 0;\n      try {\n        if (val === thenableObj) {\n          recursiveError();\n        }\n        var valThen = st > 0 && getThenableThen(val);\n        if (valThen) {\n          valThen.call(val, oneTime(function (v) {\n            ignoreThrow++;\n            complete(1, v);\n          }), oneTime(function (v) {\n            ignoreThrow++;\n            complete(-1, v);\n          }));\n        } else {\n          state = st;\n          value = val;\n          scheduleQueueFlush();\n        }\n      } catch(e) {\n        if (!state && !ignoreThrow) {\n          complete(-1, e);\n        }\n      }\n    }\n\n    function scheduleQueueFlush() {\n      if (!scheduled) {\n        setTimeout(flushQueue, 0); //TODO setImmediate or postMessage approach if available?\n        scheduled = 1;\n      }\n    }\n\n    function flushQueue() {\n      var q = queue;\n      scheduled = 0;\n      queue = [];\n      q.forEach(callIt);\n    }\n\n    function callIt(fn) {\n      fn();\n    }\n\n    function getThenableThen(val) {\n      var valThen = val && (isFn(val) || typeof val === 'object') && val.then;\n      return isFn(valThen) && valThen\n    }\n\n    function oneTime(fn) {\n      var called = 0;\n      return function() {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        if (!called++) {\n          fn.apply(this, args);\n        }\n      }\n    }\n\n    function recursiveError() {\n      throw new TypeError('Chaining cycle detected')\n    }\n\n    var isFn = function (v) { return typeof v === 'function'; };\n\n    var thenableObj = {\n      then: then,\n      resolve: resolve,\n      reject: reject\n    };\n    return thenableObj\n  }\n\n\n  /**\n   * Thenable implementation that uses a native Promise under the covers. This implementation\n   * is preferred if Promise is available, for better performance and dev tools integration.\n   * @constructor\n   */\n  function NativePromiseThenable() {\n    var resolve, reject;\n    var promise = new Promise(function (res, rej) {\n      resolve = res;\n      reject = rej;\n    });\n    return {\n      then: promise.then.bind(promise),\n      resolve: resolve,\n      reject: reject\n    }\n  }\n\n\n  /**\n   * Choose the best Thenable implementation and export it as the default.\n   */\n  var Thenable = (\n    typeof Promise === 'function' ? NativePromiseThenable : BespokeThenable\n  );\n\n  var _workerModuleId = 0;\n  var _messageId = 0;\n  var workers = Object.create(null);\n  var openRequests = Object.create(null);\n  openRequests._count = 0;\n\n\n  /**\n   * Define a module of code that will be executed with a web worker. This provides a simple\n   * interface for moving chunks of logic off the main thread, and managing their dependencies\n   * among one another.\n   *\n   * @param {object} options\n   * @param {function} options.init - The main function that initializes the module. This will be run\n   *        within the worker, and will be passed the resolved dependencies as arguments. Its\n   *        return value becomes the module's content, which can then be used by other modules\n   *        that depend on it. This function can perform any logic using those dependencies, but\n   *        must not depend on anything from its parent closures.\n   * @param {array} [options.dependencies] - Provides any dependencies required by the init function:\n   *        - Primitives like strings, numbers, booleans\n   *        - Raw functions; these will be stringified and rehydrated within the worker so they\n   *          must not depend on anything from their parent closures\n   *        - Other worker modules; these will be resolved within the worker, and therefore modules\n   *          that provide functions can be called without having to cross the worker/main thread\n   *          boundary.\n   * @param {function} [options.getTransferables] - An optional function that will be run in the worker\n   *        just before posting the response value from a module call back to the main thread.\n   *        It will be passed that response value, and if it returns an array then that will be\n   *        used as the \"transferables\" parameter to `postMessage`. Use this if there are values\n   *        in the response that can/should be transfered rather than cloned.\n   * @param {string} [options.workerId] - By default all modules will run in the same dedicated worker,\n   *        but if you want to use multiple workers you can pass a `workerId` to indicate a specific\n   *        worker to spawn. Note that each worker is completely standalone and no data or state will\n   *        be shared between them. If a worker module is used as a dependency by worker modules\n   *        using different `workerId`s, then that dependency will be re-registered in each worker.\n   * @return {function(...[*]): {then}}\n   */\n  function defineWorkerModule(options) {\n    if (!options || typeof options.init !== 'function') {\n      throw new Error('requires `options.init` function')\n    }\n    var dependencies = options.dependencies;\n    var init = options.init;\n    var getTransferables = options.getTransferables;\n    var workerId = options.workerId;\n    if (workerId == null) {\n      workerId = '#default';\n    }\n    var id = \"workerModule\" + (++_workerModuleId);\n    var registrationThenable = null;\n\n    dependencies = dependencies && dependencies.map(function (dep) {\n      // Wrap raw functions as worker modules with no dependencies\n      if (typeof dep === 'function' && !dep.workerModuleData) {\n        dep = defineWorkerModule({\n          workerId: workerId,\n          init: new Function((\"return function(){return (\" + (stringifyFunction(dep)) + \")}\"))()\n        });\n      }\n      // Grab postable data for worker modules\n      if (dep && dep.workerModuleData) {\n        dep = dep.workerModuleData;\n      }\n      return dep\n    });\n\n    function moduleFunc() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // Register this module if needed\n      if (!registrationThenable) {\n        registrationThenable = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n      }\n\n      // Invoke the module, returning a thenable\n      return registrationThenable.then(function (ref) {\n        var isCallable = ref.isCallable;\n\n        if (isCallable) {\n          return callWorker(workerId,'callModule', {id: id, args: args})\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function')\n        }\n      })\n    }\n    moduleFunc.workerModuleData = {\n      isWorkerModule: true,\n      id: id,\n      dependencies: dependencies,\n      init: stringifyFunction(init),\n      getTransferables: getTransferables && stringifyFunction(getTransferables)\n    };\n    return moduleFunc\n  }\n\n  /**\n   * Stringifies a function into a form that can be deserialized in the worker\n   * @param fn\n   */\n  function stringifyFunction(fn) {\n    var str = fn.toString();\n    // If it was defined in object method/property format, it needs to be modified\n    if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n      str = 'function ' + str;\n    }\n    return str\n  }\n\n\n  function getWorker(workerId) {\n    var worker = workers[workerId];\n    if (!worker) {\n      // Bootstrap the worker's content\n      var bootstrap = (function() {\n        var modules = Object.create(null);\n\n        // Handle messages for registering a module\n        function registerModule(ref, callback) {\n          var id = ref.id;\n          var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n          var init = ref.init; if ( init === void 0 ) init = function(){};\n          var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n          // Only register once\n          if (modules[id]) { return }\n\n          try {\n            // If any dependencies are modules, ensure they're registered and grab their value\n            dependencies = dependencies.map(function (dep) {\n              if (dep && dep.isWorkerModule) {\n                registerModule(dep, function (depResult) {\n                  if (depResult instanceof Error) { throw depResult }\n                });\n                dep = modules[dep.id].value;\n              }\n              return dep\n            });\n\n            // Rehydrate functions\n            init = new Function((\"return (\" + init + \")\"))();\n            if (getTransferables) {\n              getTransferables = new Function((\"return (\" + getTransferables + \")\"))();\n            }\n\n            // Initialize the module and store its value\n            var value = init.apply(void 0, dependencies);\n            modules[id] = {\n              id: id,\n              value: value,\n              getTransferables: getTransferables\n            };\n            callback(value);\n          } catch(err) {\n            if (!(err && err.noLog)) {\n              console.error(err);\n            }\n            callback(err);\n          }\n        }\n\n        // Handle messages for calling a registered module's result function\n        function callModule(ref, callback) {\n          var ref$1;\n\n          var id = ref.id;\n          var args = ref.args;\n          if (!modules[id] || typeof modules[id].value !== 'function') {\n            callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n          }\n          try {\n            var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n            if (result && typeof result.then === 'function') {\n              result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n            } else {\n              handleResult(result);\n            }\n          } catch(err) {\n            callback(err);\n          }\n          function handleResult(result) {\n            try {\n              var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n              if (!tx || !Array.isArray(tx) || !tx.length) {\n                tx = undefined; //postMessage is very picky about not passing null or empty transferables\n              }\n              callback(result, tx);\n            } catch(err) {\n              console.error(err);\n              callback(err);\n            }\n          }\n        }\n\n        // Handler for all messages within the worker\n        self.addEventListener('message', function (e) {\n          var ref = e.data;\n          var messageId = ref.messageId;\n          var action = ref.action;\n          var data = ref.data;\n          try {\n            // Module registration\n            if (action === 'registerModule') {\n              registerModule(data, function (result) {\n                if (result instanceof Error) {\n                  postMessage({\n                    messageId: messageId,\n                    success: false,\n                    error: result.message\n                  });\n                } else {\n                  postMessage({\n                    messageId: messageId,\n                    success: true,\n                    result: {isCallable: typeof result === 'function'}\n                  });\n                }\n              });\n            }\n            // Invocation\n            if (action === 'callModule') {\n              callModule(data, function (result, transferables) {\n                if (result instanceof Error) {\n                  postMessage({\n                    messageId: messageId,\n                    success: false,\n                    error: result.message\n                  });\n                } else {\n                  postMessage({\n                    messageId: messageId,\n                    success: true,\n                    result: result\n                  }, transferables || undefined);\n                }\n              });\n            }\n          } catch(err) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: err.stack\n            });\n          }\n        });\n      }).toString();\n\n      // Create the worker from the bootstrap function content\n      worker = workers[workerId] = new Worker(\n        URL.createObjectURL(\n          new Blob([(\";(\" + bootstrap + \")()\")], {type: 'application/javascript'})\n        )\n      );\n\n      // Single handler for response messages from the worker\n      worker.onmessage = function (e) {\n        var response = e.data;\n        var msgId = response.messageId;\n        var callback = openRequests[msgId];\n        if (!callback) {\n          throw new Error('WorkerModule response with empty or unknown messageId')\n        }\n        delete openRequests[msgId];\n        openRequests.count--;\n        callback(response);\n      };\n    }\n    return worker\n  }\n\n  // Issue a call to the worker with a callback to handle the response\n  function callWorker(workerId, action, data) {\n    var thenable = Thenable();\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        thenable.resolve(response.result);\n      } else {\n        thenable.reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n      }\n    };\n    openRequests._count++;\n    if (openRequests.count > 1000) { //detect leaks\n      console.warn('Large number of open WorkerModule requests, some may not be returning');\n    }\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n    return thenable\n  }\n\n  /**\n   * Just the {@link Thenable} function wrapped as a worker module. If another worker\n   * module needs Thenable as a dependency, it's better to pass this module rather than\n   * the raw function in its `dependencies` array so it only gets registered once.\n   */\n  var ThenableWorkerModule = defineWorkerModule({\n    dependencies: [Thenable],\n    init: function(Thenable) {\n      return Thenable\n    }\n  });\n\n  exports.Thenable = Thenable;\n  exports.ThenableWorkerModule = ThenableWorkerModule;\n  exports.defineWorkerModule = defineWorkerModule;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHJvaWthLXdvcmtlci11dGlscy9kaXN0L3Ryb2lrYS13b3JrZXItdXRpbHMudW1kLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ryb2lrYS13b3JrZXItdXRpbHMvZGlzdC90cm9pa2Etd29ya2VyLXV0aWxzLnVtZC5qcz81YTdmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC50cm9pa2Ffd29ya2VyX3V0aWxzID0ge30pKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogTGlnaHR3ZWlnaHQgdGhlbmFibGUgaW1wbGVtZW50YXRpb24gdGhhdCBpcyBlbnRpcmVseSBzZWxmLWNvbnRhaW5lZCB3aXRoaW4gYSBzaW5nbGVcbiAgICogZnVuY3Rpb24gd2l0aCBubyBleHRlcm5hbCBkZXBlbmRlbmNpZXMgc28gaXQgY2FuIGJlIGVhc2lseSBzaGlwcGVkIGFjcm9zcyB0byBhIFdvcmtlck1vZHVsZS5cbiAgICpcbiAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjb25mb3JtcyBmdWxseSB0byB0aGUgUHJvbWlzZXMvQSsgc3BlYyBzbyBpdCBjYW4gc2FmZWx5IGludGVyb3BlcmF0ZVxuICAgKiB3aXRoIG90aGVyIHRoZW5hYmxlIGltcGxlbWVudGF0aW9ucy4gaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWNcbiAgICpcbiAgICogKkhvd2V2ZXIqLCBpdCBpcyBfbm90XyBhIGZ1bGwgaW1wbGVtZW50YXRpb24gb2YgRVMyMDE1IFByb21pc2VzLCBlLmcuIGl0IGRvZXMgbm90XG4gICAqIGhhdmUgdGhlIHNhbWUgY29uc3RydWN0b3Igc2lnbmF0dXJlIGFuZCBkb2VzIG5vdCBleHBvc2UgYSBgY2F0Y2hgIG1ldGhvZCBvciB0aGUgc3RhdGljXG4gICAqIGByZXNvbHZlYC9gcmVqZWN0YC9gYWxsYC9gcmFjZWAgaW5pdGlhbGl6ZXIgbWV0aG9kcy4gSWYgeW91IG5lZWQgdG8gaGFuZCBhIFRoZW5hYmxlXG4gICAqIGluc3RhbmNlIG9mZiB0byBjb25zdW1pbmcgY29kZSB0aGF0IG1heSBleHBlY3QgYSB0cnVlIFByb21pc2UsIHlvdSdsbCB3YW50IHRvIHdyYXAgaXRcbiAgICogaW4gYSBuYXRpdmUtb3ItcG9seWZpbGxlZCBQcm9taXNlIGZpcnN0LlxuICAgKlxuICAgKiAoV2h5IHlldCBhbm90aGVyIFByb21pc2VzL0ErIGltcGxlbWVudGF0aW9uPyBHcmVhdCBxdWVzdGlvbi4gV2UgbmVlZGVkIGEgcG9seWZpbGwtbGlrZVxuICAgKiB0aGluZyB0aGF0IHdhcyAoYSkgd3JhcHBlZCBpbiBhIHNpbmdsZSBmdW5jdGlvbiBmb3IgZWFzeSBzZXJpYWxpemF0aW9uIGFjcm9zcyB0byBhIFdvcmtlcixcbiAgICogYW5kIChiKSB3YXMgYXMgc21hbGwgYXMgcG9zc2libGUgLS0gYXQgfjkwMEIgbWluaWZpZWQgKH41MDBCIGd6aXBwZWQpIHRoaXMgaXMgdGhlIHNtYWxsZXN0XG4gICAqIGltcGxlbWVudGF0aW9uIEkndmUgZm91bmQuIEFuZCBhbHNvLCBleGVyY2lzZXMgbGlrZSB0aGlzIGFyZSBjaGFsbGVuZ2luZyBhbmQgZnVuLilcbiAgICovXG4gIGZ1bmN0aW9uIEJlc3Bva2VUaGVuYWJsZSgpIHtcbiAgICB2YXIgc3RhdGUgPSAwOyAvLyAwPXBlbmRpbmcsIDE9ZnVsZmlsbGVkLCAtMT1yZWplY3RlZFxuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgc2NoZWR1bGVkID0gMDtcbiAgICB2YXIgY29tcGxldGVDYWxsZWQgPSAwO1xuXG4gICAgZnVuY3Rpb24gdGhlbihvblJlc29sdmUsIG9uUmVqZWN0KSB7XG4gICAgICB2YXIgbmV4dFRoZW5hYmxlID0gQmVzcG9rZVRoZW5hYmxlKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU5leHQoKSB7XG4gICAgICAgIHZhciBjYiA9IHN0YXRlID4gMCA/IG9uUmVzb2x2ZSA6IG9uUmVqZWN0O1xuICAgICAgICBpZiAoaXNGbihjYikpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNiKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG5leHRUaGVuYWJsZSkge1xuICAgICAgICAgICAgICByZWN1cnNpdmVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdFRoZW4gPSBnZXRUaGVuYWJsZVRoZW4ocmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRUaGVuKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFRoZW4uY2FsbChyZXN1bHQsIG5leHRUaGVuYWJsZS5yZXNvbHZlLCBuZXh0VGhlbmFibGUucmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5leHRUaGVuYWJsZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBuZXh0VGhlbmFibGUucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRUaGVuYWJsZVtzdGF0ZSA+IDAgPyAncmVzb2x2ZScgOiAncmVqZWN0J10odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlLnB1c2goaGFuZGxlTmV4dCk7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc2NoZWR1bGVRdWV1ZUZsdXNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dFRoZW5hYmxlXG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBvbmVUaW1lKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGlmICghY29tcGxldGVDYWxsZWQpIHtcbiAgICAgICAgY29tcGxldGUoMSwgdmFsKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmVUaW1lKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmICghY29tcGxldGVDYWxsZWQpIHtcbiAgICAgICAgY29tcGxldGUoLTEsIHJlYXNvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZShzdCwgdmFsKSB7XG4gICAgICBjb21wbGV0ZUNhbGxlZCsrO1xuICAgICAgdmFyIGlnbm9yZVRocm93ID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh2YWwgPT09IHRoZW5hYmxlT2JqKSB7XG4gICAgICAgICAgcmVjdXJzaXZlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsVGhlbiA9IHN0ID4gMCAmJiBnZXRUaGVuYWJsZVRoZW4odmFsKTtcbiAgICAgICAgaWYgKHZhbFRoZW4pIHtcbiAgICAgICAgICB2YWxUaGVuLmNhbGwodmFsLCBvbmVUaW1lKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZ25vcmVUaHJvdysrO1xuICAgICAgICAgICAgY29tcGxldGUoMSwgdik7XG4gICAgICAgICAgfSksIG9uZVRpbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlnbm9yZVRocm93Kys7XG4gICAgICAgICAgICBjb21wbGV0ZSgtMSwgdik7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gc3Q7XG4gICAgICAgICAgdmFsdWUgPSB2YWw7XG4gICAgICAgICAgc2NoZWR1bGVRdWV1ZUZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBpZiAoIXN0YXRlICYmICFpZ25vcmVUaHJvdykge1xuICAgICAgICAgIGNvbXBsZXRlKC0xLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUXVldWVGbHVzaCgpIHtcbiAgICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZmx1c2hRdWV1ZSwgMCk7IC8vVE9ETyBzZXRJbW1lZGlhdGUgb3IgcG9zdE1lc3NhZ2UgYXBwcm9hY2ggaWYgYXZhaWxhYmxlP1xuICAgICAgICBzY2hlZHVsZWQgPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsdXNoUXVldWUoKSB7XG4gICAgICB2YXIgcSA9IHF1ZXVlO1xuICAgICAgc2NoZWR1bGVkID0gMDtcbiAgICAgIHF1ZXVlID0gW107XG4gICAgICBxLmZvckVhY2goY2FsbEl0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsSXQoZm4pIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGhlbmFibGVUaGVuKHZhbCkge1xuICAgICAgdmFyIHZhbFRoZW4gPSB2YWwgJiYgKGlzRm4odmFsKSB8fCB0eXBlb2YgdmFsID09PSAnb2JqZWN0JykgJiYgdmFsLnRoZW47XG4gICAgICByZXR1cm4gaXNGbih2YWxUaGVuKSAmJiB2YWxUaGVuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25lVGltZShmbikge1xuICAgICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgaWYgKCFjYWxsZWQrKykge1xuICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlRXJyb3IoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFpbmluZyBjeWNsZSBkZXRlY3RlZCcpXG4gICAgfVxuXG4gICAgdmFyIGlzRm4gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYgPT09ICdmdW5jdGlvbic7IH07XG5cbiAgICB2YXIgdGhlbmFibGVPYmogPSB7XG4gICAgICB0aGVuOiB0aGVuLFxuICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIHJlamVjdDogcmVqZWN0XG4gICAgfTtcbiAgICByZXR1cm4gdGhlbmFibGVPYmpcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFRoZW5hYmxlIGltcGxlbWVudGF0aW9uIHRoYXQgdXNlcyBhIG5hdGl2ZSBQcm9taXNlIHVuZGVyIHRoZSBjb3ZlcnMuIFRoaXMgaW1wbGVtZW50YXRpb25cbiAgICogaXMgcHJlZmVycmVkIGlmIFByb21pc2UgaXMgYXZhaWxhYmxlLCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBkZXYgdG9vbHMgaW50ZWdyYXRpb24uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTmF0aXZlUHJvbWlzZVRoZW5hYmxlKCkge1xuICAgIHZhciByZXNvbHZlLCByZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRoZW46IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpLFxuICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIHJlamVjdDogcmVqZWN0XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQ2hvb3NlIHRoZSBiZXN0IFRoZW5hYmxlIGltcGxlbWVudGF0aW9uIGFuZCBleHBvcnQgaXQgYXMgdGhlIGRlZmF1bHQuXG4gICAqL1xuICB2YXIgVGhlbmFibGUgPSAoXG4gICAgdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgPyBOYXRpdmVQcm9taXNlVGhlbmFibGUgOiBCZXNwb2tlVGhlbmFibGVcbiAgKTtcblxuICB2YXIgX3dvcmtlck1vZHVsZUlkID0gMDtcbiAgdmFyIF9tZXNzYWdlSWQgPSAwO1xuICB2YXIgd29ya2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBvcGVuUmVxdWVzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBvcGVuUmVxdWVzdHMuX2NvdW50ID0gMDtcblxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBtb2R1bGUgb2YgY29kZSB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2l0aCBhIHdlYiB3b3JrZXIuIFRoaXMgcHJvdmlkZXMgYSBzaW1wbGVcbiAgICogaW50ZXJmYWNlIGZvciBtb3ZpbmcgY2h1bmtzIG9mIGxvZ2ljIG9mZiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBtYW5hZ2luZyB0aGVpciBkZXBlbmRlbmNpZXNcbiAgICogYW1vbmcgb25lIGFub3RoZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuaW5pdCAtIFRoZSBtYWluIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIG1vZHVsZS4gVGhpcyB3aWxsIGJlIHJ1blxuICAgKiAgICAgICAgd2l0aGluIHRoZSB3b3JrZXIsIGFuZCB3aWxsIGJlIHBhc3NlZCB0aGUgcmVzb2x2ZWQgZGVwZW5kZW5jaWVzIGFzIGFyZ3VtZW50cy4gSXRzXG4gICAqICAgICAgICByZXR1cm4gdmFsdWUgYmVjb21lcyB0aGUgbW9kdWxlJ3MgY29udGVudCwgd2hpY2ggY2FuIHRoZW4gYmUgdXNlZCBieSBvdGhlciBtb2R1bGVzXG4gICAqICAgICAgICB0aGF0IGRlcGVuZCBvbiBpdC4gVGhpcyBmdW5jdGlvbiBjYW4gcGVyZm9ybSBhbnkgbG9naWMgdXNpbmcgdGhvc2UgZGVwZW5kZW5jaWVzLCBidXRcbiAgICogICAgICAgIG11c3Qgbm90IGRlcGVuZCBvbiBhbnl0aGluZyBmcm9tIGl0cyBwYXJlbnQgY2xvc3VyZXMuXG4gICAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmRlcGVuZGVuY2llc10gLSBQcm92aWRlcyBhbnkgZGVwZW5kZW5jaWVzIHJlcXVpcmVkIGJ5IHRoZSBpbml0IGZ1bmN0aW9uOlxuICAgKiAgICAgICAgLSBQcmltaXRpdmVzIGxpa2Ugc3RyaW5ncywgbnVtYmVycywgYm9vbGVhbnNcbiAgICogICAgICAgIC0gUmF3IGZ1bmN0aW9uczsgdGhlc2Ugd2lsbCBiZSBzdHJpbmdpZmllZCBhbmQgcmVoeWRyYXRlZCB3aXRoaW4gdGhlIHdvcmtlciBzbyB0aGV5XG4gICAqICAgICAgICAgIG11c3Qgbm90IGRlcGVuZCBvbiBhbnl0aGluZyBmcm9tIHRoZWlyIHBhcmVudCBjbG9zdXJlc1xuICAgKiAgICAgICAgLSBPdGhlciB3b3JrZXIgbW9kdWxlczsgdGhlc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoaW4gdGhlIHdvcmtlciwgYW5kIHRoZXJlZm9yZSBtb2R1bGVzXG4gICAqICAgICAgICAgIHRoYXQgcHJvdmlkZSBmdW5jdGlvbnMgY2FuIGJlIGNhbGxlZCB3aXRob3V0IGhhdmluZyB0byBjcm9zcyB0aGUgd29ya2VyL21haW4gdGhyZWFkXG4gICAqICAgICAgICAgIGJvdW5kYXJ5LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5nZXRUcmFuc2ZlcmFibGVzXSAtIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBydW4gaW4gdGhlIHdvcmtlclxuICAgKiAgICAgICAganVzdCBiZWZvcmUgcG9zdGluZyB0aGUgcmVzcG9uc2UgdmFsdWUgZnJvbSBhIG1vZHVsZSBjYWxsIGJhY2sgdG8gdGhlIG1haW4gdGhyZWFkLlxuICAgKiAgICAgICAgSXQgd2lsbCBiZSBwYXNzZWQgdGhhdCByZXNwb25zZSB2YWx1ZSwgYW5kIGlmIGl0IHJldHVybnMgYW4gYXJyYXkgdGhlbiB0aGF0IHdpbGwgYmVcbiAgICogICAgICAgIHVzZWQgYXMgdGhlIFwidHJhbnNmZXJhYmxlc1wiIHBhcmFtZXRlciB0byBgcG9zdE1lc3NhZ2VgLiBVc2UgdGhpcyBpZiB0aGVyZSBhcmUgdmFsdWVzXG4gICAqICAgICAgICBpbiB0aGUgcmVzcG9uc2UgdGhhdCBjYW4vc2hvdWxkIGJlIHRyYW5zZmVyZWQgcmF0aGVyIHRoYW4gY2xvbmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMud29ya2VySWRdIC0gQnkgZGVmYXVsdCBhbGwgbW9kdWxlcyB3aWxsIHJ1biBpbiB0aGUgc2FtZSBkZWRpY2F0ZWQgd29ya2VyLFxuICAgKiAgICAgICAgYnV0IGlmIHlvdSB3YW50IHRvIHVzZSBtdWx0aXBsZSB3b3JrZXJzIHlvdSBjYW4gcGFzcyBhIGB3b3JrZXJJZGAgdG8gaW5kaWNhdGUgYSBzcGVjaWZpY1xuICAgKiAgICAgICAgd29ya2VyIHRvIHNwYXduLiBOb3RlIHRoYXQgZWFjaCB3b3JrZXIgaXMgY29tcGxldGVseSBzdGFuZGFsb25lIGFuZCBubyBkYXRhIG9yIHN0YXRlIHdpbGxcbiAgICogICAgICAgIGJlIHNoYXJlZCBiZXR3ZWVuIHRoZW0uIElmIGEgd29ya2VyIG1vZHVsZSBpcyB1c2VkIGFzIGEgZGVwZW5kZW5jeSBieSB3b3JrZXIgbW9kdWxlc1xuICAgKiAgICAgICAgdXNpbmcgZGlmZmVyZW50IGB3b3JrZXJJZGBzLCB0aGVuIHRoYXQgZGVwZW5kZW5jeSB3aWxsIGJlIHJlLXJlZ2lzdGVyZWQgaW4gZWFjaCB3b3JrZXIuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLlsqXSk6IHt0aGVufX1cbiAgICovXG4gIGZ1bmN0aW9uIGRlZmluZVdvcmtlck1vZHVsZShvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zLmluaXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgYG9wdGlvbnMuaW5pdGAgZnVuY3Rpb24nKVxuICAgIH1cbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gb3B0aW9ucy5kZXBlbmRlbmNpZXM7XG4gICAgdmFyIGluaXQgPSBvcHRpb25zLmluaXQ7XG4gICAgdmFyIGdldFRyYW5zZmVyYWJsZXMgPSBvcHRpb25zLmdldFRyYW5zZmVyYWJsZXM7XG4gICAgdmFyIHdvcmtlcklkID0gb3B0aW9ucy53b3JrZXJJZDtcbiAgICBpZiAod29ya2VySWQgPT0gbnVsbCkge1xuICAgICAgd29ya2VySWQgPSAnI2RlZmF1bHQnO1xuICAgIH1cbiAgICB2YXIgaWQgPSBcIndvcmtlck1vZHVsZVwiICsgKCsrX3dvcmtlck1vZHVsZUlkKTtcbiAgICB2YXIgcmVnaXN0cmF0aW9uVGhlbmFibGUgPSBudWxsO1xuXG4gICAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkge1xuICAgICAgLy8gV3JhcCByYXcgZnVuY3Rpb25zIGFzIHdvcmtlciBtb2R1bGVzIHdpdGggbm8gZGVwZW5kZW5jaWVzXG4gICAgICBpZiAodHlwZW9mIGRlcCA9PT0gJ2Z1bmN0aW9uJyAmJiAhZGVwLndvcmtlck1vZHVsZURhdGEpIHtcbiAgICAgICAgZGVwID0gZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICAgICAgICB3b3JrZXJJZDogd29ya2VySWQsXG4gICAgICAgICAgaW5pdDogbmV3IEZ1bmN0aW9uKChcInJldHVybiBmdW5jdGlvbigpe3JldHVybiAoXCIgKyAoc3RyaW5naWZ5RnVuY3Rpb24oZGVwKSkgKyBcIil9XCIpKSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gR3JhYiBwb3N0YWJsZSBkYXRhIGZvciB3b3JrZXIgbW9kdWxlc1xuICAgICAgaWYgKGRlcCAmJiBkZXAud29ya2VyTW9kdWxlRGF0YSkge1xuICAgICAgICBkZXAgPSBkZXAud29ya2VyTW9kdWxlRGF0YTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXBcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1vZHVsZUZ1bmMoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgLy8gUmVnaXN0ZXIgdGhpcyBtb2R1bGUgaWYgbmVlZGVkXG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvblRoZW5hYmxlKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvblRoZW5hYmxlID0gY2FsbFdvcmtlcih3b3JrZXJJZCwncmVnaXN0ZXJNb2R1bGUnLCBtb2R1bGVGdW5jLndvcmtlck1vZHVsZURhdGEpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnZva2UgdGhlIG1vZHVsZSwgcmV0dXJuaW5nIGEgdGhlbmFibGVcbiAgICAgIHJldHVybiByZWdpc3RyYXRpb25UaGVuYWJsZS50aGVuKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIGlzQ2FsbGFibGUgPSByZWYuaXNDYWxsYWJsZTtcblxuICAgICAgICBpZiAoaXNDYWxsYWJsZSkge1xuICAgICAgICAgIHJldHVybiBjYWxsV29ya2VyKHdvcmtlcklkLCdjYWxsTW9kdWxlJywge2lkOiBpZCwgYXJnczogYXJnc30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgbW9kdWxlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYnV0IGBpbml0YCBkaWQgbm90IHJldHVybiBhIGNhbGxhYmxlIGZ1bmN0aW9uJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgbW9kdWxlRnVuYy53b3JrZXJNb2R1bGVEYXRhID0ge1xuICAgICAgaXNXb3JrZXJNb2R1bGU6IHRydWUsXG4gICAgICBpZDogaWQsXG4gICAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcbiAgICAgIGluaXQ6IHN0cmluZ2lmeUZ1bmN0aW9uKGluaXQpLFxuICAgICAgZ2V0VHJhbnNmZXJhYmxlczogZ2V0VHJhbnNmZXJhYmxlcyAmJiBzdHJpbmdpZnlGdW5jdGlvbihnZXRUcmFuc2ZlcmFibGVzKVxuICAgIH07XG4gICAgcmV0dXJuIG1vZHVsZUZ1bmNcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpbmdpZmllcyBhIGZ1bmN0aW9uIGludG8gYSBmb3JtIHRoYXQgY2FuIGJlIGRlc2VyaWFsaXplZCBpbiB0aGUgd29ya2VyXG4gICAqIEBwYXJhbSBmblxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5RnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgc3RyID0gZm4udG9TdHJpbmcoKTtcbiAgICAvLyBJZiBpdCB3YXMgZGVmaW5lZCBpbiBvYmplY3QgbWV0aG9kL3Byb3BlcnR5IGZvcm1hdCwgaXQgbmVlZHMgdG8gYmUgbW9kaWZpZWRcbiAgICBpZiAoIS9eZnVuY3Rpb24vLnRlc3Qoc3RyKSAmJiAvXlxcdytcXHMqXFwoLy50ZXN0KHN0cikpIHtcbiAgICAgIHN0ciA9ICdmdW5jdGlvbiAnICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuXG4gIGZ1bmN0aW9uIGdldFdvcmtlcih3b3JrZXJJZCkge1xuICAgIHZhciB3b3JrZXIgPSB3b3JrZXJzW3dvcmtlcklkXTtcbiAgICBpZiAoIXdvcmtlcikge1xuICAgICAgLy8gQm9vdHN0cmFwIHRoZSB3b3JrZXIncyBjb250ZW50XG4gICAgICB2YXIgYm9vdHN0cmFwID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbW9kdWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgLy8gSGFuZGxlIG1lc3NhZ2VzIGZvciByZWdpc3RlcmluZyBhIG1vZHVsZVxuICAgICAgICBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZShyZWYsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGlkID0gcmVmLmlkO1xuICAgICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSByZWYuZGVwZW5kZW5jaWVzOyBpZiAoIGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwICkgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgICAgdmFyIGluaXQgPSByZWYuaW5pdDsgaWYgKCBpbml0ID09PSB2b2lkIDAgKSBpbml0ID0gZnVuY3Rpb24oKXt9O1xuICAgICAgICAgIHZhciBnZXRUcmFuc2ZlcmFibGVzID0gcmVmLmdldFRyYW5zZmVyYWJsZXM7IGlmICggZ2V0VHJhbnNmZXJhYmxlcyA9PT0gdm9pZCAwICkgZ2V0VHJhbnNmZXJhYmxlcyA9IG51bGw7XG5cbiAgICAgICAgICAvLyBPbmx5IHJlZ2lzdGVyIG9uY2VcbiAgICAgICAgICBpZiAobW9kdWxlc1tpZF0pIHsgcmV0dXJuIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJZiBhbnkgZGVwZW5kZW5jaWVzIGFyZSBtb2R1bGVzLCBlbnN1cmUgdGhleSdyZSByZWdpc3RlcmVkIGFuZCBncmFiIHRoZWlyIHZhbHVlXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgaWYgKGRlcCAmJiBkZXAuaXNXb3JrZXJNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICByZWdpc3Rlck1vZHVsZShkZXAsIGZ1bmN0aW9uIChkZXBSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkZXBSZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikgeyB0aHJvdyBkZXBSZXN1bHQgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlcCA9IG1vZHVsZXNbZGVwLmlkXS52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZGVwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVoeWRyYXRlIGZ1bmN0aW9uc1xuICAgICAgICAgICAgaW5pdCA9IG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gKFwiICsgaW5pdCArIFwiKVwiKSkoKTtcbiAgICAgICAgICAgIGlmIChnZXRUcmFuc2ZlcmFibGVzKSB7XG4gICAgICAgICAgICAgIGdldFRyYW5zZmVyYWJsZXMgPSBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIChcIiArIGdldFRyYW5zZmVyYWJsZXMgKyBcIilcIikpKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG1vZHVsZSBhbmQgc3RvcmUgaXRzIHZhbHVlXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpbml0LmFwcGx5KHZvaWQgMCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgIG1vZHVsZXNbaWRdID0ge1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgZ2V0VHJhbnNmZXJhYmxlczogZ2V0VHJhbnNmZXJhYmxlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgaWYgKCEoZXJyICYmIGVyci5ub0xvZykpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgbWVzc2FnZXMgZm9yIGNhbGxpbmcgYSByZWdpc3RlcmVkIG1vZHVsZSdzIHJlc3VsdCBmdW5jdGlvblxuICAgICAgICBmdW5jdGlvbiBjYWxsTW9kdWxlKHJlZiwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVmJDE7XG5cbiAgICAgICAgICB2YXIgaWQgPSByZWYuaWQ7XG4gICAgICAgICAgdmFyIGFyZ3MgPSByZWYuYXJncztcbiAgICAgICAgICBpZiAoIW1vZHVsZXNbaWRdIHx8IHR5cGVvZiBtb2R1bGVzW2lkXS52YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKChcIldvcmtlciBtb2R1bGUgXCIgKyBpZCArIFwiOiBub3QgZm91bmQgb3IgaXRzICdpbml0JyBkaWQgbm90IHJldHVybiBhIGZ1bmN0aW9uXCIpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gKHJlZiQxID0gbW9kdWxlc1tpZF0pLnZhbHVlLmFwcGx5KHJlZiQxLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC50aGVuKGhhbmRsZVJlc3VsdCwgZnVuY3Rpb24gKHJlaikgeyByZXR1cm4gY2FsbGJhY2socmVqIGluc3RhbmNlb2YgRXJyb3IgPyByZWogOiBuZXcgRXJyb3IoJycgKyByZWopKTsgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYW5kbGVSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHR4ID0gbW9kdWxlc1tpZF0uZ2V0VHJhbnNmZXJhYmxlcyAmJiBtb2R1bGVzW2lkXS5nZXRUcmFuc2ZlcmFibGVzKHJlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghdHggfHwgIUFycmF5LmlzQXJyYXkodHgpIHx8ICF0eC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0eCA9IHVuZGVmaW5lZDsgLy9wb3N0TWVzc2FnZSBpcyB2ZXJ5IHBpY2t5IGFib3V0IG5vdCBwYXNzaW5nIG51bGwgb3IgZW1wdHkgdHJhbnNmZXJhYmxlc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCwgdHgpO1xuICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZXIgZm9yIGFsbCBtZXNzYWdlcyB3aXRoaW4gdGhlIHdvcmtlclxuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciByZWYgPSBlLmRhdGE7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VJZCA9IHJlZi5tZXNzYWdlSWQ7XG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHJlZi5hY3Rpb247XG4gICAgICAgICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTW9kdWxlIHJlZ2lzdHJhdGlvblxuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JlZ2lzdGVyTW9kdWxlJykge1xuICAgICAgICAgICAgICByZWdpc3Rlck1vZHVsZShkYXRhLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7aXNDYWxsYWJsZTogdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJ31cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbnZvY2F0aW9uXG4gICAgICAgICAgICBpZiAoYWN0aW9uID09PSAnY2FsbE1vZHVsZScpIHtcbiAgICAgICAgICAgICAgY2FsbE1vZHVsZShkYXRhLCBmdW5jdGlvbiAocmVzdWx0LCB0cmFuc2ZlcmFibGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IGVyci5zdGFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLnRvU3RyaW5nKCk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgd29ya2VyIGZyb20gdGhlIGJvb3RzdHJhcCBmdW5jdGlvbiBjb250ZW50XG4gICAgICB3b3JrZXIgPSB3b3JrZXJzW3dvcmtlcklkXSA9IG5ldyBXb3JrZXIoXG4gICAgICAgIFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgICAgbmV3IEJsb2IoWyhcIjsoXCIgKyBib290c3RyYXAgKyBcIikoKVwiKV0sIHt0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCd9KVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICAvLyBTaW5nbGUgaGFuZGxlciBmb3IgcmVzcG9uc2UgbWVzc2FnZXMgZnJvbSB0aGUgd29ya2VyXG4gICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gZS5kYXRhO1xuICAgICAgICB2YXIgbXNnSWQgPSByZXNwb25zZS5tZXNzYWdlSWQ7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IG9wZW5SZXF1ZXN0c1ttc2dJZF07XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlck1vZHVsZSByZXNwb25zZSB3aXRoIGVtcHR5IG9yIHVua25vd24gbWVzc2FnZUlkJylcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgb3BlblJlcXVlc3RzW21zZ0lkXTtcbiAgICAgICAgb3BlblJlcXVlc3RzLmNvdW50LS07XG4gICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJcbiAgfVxuXG4gIC8vIElzc3VlIGEgY2FsbCB0byB0aGUgd29ya2VyIHdpdGggYSBjYWxsYmFjayB0byBoYW5kbGUgdGhlIHJlc3BvbnNlXG4gIGZ1bmN0aW9uIGNhbGxXb3JrZXIod29ya2VySWQsIGFjdGlvbiwgZGF0YSkge1xuICAgIHZhciB0aGVuYWJsZSA9IFRoZW5hYmxlKCk7XG4gICAgdmFyIG1lc3NhZ2VJZCA9ICsrX21lc3NhZ2VJZDtcbiAgICBvcGVuUmVxdWVzdHNbbWVzc2FnZUlkXSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhlbmFibGUucmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhlbmFibGUucmVqZWN0KG5ldyBFcnJvcigoXCJFcnJvciBpbiB3b3JrZXIgXCIgKyBhY3Rpb24gKyBcIiBjYWxsOiBcIiArIChyZXNwb25zZS5lcnJvcikpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvcGVuUmVxdWVzdHMuX2NvdW50Kys7XG4gICAgaWYgKG9wZW5SZXF1ZXN0cy5jb3VudCA+IDEwMDApIHsgLy9kZXRlY3QgbGVha3NcbiAgICAgIGNvbnNvbGUud2FybignTGFyZ2UgbnVtYmVyIG9mIG9wZW4gV29ya2VyTW9kdWxlIHJlcXVlc3RzLCBzb21lIG1heSBub3QgYmUgcmV0dXJuaW5nJyk7XG4gICAgfVxuICAgIGdldFdvcmtlcih3b3JrZXJJZCkucG9zdE1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgICByZXR1cm4gdGhlbmFibGVcbiAgfVxuXG4gIC8qKlxuICAgKiBKdXN0IHRoZSB7QGxpbmsgVGhlbmFibGV9IGZ1bmN0aW9uIHdyYXBwZWQgYXMgYSB3b3JrZXIgbW9kdWxlLiBJZiBhbm90aGVyIHdvcmtlclxuICAgKiBtb2R1bGUgbmVlZHMgVGhlbmFibGUgYXMgYSBkZXBlbmRlbmN5LCBpdCdzIGJldHRlciB0byBwYXNzIHRoaXMgbW9kdWxlIHJhdGhlciB0aGFuXG4gICAqIHRoZSByYXcgZnVuY3Rpb24gaW4gaXRzIGBkZXBlbmRlbmNpZXNgIGFycmF5IHNvIGl0IG9ubHkgZ2V0cyByZWdpc3RlcmVkIG9uY2UuXG4gICAqL1xuICB2YXIgVGhlbmFibGVXb3JrZXJNb2R1bGUgPSBkZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgIGRlcGVuZGVuY2llczogW1RoZW5hYmxlXSxcbiAgICBpbml0OiBmdW5jdGlvbihUaGVuYWJsZSkge1xuICAgICAgcmV0dXJuIFRoZW5hYmxlXG4gICAgfVxuICB9KTtcblxuICBleHBvcnRzLlRoZW5hYmxlID0gVGhlbmFibGU7XG4gIGV4cG9ydHMuVGhlbmFibGVXb3JrZXJNb2R1bGUgPSBUaGVuYWJsZVdvcmtlck1vZHVsZTtcbiAgZXhwb3J0cy5kZWZpbmVXb3JrZXJNb2R1bGUgPSBkZWZpbmVXb3JrZXJNb2R1bGU7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFdBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js\n");

/***/ })

})